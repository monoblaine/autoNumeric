(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n *               autoNumeric.js\r\n *\r\n * @version      2.0.12\r\n * @date         2017-04-07 UTC 07:00\r\n *\r\n * @author       Bob Knothe\r\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n *               cf. AUTHORS.md.\r\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n * @since        2009-08-09\r\n *\r\n * @summary      autoNumeric is a library that provides live as-you-type\r\n *               formatting for international numbers and currencies.\r\n *\r\n *               Note : Some functions are borrowed from big.js\r\n * @link         https://github.com/MikeMcl/big.js/\r\n *\r\n * Please report any bugs to https://github.com/autoNumeric/autoNumeric\r\n *\r\n * @license      Released under the MIT License\r\n * @link         http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar getLanguages = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\r\n * List of allowed tag on which autoNumeric can be used.\r\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\r\n * Defaults options are public - these can be overridden by the following method:\r\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" €\">`)\r\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' €' });`)\r\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n */\nvar defaultSettings = {\n    /* Allowed thousand grouping separator characters :\r\n     * ','      // Comma\r\n     * '.'      // Dot\r\n     * ' '      // Normal space\r\n     * '\\u2009' // Thin-space\r\n     * '\\u202f' // Narrow no-break space\r\n     * '\\u00a0' // No-break space\r\n     * ''       // No separator\r\n     * \"'\"      // Apostrophe\r\n     * '٬'      // Arabic thousands separator\r\n     * '˙'      // Dot above\r\n     * Deprecated older option name : aSep\r\n     */\n    digitGroupSeparator: ',',\n\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n     * example if the input value \"$ 1,999.88 suffix\"\r\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n     * Deprecated older option name : nSep\r\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\r\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n     * Deprecated older option name : dGroup\r\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters :\r\n     * ',' : Comma\r\n     * '.' : Dot\r\n     * '·' : Middle-dot\r\n     * '٫' : Arabic decimal separator\r\n     * '⎖' : Decimal separator key symbol\r\n     * Deprecated older option name : aDec\r\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n     * Deprecated older option name : altDec\r\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\r\n     * Must be in quotes currencySymbol: \"$\"\r\n     * space to the right of the currency symbol currencySymbol: '$ '\r\n     * space to the left of the currency symbol currencySymbol: ' $'\r\n     * Deprecated older option name : aSign\r\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n     * for prefix currencySymbolPlacement: \"p\" (default)\r\n     * for suffix currencySymbolPlacement: \"s\"\r\n     * Deprecated older option name : pSign\r\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n     * -1,234.56  => default no options required\r\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n     * Deprecated older option name : pNeg\r\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    negativePositiveSignPlacement: null,\n\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n     * By default, this positive sign is not shown.\r\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n     */\n    showPositiveSign: false,\n\n    /* Additional suffix\r\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n     * Numeric characters and negative sign not allowed'\r\n     * Deprecated older option name : aSuffix\r\n     */\n    suffixText: '',\n\n    /* Override min max limits\r\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n     * Deprecated older option name : oLimits\r\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be larger than minimumValue\r\n     * Deprecated older option name : vMax\r\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be smaller than maximumValue\r\n     * Deprecated older option name : vMin\r\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n     * Deprecated older option name : mDec\r\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\r\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n     * the \"get\" method returns the extended decimal places\r\n     * Deprecated older option name : eDec\r\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n     */\n    scaleDivisor: null,\n\n    /*\r\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n     * Deprecated older option name : scaleDecimal\r\n     */\n    scaleDecimalPlaces: null,\n\n    /*\r\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n     * This is optional too.\r\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n     * if ie 6 or 7 the value will be saved as a session cookie\r\n     * Deprecated older option name : aStor\r\n     */\n    saveValueToSessionStorage: false,\n\n    /*\r\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n     *                The non-pasted numbers are dropped and therefore not used at all.\r\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n     *\r\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n     *          Only the first number will be used (here '123').\r\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\r\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n     * roundingMethod: \"U05\" Rounds up to next .05\r\n     * roundingMethod: \"D05\" Rounds down to next .05\r\n     * Deprecated older option name : mRound\r\n     */\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\n    roundingMethod: 'S',\n\n    /* Allow padding the decimal places with zeros\r\n     * allowDecimalPadding: true - always Pad decimals with zeros\r\n     * allowDecimalPadding: false - does not pad with zeros.\r\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n     *\r\n     * thanks to Jonas Johansson for the suggestion\r\n     * Deprecated older option name : aPad\r\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n     * Those brackets are visible only when the field does NOT have the focus.\r\n     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n     * This option can be of the following values :\r\n     * null, // This is the default value, which deactivate this feature\r\n     * '(,)',\r\n     * '[,]',\r\n     * '<,>' or\r\n     * '{,}'\r\n     * Deprecated older option name : nBracket\r\n     */\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\r\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n     * Deprecated older option name : wEmpty\r\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\r\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n     * Deprecated older option name : lZero\r\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\r\n     * true = automatically formats the default value on initialization\r\n     * false = will not format the default value on initialization\r\n     * Deprecated older option name : aForm\r\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n     * Deprecated older option name : sNumber\r\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\r\n     * should be the value of the unformatted default value\r\n     * examples:\r\n     * no default value=\"\" {defaultValueOverride: \"\"}\r\n     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n     * Deprecated older option name : anDefault\r\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\r\n     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n     * review the 'unSet' method for other formats\r\n     * Deprecated older option name : unSetOnSubmit\r\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n     * Deprecated older option name : outputType\r\n     */\n    outputFormat: null,\n\n    /* Defines if warnings should be shown\r\n     * Error handling function\r\n     * true => all warning are shown\r\n     * false => no warnings are shown, only the thrown errors\r\n     * Deprecated older option name : debug\r\n     */\n    showWarnings: true,\n\n    /*\r\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n     */\n    failOnUnknownOption: false\n};\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n * //TODO Replace every call to this object with a call to `keyName`\r\n * @deprecated\r\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224,\n    AndroidDefault: 229 };\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n * Those names are listed here :\r\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n */\nvar keyName = {\n    // Special values\n    Unidentified: 'Unidentified',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta', // The Windows, Command or ⌘ key // 'OS' under Firefox and IE9\n    Windows: 'Meta', // This is a non-official key name\n    Command: 'Meta', // This is a non-official key name\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageDown: 'PageDown',\n    PageUp: 'PageUp',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    MultiplyNumpad: '*',\n    PlusNumpad: '+',\n    MinusNumpad: '-',\n    DotNumpad: '.',\n    SlashNumpad: '/',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\",\n    NumpadDot: '.',\n    NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n    NumpadMultiply: '*',\n    NumpadPlus: '+',\n    NumpadMinus: '-',\n    NumpadSlash: '/',\n    NumpadDotObsoleteBrowsers: 'Decimal',\n    NumpadMultiplyObsoleteBrowsers: 'Multiply',\n    NumpadPlusObsoleteBrowsers: 'Add',\n    NumpadMinusObsoleteBrowsers: 'Subtract',\n    NumpadSlashObsoleteBrowsers: 'Divide'\n};\n\nvar defaultMinimumValue = '-999999999999.99';\nvar defaultMaximumValue = '999999999999.99';\nvar defaultRoundingMethod = 'U';\nvar defaultLeadingZero = 'deny';\nvar defaultSelectNumberOnly = true;\n\n/**\r\n * Predefined options for the most common languages\r\n */\nvar languageOption = {\n    French: { // Français\n        digitGroupSeparator: '.', // or '\\u202f'\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: '\\u202F\\u20AC',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    NorthAmerican: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '$',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    British: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '£',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Swiss: { // Suisse\n        digitGroupSeparator: '\\'',\n        decimalCharacter: '.',\n        currencySymbol: '\\u202FCHF',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Japanese: { // 日本語\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '¥',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Turkish: {\n        digitGroupSeparator: '.',\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: ' ₺',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue,\n        negativePositiveSignPlacement: 'p'\n    }\n};\nlanguageOption.Spanish = languageOption.French; // Español (idem French)\nlanguageOption.Chinese = languageOption.Japanese; // 中国語 (Chinese)\n\n/**\r\n * UMD structure\r\n */\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    var jQueryOriginalVal = $.fn.val;\n\n    // Helper functions\n\n    /**\r\n     * Return TRUE if the `value` is null\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\r\n     * Return TRUE if the given parameter is a String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a boolean\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string 'true' or 'false'\r\n     *\r\n     * This function accepts any cases for those strings.\r\n     * @param {string} value\r\n     * @returns {boolean}\r\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an object\r\n     *\r\n     * @param {*} reference\r\n     * @returns {boolean}\r\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\r\n     * Return TRUE if the given object is empty\r\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n     *\r\n     * @param {object} obj\r\n     * @returns {boolean}\r\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a number (or a number written as a string).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an integer (and not a float).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\r\n     * Return the pasted text that will be used.\r\n     *\r\n     * @param {string} text\r\n     * @param {AutoNumericHolder} holder\r\n     * @returns {string|void|XML|*}\r\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {*} needle\r\n     * @param {Array} array\r\n     * @returns {boolean}\r\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n     *\r\n     * @param {string} str\r\n     * @returns {boolean}\r\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\r\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n     *\r\n     * @param {string} str\r\n     * @returns {int}\r\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\r\n     * Return the code for the key used to generate the given event.\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string|Number}\r\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\r\n     * Return the character from the event key code.\r\n     * @example character(50) => '2'\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string}\r\n     */\n    function character(event) {\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n            return String.fromCharCode(keyCodeNumber(event));\n        } else {\n            // Special case for obsolete browsers like IE that return the old names\n            var result = void 0;\n            switch (event.key) {\n                case 'Decimal':\n                    result = keyName.NumpadDot;\n                    break;\n                case 'Multiply':\n                    result = keyName.NumpadMultiply;\n                    break;\n                case 'Add':\n                    result = keyName.NumpadPlus;\n                    break;\n                case 'Subtract':\n                    result = keyName.NumpadMinus;\n                    break;\n                case 'Divide':\n                    result = keyName.NumpadSlash;\n                    break;\n                case 'Del':\n                    // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401 //FIXME à terminer\n                    result = keyName.Dot; // as of version 2.0.8 the character() function is only called on keypress event. The 'Del' does not throw the keypress event.\n                    break;\n                default:\n                    result = event.key;\n            }\n\n            return result;\n        }\n    }\n\n    /**\r\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n     * @returns {boolean}\r\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\r\n     * Return TRUE if the given string contains a negative sign :\r\n     * - everywhere in the string (by default), or\r\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n     *\r\n     * @param {string} numericString A number represented by a string\r\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n     * @returns {boolean}\r\n     */\n    function isNegative(numericString) {\n        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        //TODO Use the `negativeSignCharacter` from the settings here\n        if (checkEverywhere) {\n            return contains(numericString, '-');\n        }\n\n        return isNegativeStrict(numericString);\n    }\n\n    /**\r\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n     *\r\n     * @example isNegativeStrict('1234.56')     => false\r\n     * @example isNegativeStrict('1234.56-')    => false\r\n     * @example isNegativeStrict('-1234.56')    => true\r\n     * @example isNegativeStrict('-1,234.56 €') => true\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\n    function isNegativeStrict(numericString) {\n        //TODO Using the `negativeSignCharacter` from the settings here\n        return numericString.charAt(0) === '-';\n    }\n\n    /**\r\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 €'), or is empty (' €').\r\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\n    function isZeroOrHasNoValue(numericString) {\n        return !/[1-9]/g.test(numericString);\n    }\n\n    /**\r\n     * Return the negative version of the value (represented as a string) given as a parameter.\r\n     *\r\n     * @param {string} value\r\n     * @returns {*}\r\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegativeStrict(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\r\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n     *\r\n     * @param {string} string\r\n     * @param {int} index\r\n     * @param {string} newCharacter\r\n     * @returns {string}\r\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\r\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} settings\r\n     * @returns {number}\r\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\r\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n     *\r\n     * @param {string} formattedNumberString\r\n     * @param {int} caretPosition This must be a positive integer\r\n     * @param {string} decimalCharacter\r\n     * @returns {number}\r\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\r\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n     *\r\n     * @example\r\n     * 1234567|89.01   : position 7 (rawNumberString)\r\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n     *\r\n     * @param {string} rawNumberString\r\n     * @param {int} caretPositionInRawValue\r\n     * @param {string} formattedNumberString\r\n     * @param {string} decimalCharacter\r\n     * @returns {*}\r\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\r\n     * Count the number of occurrence of the given character, in the given text.\r\n     *\r\n     * @param {string} character\r\n     * @param {string} text\r\n     * @returns {number}\r\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\r\n     * Return the index that can be used to set the caret position.\r\n     * This takes into account that the position is starting at '0', not 1.\r\n     *\r\n     * @param {int} characterCount\r\n     * @returns {number}\r\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @returns {{}}\r\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @param {int} start\r\n     * @param {int|null} end\r\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\r\n     * Function that throw error messages\r\n     *\r\n     * @param {string} message\r\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\r\n     * Function that display a warning messages, according to the debug level.\r\n     *\r\n     * @param {string} message\r\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\r\n     * Run any callbacks found in the settings object.\r\n     * Any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\r\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n     *\r\n     * @param {string} minimumValue\r\n     * @param {string} maximumValue\r\n     * @returns {number}\r\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\r\n     * Strip all unwanted non-number characters.\r\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} leftOrAll\r\n     * @returns {string|*}\r\n     */\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n        //TODO Refactor this with `convertToNumericString()` if possible?\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Sets or removes brackets on negative values, depending on the focus state.\r\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n     * //TODO Use another object to keep track of internal data that are not settings\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            //TODO Split the first and last bracket only once during the settings initialization\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.hasFocus) {\n                // Add brackets\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n                // Remove brackets\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n     *\r\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n     * Lastly, it also put the negative sign back to its normal position if needed.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string|void|XML|*}\r\n     */\n    function convertToNumericString(s, settings) {\n        // Remove the currency symbol\n        s = s.replace(settings.currencySymbol, '');\n\n        // Remove the grouping separators (thousands separators usually)\n        s = s.replace(settings.digitGroupSeparator, '');\n\n        // Replace the decimal character by a dot\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n\n        // Move the trailing negative sign to the right position, if any\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        // Convert any arabic numbers to latin ones\n        var temp = arabicToLatinNumbers(s, true, false, false);\n        if (!isNaN(temp)) {\n            s = temp.toString();\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n     * See the \"outputFormat\" option definition for more details.\r\n     *\r\n     * @param {string|null} value\r\n     * @param {string} locale\r\n     * @returns {*}\r\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is not formatted with decimals\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Private function to check for empty value\r\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @param {boolean} signOnEmpty\r\n     * @returns {*}\r\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Modify the input value by adding the group separators, as defined in the settings.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n        if (settings.trailingNegative && !isNegative(inputValue)) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isValueNegative = isNegative(inputValue);\n        var isZero = isZeroOrHasNoValue(inputValue);\n        if (isValueNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        settings.trailingNegative = false;\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\r\n     * Truncate not needed zeros\r\n     *\r\n     * @param {string} roundedInputValue\r\n     * @param {int} temporaryDecimalPlacesOverride\r\n     * @returns {void|XML|string|*}\r\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\r\n     * Round the input value using the rounding method defined in the settings.\r\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n     *\r\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (isNegativeStrict(inputValue)) {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\r\n     * Truncates the decimal part of a number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} isPaste\r\n     * @returns {*}\r\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {number|string} n A numeric value.\r\n     * @returns {{}}\r\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (isNegativeStrict(n)) {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings.\r\n     * This uses the parsed strings for the above parseStr function.\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {object} y Big number instance\r\n     * @param {object} x Big number instance\r\n     * @returns {*}\r\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Check that the number satisfy the format conditions\r\n     * and lays between settings.minimumValue and settings.maximumValue\r\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Thanks to Anthony & Evan C\r\n     *\r\n     * @param {Element|string} element\r\n     * @returns {*|jQuery|HTMLElement}\r\n     */\n    function getCurrentElement(element) {\n        /*\r\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n         * for jQuery to be able to parse the selector correctly.\r\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\r\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     * @param {boolean} update\r\n     * @returns {*}\r\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\r\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\r\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n     * This is taken from Quirksmode.\r\n     *\r\n     * @param {string} name\r\n     * @returns {*}\r\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Test if sessionStorage is supported.\r\n     * This is taken from Modernizr.\r\n     *\r\n     * @returns {boolean}\r\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\r\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function cleanLeadingTrailingZeros(value, settings) {\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n        if (value === '') {\n            return '';\n        }\n\n        // Return '0' if the value is zero\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n            return '0';\n        }\n\n        if (settings.leadingZero !== 'keep') {\n            // Trim leading zero's - leaves one zero to the left of the decimal point\n            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n            if (contains(value, '.')) {\n                // Trims trailing zeros after the decimal point\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n        }\n        // Strips trailing decimal point\n        value = value.replace(/\\.$/, '');\n\n        return value;\n    }\n\n    /**\r\n     * Remove the trailing zeros in the decimal part of a number.\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {*}\r\n     */\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\n        var _numericString$split = numericString.split('.'),\n            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n            integerPart = _numericString$split2[0],\n            decimalPart = _numericString$split2[1];\n\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n            return integerPart;\n        }\n\n        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n        var result = void 0;\n        if (trimmedDecimalPart === '') {\n            result = integerPart;\n        } else {\n            result = integerPart + '.' + trimmedDecimalPart;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n     *\r\n     * @param {Element|EventTarget} element\r\n     * @param {object} settings\r\n     * @param {string} action\r\n     * @returns {*}\r\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Holder object for field properties\r\n     */\n\n    var AutoNumericHolder = function () {\n        /**\r\n         * Class constructor\r\n         *\r\n         * @param {HTMLElement} that - A reference to the current DOM element\r\n         * @param {object} settings\r\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\r\n         * Update the value and the selection values inside the AutoNumericHolder object.\r\n         * This keeps tracks of the input value, as well as the current selection.\r\n         * This also resets the 'processed' and 'formatted' state.\r\n         *\r\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n         *        this function is called on each event handler.\r\n         *\r\n         * @private\r\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateAutoNumericHolderProperties',\n            value: function _updateAutoNumericHolderProperties() {\n                this.value = this.that.value;\n                this.selection = getElementSelection(this.that);\n                this.processed = false;\n                this.formatted = false;\n            }\n\n            /**\r\n             * Update the keycode of the key that triggered the given event.\r\n             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n             *\r\n             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n             * e.key describe the key name used to trigger the event.\r\n             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n             * The key list is described here\r\n             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n             *\r\n             * @param {Event} e\r\n             * @private\r\n             */\n\n        }, {\n            key: '_updateAutoNumericHolderEventKeycode',\n            value: function _updateAutoNumericHolderEventKeycode(e) {\n                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n                this.eventKeyCode = keyCodeNumber(e);\n            }\n\n            /**\r\n             * Set the text selection inside the input with the given start and end position.\r\n             *\r\n             * @param {int} start\r\n             * @param {int} end\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\r\n             * Set the caret position inside the input at the given position.\r\n             *\r\n             * @param {int} pos\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\r\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n             *\r\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\r\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n             * Those parts are unformatted (stripped) of any non-numbers characters.\r\n             *\r\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                if (left === '' && right === '') {\n                    settingsClone.trailingNegative = false;\n                }\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                    settingsClone.trailingNegative = false;\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Strip parts from excess characters and leading zeros.\r\n             *\r\n             * @param {string} left\r\n             * @param {string} right\r\n             * @returns {[*,*]}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n             *\r\n             * @param {string} left\r\n             * @param {string} right\r\n             * @param {boolean} isPaste\r\n             * @returns {boolean}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n                    } else {\n                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\r\n             * Helper function for `_expandSelectionOnSign()`.\r\n             *\r\n             * @returns {*} Sign position of a formatted value\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\r\n             * Expands selection to cover whole sign\r\n             * Prevents partial deletion/copying/overwriting of a sign\r\n             *\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\r\n             * Try to strip pasted value to digits\r\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // Try to strip the pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\r\n             * Process pasting, cursor moving and skipping of not interesting keys.\r\n             * If this function returns TRUE, then further processing is not performed.\r\n             *\r\n             * @param {Event} e\r\n             * @returns {boolean}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n                    //TODO Move this test inside the `onKeyup` handler\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !isNegative(this.that.value) ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // Try to prevent wrong paste\n                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n                }\n\n                if (e.ctrlKey || e.metaKey) {\n                    return true;\n                }\n\n                // Jump over thousand separator\n                //TODO Move this test inside the `onKeydown` handler\n                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                    if (e.type === 'keydown' && !e.shiftKey) {\n                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start - 1);\n                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n            }\n\n            /**\r\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n             *\r\n             * @param {string} left The part on the left of the caret or selection\r\n             * @param {string} right The part on the right of the caret or selection\r\n             * @returns {[string, string]}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Process the deletion of characters.\r\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.eventKeyCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\r\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n             * Returns TRUE if the keycode is allowed.\r\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n             *\r\n             * @param {Event|string} eventOrChar The event object, or the character entered (from an android device)\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion(eventOrChar) {\n                var settingsClone = this.settingsClone;\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                var eventCharacter = void 0;\n                if (isString(eventOrChar)) {\n                    // Android browsers\n                    eventCharacter = eventOrChar;\n                } else {\n                    // Normal browsers\n                    settingsClone.throwInput = true;\n\n                    // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n                    eventCharacter = character(eventOrChar);\n                }\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If the user tries to insert digit before minus sign\n                var eventNumber = Number(eventCharacter);\n                if (eventNumber >= 0 && eventNumber <= 9) {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + eventCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\r\n             * Formatting of just processed value while keeping the cursor position\r\n             *\r\n             * @param {Event} e\r\n             * @private\r\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (isNegative(subParts)) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (_this.eventKeyCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If the positive sign is shown, calculate the caret position accordingly\n                        if (settingsClone.showPositiveSign) {\n                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n                            }\n\n                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n                                position = settingsClone.currencySymbol.length + 1;\n                            }\n                        }\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                if (settingsClone.androidSelectionStart !== null) {\n                    // If an Android browser is detected, fix the caret position\n                    // Unfortunately this does not fix all android browsers, only Android Chrome currently.\n                    // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\n                    this._setCaretPosition(settingsClone.androidSelectionStart);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @param {HTMLElement} that - A reference to the current DOM element\r\n     * @returns {*}\r\n     * @private\r\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = scIndex.indexOf(i);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\r\n     * Handler for 'focusin' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.hasFocus = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                jQueryOriginalVal.call($this, toggleNegativeBracket(e.target.value, settings));\n            }\n\n            // clean the value to compare to rawValue\n            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n            result = convertToNumericString(result, settings);\n            result = cleanLeadingTrailingZeros(result, settings);\n            if (settings.trailingNegative) {\n                result = '-' + result;\n            }\n\n            var roundedValue = void 0;\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = Number(settings.oDec);\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (result !== settings.rawValue) {\n                // updates the rawValue\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                jQueryOriginalVal.call($this, onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'keydown' events.\r\n     * The user just started pushing any key, hence one event is sent.\r\n     *\r\n     * Note :\r\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n     * - keydown\r\n     * - keypress\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * ...when inputting a modifier key (ie. 'ctrl') :\r\n     * - keydown\r\n     * - keyup\r\n     *\r\n     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - change\r\n     * - keyup\r\n     *\r\n     * When a paste is done, the following events are sent :\r\n     * - input (if paste is done with the mouse)\r\n     *\r\n     * - keydown (if paste is done with ctrl+v)\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     * - keyup\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\r\n     * Handler for 'keypress' events.\r\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onKeypress(holder, e) {\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n        var eventCharacter = character(e);\n\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (eventCharacter === keyName.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n                    var position = getElementSelection(e.target).start + 1;\n                    setElementSelection(e.target, position, position);\n                }\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\r\n     * Handler for 'input' events.\r\n     * added to support android devices with mobile chrome browsers and others\r\n     * Has the potential to replace the keypress event.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onInput(holder, e) {\n        var value = e.target.value;\n\n        // Fix the caret position on keyup in the `_formatValue()` function\n        holder.settings.androidSelectionStart = null;\n\n        if (holder.eventKeyCode === keyCode.AndroidDefault) {\n            // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\n            if (value.length > holder.lastVal.length || value.length >= holder.lastVal.length - holder.selection.length) {\n                // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\n                holder.eventKeyCode = value.charCodeAt(holder.selection.start);\n\n                // Capture the actual character entered\n                var androidCharEntered = value.charAt(holder.selection.start);\n\n                // Check if the given character should be inserted, and if so, do insert it into the current element value\n                var isCharacterInsertionAllowed = holder._processCharacterInsertion(androidCharEntered);\n\n                if (isCharacterInsertionAllowed) {\n                    // Allowed character entered (number, decimal or plus/minus sign)\n                    holder._formatValue(e);\n\n                    // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\n                    //TODO Check if this is an Android bug or an autoNumeric one\n                    holder.settings.androidSelectionStart = holder.selection.start;\n\n                    var decimalCharacterPosition = e.target.value.indexOf(holder.settings.decimalCharacter);\n                    var hasDecimalCharacter = decimalCharacterPosition === -1;\n\n                    // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\n                    if (androidCharEntered === holder.settings.decimalCharacter || !hasDecimalCharacter && decimalCharacterPosition < holder.settings.androidSelectionStart) {\n                        holder.settings.androidSelectionStart = holder.selection.start + 1;\n                    }\n\n                    if (e.target.value.length > value.length) {\n                        // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\n                        setElementSelection(e.target, holder.settings.androidSelectionStart, holder.settings.androidSelectionStart);\n                    }\n\n                    holder.lastVal = e.target.value;\n\n                    return;\n                } else {\n                    // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\n                    e.target.value = holder.lastVal;\n                    setElementSelection(e.target, holder.selection.start, holder.selection.end);\n                    holder.settings.androidSelectionStart = holder.selection.start;\n                }\n\n                e.preventDefault(); //FIXME How does that affects the normal trigger of the input event?\n\n                holder.formatted = false;\n            } else {\n                // Character deleted\n                //TODO What about the `Delete` key?\n                holder.eventKeyCode = keyCode.Backspace;\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'keyup' events.\r\n     * The user just released any key, hence one event is sent.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {object} settings\r\n     * @param {Event} e\r\n     */\n    function _onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        var isOnAndroid = holder.settingsClone.androidSelectionStart !== null;\n        if (skip && !isOnAndroid || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\r\n     * Handler for 'focusout' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.hasFocus = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative && !isNegative(value)) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? Number(settings.scaleDecimalPlaces) : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                jQueryOriginalVal.call($this, groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'paste' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegativeStrict(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\n        var pastedText = void 0;\n        if (untranslatedPastedText === '.') {\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n            pastedText = '.';\n        } else {\n            // Normal case\n            // Allow pasting arabic numbers\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n        }\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = void 0;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        var leftPartContainedADot = false;\n        var leftPart = void 0;\n        var rightPart = void 0;\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\r\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n             * Otherwise paste all the numbers in the clipboard.\r\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n             *\r\n             * 4b. Replace paste behavior:\r\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                if (leftPartContainedADot) {\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                    caretPositionOnInitialTextAfterPasting--;\n                }\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\r\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // 1. Generate the unformatted result\n                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // Generate the unformatted result\n                result = '' + leftPart + pastedText + rightPart;\n\n                // 2. Calculate the caret position in the unformatted value, for later use\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, then the caret position is set after the pasted text\n                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else if (rightPart === '') {\n                        // If the user selected from the caret position to the end of the input (on the far right)\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                    }\n                }\n\n                // Modify the caret position for special cases, only if the whole input has not been selected\n                if (!isAllInputTextSelected) {\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        caretPositionOnInitialTextAfterPasting++;\n                    }\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\r\n         * If 'error' (this is the default) :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'ignore' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, do nothing more.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'clamp' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n         *        paste result.\r\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n         * If 'truncate' :\r\n         *      - Truncate paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         * If 'replace' :\r\n         *      - Replace paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\r\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n        }\n    }\n\n    /**\r\n     * Handler for 'submit' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    jQueryOriginalVal.call($this, $settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\r\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @returns {boolean|*}\r\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\r\n     * Formats the default value on page load.\r\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n     *\r\n     * @param {object} settings\r\n     * @param {object} $input jQuery-selected <input> element\r\n     * @param {object} $this jQuery-selected DOM element\r\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = jQueryOriginalVal.call($this);\n            /*\r\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n             *\r\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n             * we should ignore `defaultValueOverride` altogether.\r\n             */\n            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup oDec\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\r\n                 * - page reload from back button, and\r\n                 * - ASP.net form post back\r\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                 */\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.hasFocus = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n                        } else {\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n                        }\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        jQueryOriginalVal.call($this, settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\r\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n     *\r\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n     *\r\n     * @param {object} settings\r\n     */\n    function correctNegativePositiveSignPlacementOption(settings) {\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\n        if (!isNull(settings.negativePositiveSignPlacement)) {\n            return;\n        }\n\n        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 €\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n                    break;\n                default:\n                //\n            }\n        } else {\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\n            settings.negativePositiveSignPlacement = 'l';\n        }\n    }\n\n    /**\r\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n     *\r\n     * @param {object} settings\r\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\r\n     * Modify `decimalPlacesOverride` as needed\r\n     *\r\n     * @param {object} settings\r\n     */\n    function correctDecimalPlacesOverrideOption(settings) {\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\r\n     * Sets the alternative decimal separator key.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\r\n     * Caches regular expressions for stripAllNonNumberCharacters\r\n     *\r\n     * @param {object} settings\r\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var allNumbersReg = '[0-9]';\n        var noAllNumbersReg = '[^0-9]';\n\n        // Test if there is a negative character in the string\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n\n        var negativeSignRegPart = void 0;\n        if (settings.negativeSignCharacter) {\n            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n        } else {\n            negativeSignRegPart = '';\n        }\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n    }\n\n    /**\r\n     * Modify the user settings to make them 'exploitable' later.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\r\n     * Convert the old settings options name to new ones.\r\n     *\r\n     * @param {object} options\r\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            showPositiveSign: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            hasFocus: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            positiveSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n     *\r\n     * @param {object} options\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n     * @returns {object|null}\r\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    hasFocus: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    androidSelectionStart: null,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctNegativePositiveSignPlacementOption(settings);\n\n            // Set the negative and positive signs, as needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctDecimalPlacesOverrideOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\r\n     * Convert the `value` parameter that can either be :\r\n     * - a real number,\r\n     * - a string representing a real number, or\r\n     * - a string representing a localized number (with specific group separators and decimal character),\r\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n     *\r\n     * This function returns `NaN` if such conversion fails.\r\n     *\r\n     * @param {int|float|string} value\r\n     * @param {object} settings\r\n     * @returns {string|NaN}\r\n     */\n    function toNumericValue(value, settings) {\n        var result = void 0;\n        if (isNumber(Number(value))) {\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n            result = value;\n        } else {\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\n            result = convertToNumericString(value.toString(), settings);\n\n            // If the result is still not a numeric string, then we throw a warning\n            if (!isNumber(Number(result))) {\n                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                result = NaN;\n            }\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\n    var methods = {\n        /**\r\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var _this2 = this;\n\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input && $this.data('initialized') !== true) {\n                    (function () {\n                        var eventHandlers = {\n                            onFocusInAndMouseEnter: function onFocusInAndMouseEnter(e) {\n                                _onFocusInAndMouseEnter($this, holder, e);\n                            },\n                            onFocusOutAndMouseLeave: function onFocusOutAndMouseLeave(e) {\n                                _onFocusOutAndMouseLeave($this, holder, e);\n                            },\n                            onKeydown: function onKeydown(e) {\n                                _onKeydown(holder, e);\n                            },\n                            onKeypress: function onKeypress(e) {\n                                _onKeypress(holder, e);\n                            },\n                            onInput: function onInput(e) {\n                                _onInput(holder, e);\n                            },\n                            onKeyup: function onKeyup(e) {\n                                _onKeyup(holder, settings, e);\n                            },\n                            onBlur: function onBlur(e) {\n                                _onBlur(holder, e);\n                            },\n                            onPaste: function onPaste(e) {\n                                _onPaste($this, holder, e);\n                            }\n                        };\n                        var eventConfigs = [{ name: 'focusin', handler: eventHandlers.onFocusInAndMouseEnter }, { name: 'mouseenter', handler: eventHandlers.onFocusInAndMouseEnter }, { name: 'blur', handler: eventHandlers.onFocusOutAndMouseLeave }, { name: 'mouseleave', handler: eventHandlers.onFocusOutAndMouseLeave }, { name: 'keydown', handler: eventHandlers.onKeydown }, { name: 'keypress', handler: eventHandlers.onKeypress }, { name: 'input', handler: eventHandlers.onInput }, { name: 'keyup', handler: eventHandlers.onKeyup }, { name: 'blur', handler: eventHandlers.onBlur }, { name: 'paste', handler: eventHandlers.onPaste }];\n\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = eventConfigs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var eventConfig = _step.value;\n\n                                _this2.addEventListener(eventConfig.name, eventConfig.handler, false);\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n\n                        onSubmit($this, holder); //TODO Switch to `addEventListener'\n\n                        $this.data({\n                            initialized: true,\n                            misc: {\n                                removeAllEvents: function removeAllEvents(el) {\n                                    var _iteratorNormalCompletion2 = true;\n                                    var _didIteratorError2 = false;\n                                    var _iteratorError2 = undefined;\n\n                                    try {\n                                        for (var _iterator2 = eventConfigs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                            var eventConfig = _step2.value;\n\n                                            el.removeEventListener(eventConfig.name, eventConfig.handler, false);\n                                        }\n                                    } catch (err) {\n                                        _didIteratorError2 = true;\n                                        _iteratorError2 = err;\n                                    } finally {\n                                        try {\n                                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                                _iterator2.return();\n                                            }\n                                        } finally {\n                                            if (_didIteratorError2) {\n                                                throw _iteratorError2;\n                                            }\n                                        }\n                                    }\n\n                                    $(el).closest('form').off('.autoNumeric');\n                                }\n                            }\n                        });\n                    })();\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to stop and remove autoNumeric for the current element.\r\n         * Note: this does not remove the formatting.\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n         *\r\n         * @param {Boolean} clearValue If TRUE, then this function clears the text box upon destruction.\r\n         * @returns {*|jQuery}\r\n         */\n        destroy: function destroy() {\n            var clearValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    jQueryOriginalVal.call($this, clearValue === true ? '' : $this.autoNumeric('get'));\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.data('misc').removeAllEvents(this);\n                    $this.removeData('autoNumeric', 'initialized', 'removeAllEvents');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    jQueryOriginalVal.call($this, '');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method that updates the autoNumeric settings.\r\n         * It can be called multiple times if needed.\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '}).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|jQuery}\r\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                // Retrieve the current unformatted input value\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n\n                // Update the settings\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                // Reformat the input value with the new settings\n                if (jQueryOriginalVal.call($this) !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         *\r\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n         *\r\n         * @param {*} newValue\r\n         * @returns {*|jQuery}\r\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n                }\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n                settings.trailingNegative = false;\n\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                var value = toNumericValue(newValue, settings);\n                if (isNaN(value)) {\n                    return jQueryOriginalVal.call($this, '');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n                    // This test is needed by the showPositiveSign option\n\n\n                    var isZero = isZeroOrHasNoValue(value);\n                    if (isZero) {\n                        value = '0';\n                    }\n\n                    if (minTest && maxTest) {\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            // to ensure rounding does not happen twice\n                            var hasBeenRounded = false;\n\n                            // rounds the the extended decimal places\n                            var tempDecimal = void 0;\n                            if (settings.decimalPlacesShownOnFocus) {\n                                tempDecimal = settings.decimalPlacesOverride;\n                                settings.decimalPlacesOverride = Number(settings.decimalPlacesShownOnFocus);\n                                value = roundValue(value, settings);\n                                hasBeenRounded = true;\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = roundValue(value, settings);\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                                value = toNumericValue(value, settings);\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                if (settings.scaleDecimalPlaces) {\n                                    tempDecimal = settings.decimalPlacesOverride;\n                                    settings.decimalPlacesOverride = Number(settings.scaleDecimalPlaces);\n                                    value = roundValue(value, settings);\n                                    hasBeenRounded = true;\n                                }\n                            }\n\n                            // Rounds if this has not been done already\n                            if (!hasBeenRounded) {\n                                value = roundValue(value, settings);\n                            }\n\n                            // Stores rawValue including the decimalPlacesShownOnFocus\n                            if (!settings.scaleDivisor) {\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n\n                            if (settings.scaleDivisor && settings.scaleDecimalPlaces && !settings.onOff) {\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return jQueryOriginalVal.call($this, '');\n                    }\n                } else {\n                    return jQueryOriginalVal.call($this, '');\n                }\n\n                if (!settings.hasFocus && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return jQueryOriginalVal.call($this, value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\r\n         * Method to un-format inputs.\r\n         * This is handy to use right before form submission.\r\n         *\r\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n         * Please see option \"outputFormat\" for more details\r\n         *\r\n         * @example $(someSelector).autoNumeric('unSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.hasFocus = true;\n                    jQueryOriginalVal.call($this, $this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to re-format inputs.\r\n         * This is handy to use right after form submission.\r\n         *\r\n         * This is called after the 'unSet' method to reformat the input\r\n         *\r\n         * @example $(someSelector).autoNumeric('reSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', jQueryOriginalVal.call($this));\n                }\n            });\n        },\n\n\n        /**\r\n         * Return the unformatted value as a string.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('get');\r\n         *\r\n         * @returns {string}\r\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = jQueryOriginalVal.call($this.eq(0));\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                // Test if the value is negative\n                var isValueNegative = isNegative(value);\n\n                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.hasFocus = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    // Strips trailing negative symbol\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\n                    // Places the negative symbol in front of the trailing negative\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n                        value = '-' + value;\n                    }\n                }\n\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                }\n            }\n\n            // Always return a numeric string\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n            return trimPaddedZerosFromDecimalPlaces(value);\n        },\n\n\n        /**\r\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n         * - a plain number (if the setting 'number' is used).\r\n         *\r\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n         * Check the \"outputFormat\" option definition for more details.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getLocalized');\r\n         *\r\n         * @returns {*}\r\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\r\n         * Return the input unformatted value as a real Javascript number.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getNumber');\r\n         *\r\n         * @returns {number}\r\n         */\n        getNumber: function getNumber() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {string}\r\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {{}|[]}\r\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\r\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('getSettings');\r\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n         *\r\n         * @returns {object}\r\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\r\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n     * It initialize autoNumeric on the given element.\r\n     *\r\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n     * @param {*} args\r\n     * @returns {*}\r\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\r\n     * Return the default autoNumeric settings.\r\n     *\r\n     * @returns {object}\r\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\r\n     * Return all the predefined language options in one object.\r\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n     *\r\n     * @returns {object}\r\n     */\n    getLanguages = function getLanguages() {\n        return languageOption;\n    };\n\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\n    /**\r\n     * Public function that allows formatting without an element trigger.\r\n     *\r\n     * @param {number|string} value A number, or a string that represent a javascript number\r\n     * @param {object|null} options\r\n     * @returns {*}\r\n     */\n    autoFormat = function autoFormat(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        if (!isString(value) && !isNumber(value)) {\n            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Check the validity of the `value` parameter\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\n        var valueString = toNumericValue(value, settings);\n        if (isNaN(valueString)) {\n            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\r\n     * Public function that allows unformatting without an element.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} options\r\n     * @returns {*}\r\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n        if (isNegative(value)) {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.hasFocus = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(settings.decimalCharacter, '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\r\n     * Validate the given option object.\r\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n     *\r\n     * This tests if the options are not conflicting and are well formatted.\r\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n     *\r\n     * @param {*} userOptions\r\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n     * @throws Error\r\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n        '.', // Dot\n        ' ', // Normal space\n        '\\u2009', // Thin-space\n        '\\u202F', // Narrow no-break space\n        '\\xA0', // No-break space\n        '', // No separator\n        \"'\", // Apostrophe\n        '٬', // Arabic thousands separator\n        '˙'])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', // Comma\n        '.', // Dot\n        '·', // Middle-dot\n        '٫', // Arabic decimal separator\n        '⎖'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\r\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n     *\r\n     * @param {object} options\r\n     * @returns {boolean}\r\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\r\n     * Take an arabic number as a string and return a javascript number.\r\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n     * This returns `NaN` is the conversion is not possible.\r\n     * Based on http://stackoverflow.com/a/17025392/2834898\r\n     *\r\n     * @param {string} arabicNumbers\r\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n     * @param {boolean} parseDecimalCharacter\r\n     * @param {boolean} parseThousandSeparator\r\n     * @returns {string|number|NaN}\r\n     */\n    function arabicToLatinNumbers(arabicNumbers) {\n        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var result = arabicNumbers.toString();\n        if (result === '' || result.match(/[٠١٢٣٤٥٦٧٨٩۴۵۶]/g) === null) {\n            // If no Arabic/Persian numbers are found, return the numeric string directly\n            return arabicNumbers;\n        }\n\n        if (parseDecimalCharacter) {\n            result = result.replace(/٫/, '.'); // Decimal character\n        }\n\n        if (parseThousandSeparator) {\n            result = result.replace(/٬/g, ''); // Thousand separator\n        }\n\n        // Replace the numbers only\n        result = result.replace(/[٠١٢٣٤٥٦٧٨٩]/g, function (d) {\n            return d.charCodeAt(0) - 1632;\n        }) // Arabic numbers\n        .replace(/[۰۱۲۳۴۵۶۷۸۹]/g, function (d) {\n            return d.charCodeAt(0) - 1776;\n        }); // Persian numbers\n\n        // `NaN` has precedence over the string `'NaN'`\n        var resultAsNumber = Number(result);\n        if (isNaN(resultAsNumber)) {\n            return resultAsNumber;\n        }\n\n        if (returnANumber) {\n            result = resultAsNumber;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Create a custom event and immediately sent it from the given element.\r\n     * By default, if no element is given, the event is thrown from `document`.\r\n     *\r\n     * @param {string} eventName\r\n     * @param {Element} element\r\n     * @param {object} detail\r\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n\n    $.extend(true, defaultSettings, $.fn.autoNumeric.lang.Turkish, { currencySymbol: '' });\n\n    // Hijack the original val fn in order to\n    // use $autoNumeric.val() and be able to get/set\n    // the unmasked value.\n    $.fn.val = function (value) {\n        var me = this;\n        var $me = $(me);\n\n        // If we're not dealing with an instance of autoNumeric,\n        // simply call the original jQuery.fn.val\n        if ($me.data('autoNumeric') === undefined) {\n            return jQueryOriginalVal.apply(me, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        if (!arguments.length) {\n            // We're trying to read the numeric value\n            return $me.autoNumeric('get');\n        } else {\n            // We're trying to set a value\n            var originalVal = value;\n            var numericValue = void 0;\n\n            if (typeof value === 'string') {\n                value = value.replace(',', '.');\n                numericValue = parseFloat(value, 10);\n\n                if (isNaN(numericValue)) {\n                    throw '\"' + originalVal + '\" is not a number.';\n                }\n            } else if (typeof value !== 'number') {\n                throw 'The type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is not supported.';\n            } else {\n                numericValue = value;\n            }\n\n            return $me.autoNumeric('set', numericValue);\n        }\n    };\n});\n\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    getLanguages: getLanguages,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsImdldExhbmd1YWdlcyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiZGlnaXRHcm91cFNlcGFyYXRvciIsIm5vU2VwYXJhdG9yT25Gb2N1cyIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJkZWNpbWFsQ2hhcmFjdGVyIiwiZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlIiwiY3VycmVuY3lTeW1ib2wiLCJjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwic2hvd1Bvc2l0aXZlU2lnbiIsInN1ZmZpeFRleHQiLCJvdmVycmlkZU1pbk1heExpbWl0cyIsIm1heGltdW1WYWx1ZSIsIm1pbmltdW1WYWx1ZSIsImRlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWxQbGFjZXMiLCJzY2FsZVN5bWJvbCIsInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UiLCJvbkludmFsaWRQYXN0ZSIsInJvdW5kaW5nTWV0aG9kIiwiYWxsb3dEZWNpbWFsUGFkZGluZyIsIm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyIiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwibGVhZGluZ1plcm8iLCJmb3JtYXRPblBhZ2VMb2FkIiwic2VsZWN0TnVtYmVyT25seSIsImRlZmF1bHRWYWx1ZU92ZXJyaWRlIiwidW5mb3JtYXRPblN1Ym1pdCIsIm91dHB1dEZvcm1hdCIsInNob3dXYXJuaW5ncyIsImZhaWxPblVua25vd25PcHRpb24iLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZUJyZWFrIiwiQ2Fwc0xvY2siLCJFc2MiLCJTcGFjZSIsIlBhZ2VVcCIsIlBhZ2VEb3duIiwiRW5kIiwiSG9tZSIsIkxlZnRBcnJvdyIsIlVwQXJyb3ciLCJSaWdodEFycm93IiwiRG93bkFycm93IiwiSW5zZXJ0IiwiRGVsZXRlIiwibnVtMCIsIm51bTEiLCJudW0yIiwibnVtMyIsIm51bTQiLCJudW01IiwibnVtNiIsIm51bTciLCJudW04IiwibnVtOSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiV2luZG93cyIsIlJpZ2h0Q2xpY2siLCJudW1wYWQwIiwibnVtcGFkMSIsIm51bXBhZDIiLCJudW1wYWQzIiwibnVtcGFkNCIsIm51bXBhZDUiLCJudW1wYWQ2IiwibnVtcGFkNyIsIm51bXBhZDgiLCJudW1wYWQ5IiwiTXVsdGlwbHlOdW1wYWQiLCJQbHVzTnVtcGFkIiwiTWludXNOdW1wYWQiLCJEb3ROdW1wYWQiLCJTbGFzaE51bXBhZCIsIkYxIiwiRjIiLCJGMyIsIkY0IiwiRjUiLCJGNiIsIkY3IiwiRjgiLCJGOSIsIkYxMCIsIkYxMSIsIkYxMiIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiTXlDb21wdXRlciIsIk15Q2FsY3VsYXRvciIsIlNlbWljb2xvbiIsIkVxdWFsIiwiQ29tbWEiLCJIeXBoZW4iLCJEb3QiLCJTbGFzaCIsIkJhY2txdW90ZSIsIkxlZnRCcmFja2V0IiwiQmFja3NsYXNoIiwiUmlnaHRCcmFja2V0IiwiUXVvdGUiLCJDb21tYW5kIiwiQW5kcm9pZERlZmF1bHQiLCJrZXlOYW1lIiwiVW5pZGVudGlmaWVkIiwiQWx0R3IiLCJGbiIsIkZuTG9jayIsIkh5cGVyIiwiTWV0YSIsIlN1cGVyIiwiU3ltYm9sIiwiU3ltYm9sTG9jayIsIkNsZWFyIiwiQ29weSIsIkNyU2VsIiwiQ3V0IiwiRXJhc2VFb2YiLCJFeFNlbCIsIlBhc3RlIiwiUmVkbyIsIlVuZG8iLCJBY2NlcHQiLCJBZ2FpbiIsIkF0dG4iLCJDYW5jZWwiLCJDb250ZXh0TWVudSIsIkV4ZWN1dGUiLCJGaW5kIiwiRmluaXNoIiwiSGVscCIsIlBhdXNlIiwiUGxheSIsIlByb3BzIiwiU2VsZWN0IiwiWm9vbUluIiwiWm9vbU91dCIsIkJyaWdodG5lc3NEb3duIiwiQnJpZ2h0bmVzc1VwIiwiRWplY3QiLCJMb2dPZmYiLCJQb3dlciIsIlBvd2VyT2ZmIiwiUHJpbnRTY3JlZW4iLCJIaWJlcm5hdGUiLCJTdGFuZGJ5IiwiV2FrZVVwIiwiQ29tcG9zZSIsIkRlYWQiLCJQcmludCIsIk1pbnVzIiwiUGx1cyIsIk51bXBhZERvdCIsIk51bXBhZERvdEFsdCIsIk51bXBhZE11bHRpcGx5IiwiTnVtcGFkUGx1cyIsIk51bXBhZE1pbnVzIiwiTnVtcGFkU2xhc2giLCJOdW1wYWREb3RPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkTXVsdGlwbHlPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkUGx1c09ic29sZXRlQnJvd3NlcnMiLCJOdW1wYWRNaW51c09ic29sZXRlQnJvd3NlcnMiLCJOdW1wYWRTbGFzaE9ic29sZXRlQnJvd3NlcnMiLCJkZWZhdWx0TWluaW11bVZhbHVlIiwiZGVmYXVsdE1heGltdW1WYWx1ZSIsImRlZmF1bHRSb3VuZGluZ01ldGhvZCIsImRlZmF1bHRMZWFkaW5nWmVybyIsImRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5IiwibGFuZ3VhZ2VPcHRpb24iLCJGcmVuY2giLCJOb3J0aEFtZXJpY2FuIiwiQnJpdGlzaCIsIlN3aXNzIiwiSmFwYW5lc2UiLCJUdXJraXNoIiwiU3BhbmlzaCIsIkNoaW5lc2UiLCJmYWN0b3J5IiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJ3aW5kb3ciLCJqUXVlcnkiLCJqUXVlcnlPcmlnaW5hbFZhbCIsIiQiLCJmbiIsInZhbCIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImlzSW50IiwicGFyc2VJbnQiLCJwcmVwYXJlUGFzdGVkVGV4dCIsInRleHQiLCJob2xkZXIiLCJzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMiLCJzZXR0aW5nc0Nsb25lIiwicmVwbGFjZSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJkZWNpbWFsUGxhY2VzIiwic3BsaXQiLCJkZWNpbWFsUGFydCIsImxlbmd0aCIsImtleUNvZGVOdW1iZXIiLCJldmVudCIsIndoaWNoIiwiY2hhcmFjdGVyIiwia2V5IiwiZnJvbUNoYXJDb2RlIiwicmVzdWx0IiwiY2hlY2tJZkluUmFuZ2UiLCJwYXJzZWRNaW5WYWx1ZSIsInBhcnNlZE1heFZhbHVlIiwicGFyc2VkVmFsdWUiLCJwYXJzZVN0ciIsInRlc3RNaW5NYXgiLCJpc05lZ2F0aXZlIiwibnVtZXJpY1N0cmluZyIsImNoZWNrRXZlcnl3aGVyZSIsImlzTmVnYXRpdmVTdHJpY3QiLCJjaGFyQXQiLCJpc1plcm9Pckhhc05vVmFsdWUiLCJ0ZXN0Iiwic2V0UmF3TmVnYXRpdmVTaWduIiwicmVwbGFjZUNoYXJBdCIsInN0cmluZyIsImluZGV4IiwibmV3Q2hhcmFjdGVyIiwic3Vic3RyIiwiY2xhbXBUb1JhbmdlTGltaXRzIiwic2V0dGluZ3MiLCJNYXRoIiwibWF4IiwibWluIiwiY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nIiwiY2FyZXRQb3NpdGlvbiIsIm51bWJlckRvdE9yTmVnYXRpdmVTaWduIiwiUmVnRXhwIiwibnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQiLCJmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwicmF3TnVtYmVyU3RyaW5nIiwiY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplIiwicmF3TnVtYmVyU3RyaW5nU2l6ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4IiwicmF3TnVtYmVyU3RyaW5nSW5kZXgiLCJjb3VudENoYXJJblRleHQiLCJjaGFyQ291bnRlciIsImNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbiIsImNoYXJhY3RlckNvdW50IiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIndhcm5pbmciLCJzaG93V2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwicnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0IiwiJHRoaXMiLCJlYWNoIiwiYXV0b051bWVyaWMiLCJtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoIiwibGVmdE9yQWxsIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwidHJhaWxpbmdOZWdhdGl2ZSIsInNraXBMYXN0QXV0b1N0cmlwIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm1hdGNoIiwibnVtUmVnQXV0b1N0cmlwIiwiam9pbiIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwibmVnYXRpdmVTaWduQ2hhcmFjdGVyIiwibUludFBvcyIsInNsaWNlIiwibUludE5lZyIsImhhc0ZvY3VzIiwic3RyaXBSZWciLCJ0b2dnbGVOZWdhdGl2ZUJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImNvbnZlcnRUb051bWVyaWNTdHJpbmciLCJsYXN0SW5kZXhPZiIsInRlbXAiLCJhcmFiaWNUb0xhdGluTnVtYmVycyIsInRvTG9jYWxlIiwibG9jYWxlIiwiTnVtYmVyIiwibW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlIiwibW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlIiwiY2hlY2tFbXB0eSIsImlucHV0VmFsdWUiLCJzaWduT25FbXB0eSIsImFkZEdyb3VwU2VwYXJhdG9ycyIsInN0cmlwIiwiZW1wdHkiLCJpc1ZhbHVlTmVnYXRpdmUiLCJpc1plcm8iLCJkaWdpdGFsR3JvdXAiLCJzdWJzdHJpbmciLCJwb3NpdGl2ZVNpZ25DaGFyYWN0ZXIiLCJyYXdWYWx1ZSIsInRydW5jYXRlWmVyb3MiLCJyb3VuZGVkSW5wdXRWYWx1ZSIsInRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSIsInJlZ2V4Iiwicm91bmRWYWx1ZSIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwiaXZSb3VuZGVkIiwiZFBvcyIsImlucHV0VmFsdWVIYXNBRG90IiwidmRQb3MiLCJjRGVjIiwiemVyb3MiLCJyTGVuZ3RoIiwidFJvdW5kIiwib2RkIiwiaXZBcnJheSIsInRydW5jYXRlRGVjaW1hbCIsImlzUGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwibkwiLCJzZWFyY2giLCJ4YyIsInljIiwieE5lZyIsImNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uIiwibWluUGFyc2UiLCJtYXhQYXJzZSIsInZhbFBhcnNlIiwiZ2V0Q3VycmVudEVsZW1lbnQiLCJlbGVtZW50IiwiZ2V0QXV0b051bWVyaWNIb2xkZXIiLCJ1cGRhdGUiLCJkYXRhIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSIsIm9EZWMiLCJvUGFkIiwib0JyYWNrZXQiLCJvU2VwIiwib1NpZ24iLCJvU3VmZml4IiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3MiLCJ0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyIsInRyaW1tZWREZWNpbWFsUGFydCIsInNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UiLCJhY3Rpb24iLCJzdG9yZWROYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJkYXRlIiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SXRlbSIsIiR0aGF0IiwiZm9ybWF0dGVkIiwicHJvY2Vzc2VkIiwiZXZlbnRLZXlDb2RlIiwic2V0UmVhbCIsInBvcyIsIl9zZXRTZWxlY3Rpb24iLCJsZWZ0IiwicmlnaHQiLCJfZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInN0cmlwWmVyb3MiLCJuZXdWYWx1ZSIsImFOZWdSZWdBdXRvU3RyaXAiLCJwYXJ0cyIsIl9ub3JtYWxpemVQYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwiX3NldENhcmV0UG9zaXRpb24iLCJ0cmlnZ2VyIiwiY3VycmVuY3lTeW1ib2xMZW4iLCJoYXNOZWciLCJ2YWx1ZUxlbiIsInNpZ25Qb3NpdGlvbiIsIl9nZXRTaWduUG9zaXRpb24iLCJ2YWx1ZVBhcnRzQmVmb3JlUGFzdGUiLCJvbGRQYXJ0cyIsIm1vZGlmaWVkTGVmdFBhcnQiLCJfc2V0VmFsdWVQYXJ0cyIsImN0cmxLZXkiLCJtZXRhS2V5IiwidHlwZSIsInNoaWZ0S2V5IiwiX2NoZWNrUGFzdGUiLCJwcmV2ZW50RGVmYXVsdCIsIm5lZ0xlbiIsInN1ZmZpeFRleHRMZW4iLCJfZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiY2FyZXRGaXgiLCJfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uIiwidGhyb3dJbnB1dCIsIl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduIiwiZXZlbnRPckNoYXIiLCJldmVudENoYXJhY3RlciIsImV2ZW50TnVtYmVyIiwibGVmdExlbmd0aCIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJpbnB1dCIsImFuZHJvaWRTZWxlY3Rpb25TdGFydCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImFsbEZvcm1FbGVtZW50cyIsImFpSW5kZXgiLCJzY0luZGV4IiwiclN1Ym1pdHRlclR5cGVzIiwiclN1Ym1pdHRhYmxlIiwickNoZWNrYWJsZVR5cGUiLCJyTm9uQXV0b051bWVyaWNUeXBlcyIsImNvdW50IiwiZmllbGQiLCJsb2NhbE5hbWUiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJmb3JtRmllbGRzIiwic2VyaWFsaXplQXJyYXkiLCJzY0VsZW1lbnQiLCJ0ZXN0SW5wdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJvbkZvY3VzSW5BbmRNb3VzZUVudGVyIiwiaXMiLCJ0YXJnZXQiLCJyb3VuZGVkVmFsdWUiLCJ2YWx1ZU9uRm9jdXMiLCJsYXN0VmFsIiwib25FbXB0eSIsIm9uS2V5ZG93biIsIl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZSIsImluaXRpYWxWYWx1ZU9uS2V5ZG93biIsInJlYWRPbmx5IiwidHJpZ2dlckV2ZW50IiwiX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyIsIl9za2lwQWx3YXlzIiwiX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbiIsIl9mb3JtYXRWYWx1ZSIsIm9uS2V5cHJlc3MiLCJpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQiLCJfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbiIsIm9uSW5wdXQiLCJjaGFyQ29kZUF0IiwiYW5kcm9pZENoYXJFbnRlcmVkIiwiZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uIiwiaGFzRGVjaW1hbENoYXJhY3RlciIsIm9uS2V5dXAiLCJza2lwIiwiaXNPbkFuZHJvaWQiLCJvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsImNoYW5nZSIsIm9uUGFzdGUiLCJyYXdQYXN0ZWRUZXh0IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJpbml0aWFsRm9ybWF0dGVkVmFsdWUiLCJzZWxlY3Rpb25TaXplIiwiaXNBbGxJbnB1dFRleHRTZWxlY3RlZCIsImlzUGFzdGVOZWdhdGl2ZSIsInVudHJhbnNsYXRlZFBhc3RlZFRleHQiLCJwYXN0ZWRUZXh0IiwiY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmciLCJpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIiLCJpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlIiwiaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSIsImxlZnRQYXJ0Q29udGFpbmVkQURvdCIsImxlZnRQYXJ0IiwicmlnaHRQYXJ0IiwibGVmdEZvcm1hdHRlZFBhcnQiLCJyaWdodEZvcm1hdHRlZFBhcnQiLCJsYXN0R29vZEtub3duUmVzdWx0IiwicGFzdGVkVGV4dEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdFNpemUiLCJsZWZ0Rm9ybWF0dGVkUGFydDIiLCJyaWdodEZvcm1hdHRlZFBhcnQyIiwiaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQiLCJpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUiLCJzZWxlY3RlZFRleHQiLCJ2YWx1ZUhhc0JlZW5TZXQiLCJ2YWx1ZUhhc0JlZW5DbGFtcGVkIiwiZXJyb3IiLCJjbGFtcGVkVmFsdWUiLCJjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJvbkJsdXIiLCJvblN1Ym1pdCIsImNsb3Nlc3QiLCJvbiIsIiRzZXR0aW5ncyIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiY3VycmVudEVsZW1lbnRUYWciLCJmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkIiwic2V0VmFsdWUiLCJjdXJyZW50VmFsdWUiLCJ1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSIsInRvTnVtZXJpY1ZhbHVlIiwiYXR0ciIsIkluZmluaXR5IiwidG9TdHJpcCIsInRhZ0xpc3QiLCJjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24iLCJjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyIsIm1heGltdW1WYWx1ZUludGVnZXJQYXJ0IiwibWluaW11bVZhbHVlSW50ZWdlclBhcnQiLCJjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uIiwic2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlciIsImNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zIiwiYWxsTnVtYmVyc1JlZyIsIm5vQWxsTnVtYmVyc1JlZyIsImFOZWdSZWciLCJuZWdhdGl2ZVNpZ25SZWdQYXJ0IiwiYWxsb3dlZCIsInRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyIsImNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzIiwib3B0aW9ucyIsIm9sZE9wdGlvbnNDb252ZXJ0ZXIiLCJhU2VwIiwiblNlcCIsImRHcm91cCIsImFEZWMiLCJhbHREZWMiLCJhU2lnbiIsInBTaWduIiwicE5lZyIsImFTdWZmaXgiLCJvTGltaXRzIiwidk1heCIsInZNaW4iLCJtRGVjIiwiZURlYyIsInNjYWxlRGVjaW1hbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwicnVuT25jZSIsIm9wdGlvbiIsImdldEluaXRpYWxTZXR0aW5ncyIsImV4dGVuZCIsInRhZ0RhdGEiLCJOYU4iLCJtZXRob2RzIiwiaW5pdCIsImV2ZW50SGFuZGxlcnMiLCJldmVudENvbmZpZ3MiLCJoYW5kbGVyIiwiZXZlbnRDb25maWciLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdGlhbGl6ZWQiLCJtaXNjIiwicmVtb3ZlQWxsRXZlbnRzIiwiZWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmIiwiZGVzdHJveSIsImNsZWFyVmFsdWUiLCJyZW1vdmVEYXRhIiwid2lwZSIsInNldCIsImhhc0JlZW5Sb3VuZGVkIiwidGVtcERlY2ltYWwiLCJvbk9mZiIsImF0dGVtcHRlZFZhbHVlIiwidW5TZXQiLCJyZVNldCIsImVxIiwiZ2V0TG9jYWxpemVkIiwiZ2V0TnVtYmVyIiwiZ2V0Rm9ybWF0dGVkIiwiZ2V0U3RyaW5nIiwiZ2V0QXJyYXkiLCJnZXRTZXR0aW5ncyIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwibGFuZyIsInZhbHVlU3RyaW5nIiwiYXV0b1N0cmlwIiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJ2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzIiwiYXV0b1ZhbGlkYXRlIiwiaXNWYWxpZCIsImFyYWJpY051bWJlcnMiLCJyZXR1cm5BTnVtYmVyIiwicGFyc2VEZWNpbWFsQ2hhcmFjdGVyIiwicGFyc2VUaG91c2FuZFNlcGFyYXRvciIsInJlc3VsdEFzTnVtYmVyIiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInBhcmFtcyIsImV2dCIsIkV2ZW50IiwibWUiLCIkbWUiLCJ1bmRlZmluZWQiLCJhcmd1bWVudHMiLCJvcmlnaW5hbFZhbCIsIm51bWVyaWNWYWx1ZSIsImZvcm1hdCIsInVuRm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQTs7QUFFQTtBQUNBLElBQUlBLG1CQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyx5QkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMsaUJBQUo7QUFDQSxJQUFJQyx5QkFBSjs7QUFFQTtBQUNBOzs7QUFHQSxJQUFNQyxpQkFBaUIsQ0FDbkIsR0FEbUIsRUFFbkIsU0FGbUIsRUFHbkIsTUFIbUIsRUFJbkIsTUFKbUIsRUFLbkIsT0FMbUIsRUFNbkIsSUFObUIsRUFPbkIsS0FQbUIsRUFRbkIsS0FSbUIsRUFTbkIsS0FUbUIsRUFVbkIsSUFWbUIsRUFXbkIsSUFYbUIsRUFZbkIsSUFabUIsRUFhbkIsSUFibUIsRUFjbkIsSUFkbUIsRUFlbkIsSUFmbUIsRUFnQm5CLElBaEJtQixFQWlCbkIsSUFqQm1CLEVBa0JuQixLQWxCbUIsRUFtQm5CLEtBbkJtQixFQW9CbkIsT0Fw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SW1CLE1BQU02ZSxZQUFOLENBQUosRUFBeUI7QUFDckIsZ0NBQVVELFdBQVY7QUFDSDtBQUNKLGFBUEQsTUFRSyxJQUFJLE9BQU8vZixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2hDLDZDQUEwQkEsS0FBMUIseUNBQTBCQSxLQUExQjtBQUNILGFBRkksTUFHQTtBQUNEZ2dCLCtCQUFlaGdCLEtBQWY7QUFDSDs7QUFFRCxtQkFBTzRmLElBQUlwWSxXQUFKLENBQWdCLEtBQWhCLEVBQXVCd1ksWUFBdkIsQ0FBUDtBQUNIO0FBQ0osS0FsQ0Q7QUFtQ0gsQ0F0cEpBLENBQUQ7O0FBd3BKQTs7O2tCQUdlO0FBQ1hDLFlBQVV0dUIsVUFEQztBQUVYdXVCLGNBQVV0dUIsWUFGQztBQUdYQyxzQ0FIVztBQUlYQyw4QkFKVztBQUtYQyxzQkFMVyxFQUtEO0FBQ1ZDLHNDQU5XLEUiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgICAgICAgICAgICAgIGF1dG9OdW1lcmljLmpzXHJcbiAqXHJcbiAqIEB2ZXJzaW9uICAgICAgMi4wLjEyXHJcbiAqIEBkYXRlICAgICAgICAgMjAxNy0wNC0wNyBVVEMgMDc6MDBcclxuICpcclxuICogQGF1dGhvciAgICAgICBCb2IgS25vdGhlXHJcbiAqIEBjb250cmlidXRvcnMgQWxleGFuZHJlIEJvbm5lYXUsIFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzLFxyXG4gKiAgICAgICAgICAgICAgIGNmLiBBVVRIT1JTLm1kLlxyXG4gKiBAY29weXJpZ2h0ICAgIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXHJcbiAqIEBzaW5jZSAgICAgICAgMjAwOS0wOC0wOVxyXG4gKlxyXG4gKiBAc3VtbWFyeSAgICAgIGF1dG9OdW1lcmljIGlzIGEgbGlicmFyeSB0aGF0IHByb3ZpZGVzIGxpdmUgYXMteW91LXR5cGVcclxuICogICAgICAgICAgICAgICBmb3JtYXR0aW5nIGZvciBpbnRlcm5hdGlvbmFsIG51bWJlcnMgYW5kIGN1cnJlbmNpZXMuXHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgTm90ZSA6IFNvbWUgZnVuY3Rpb25zIGFyZSBib3Jyb3dlZCBmcm9tIGJpZy5qc1xyXG4gKiBAbGluayAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cclxuICpcclxuICogUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vYXV0b051bWVyaWMvYXV0b051bWVyaWNcclxuICpcclxuICogQGxpY2Vuc2UgICAgICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICogQGxpbmsgICAgICAgICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuICogY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG4vKiBnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBkZWZpbmUgKi9cclxuXHJcbi8vIEZ1bmN0aW9ucyBuYW1lcyBmb3IgRVM2IGV4cG9ydHNcclxubGV0IGF1dG9Gb3JtYXQ7XHJcbmxldCBhdXRvVW5Gb3JtYXQ7XHJcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xyXG5sZXQgZ2V0TGFuZ3VhZ2VzO1xyXG5sZXQgdmFsaWRhdGU7XHJcbmxldCBhcmVTZXR0aW5nc1ZhbGlkO1xyXG5cclxuLy8gQXV0b051bWVyaWMgZGVmYXVsdCBzZXR0aW5nc1xyXG4vKipcclxuICogTGlzdCBvZiBhbGxvd2VkIHRhZyBvbiB3aGljaCBhdXRvTnVtZXJpYyBjYW4gYmUgdXNlZC5cclxuICovXHJcbmNvbnN0IGFsbG93ZWRUYWdMaXN0ID0gW1xyXG4gICAgJ2InLFxyXG4gICAgJ2NhcHRpb24nLFxyXG4gICAgJ2NpdGUnLFxyXG4gICAgJ2NvZGUnLFxyXG4gICAgJ2NvbnN0JyxcclxuICAgICdkZCcsXHJcbiAgICAnZGVsJyxcclxuICAgICdkaXYnLFxyXG4gICAgJ2RmbicsXHJcbiAgICAnZHQnLFxyXG4gICAgJ2VtJyxcclxuICAgICdoMScsXHJcbiAgICAnaDInLFxyXG4gICAgJ2gzJyxcclxuICAgICdoNCcsXHJcbiAgICAnaDUnLFxyXG4gICAgJ2g2JyxcclxuICAgICdpbnMnLFxyXG4gICAgJ2tkYicsXHJcbiAgICAnbGFiZWwnLFxyXG4gICAgJ2xpJyxcclxuICAgICdvcHRpb24nLFxyXG4gICAgJ291dHB1dCcsXHJcbiAgICAncCcsXHJcbiAgICAncScsXHJcbiAgICAncycsXHJcbiAgICAnc2FtcGxlJyxcclxuICAgICdzcGFuJyxcclxuICAgICdzdHJvbmcnLFxyXG4gICAgJ3RkJyxcclxuICAgICd0aCcsXHJcbiAgICAndScsXHJcbl07XHJcblxyXG4vKipcclxuICogRGVmYXVsdHMgb3B0aW9ucyBhcmUgcHVibGljIC0gdGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZvbGxvd2luZyBtZXRob2Q6XHJcbiAqIC0gSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIChpZS4gYDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtY3VycmVuY3ktc3ltYm9sPVwiIOKCrFwiPmApXHJcbiAqIC0gT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzIChpZS4gYGFOSW5wdXQuYXV0b051bWVyaWMoJ3VwZGF0ZScsIHsgY3VycmVuY3lTeW1ib2w6ICcg4oKsJyB9KTtgKVxyXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcclxuICovXHJcbmNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHtcclxuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgZ3JvdXBpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgOlxyXG4gICAgICogJywnICAgICAgLy8gQ29tbWFcclxuICAgICAqICcuJyAgICAgIC8vIERvdFxyXG4gICAgICogJyAnICAgICAgLy8gTm9ybWFsIHNwYWNlXHJcbiAgICAgKiAnXFx1MjAwOScgLy8gVGhpbi1zcGFjZVxyXG4gICAgICogJ1xcdTIwMmYnIC8vIE5hcnJvdyBuby1icmVhayBzcGFjZVxyXG4gICAgICogJ1xcdTAwYTAnIC8vIE5vLWJyZWFrIHNwYWNlXHJcbiAgICAgKiAnJyAgICAgICAvLyBObyBzZXBhcmF0b3JcclxuICAgICAqIFwiJ1wiICAgICAgLy8gQXBvc3Ryb3BoZVxyXG4gICAgICogJ9msJyAgICAgIC8vIEFyYWJpYyB0aG91c2FuZHMgc2VwYXJhdG9yXHJcbiAgICAgKiAny5knICAgICAgLy8gRG90IGFib3ZlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNlcFxyXG4gICAgICovXHJcbiAgICBkaWdpdEdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcblxyXG4gICAgLyogUmVtb3ZlIHRoZSB0aG91c2FuZCBzZXBhcmF0b3Igb24gZm9jdXMsIGN1cnJlbmN5IHN5bWJvbCBhbmQgc3VmZml4IG9uIGZvY3VzXHJcbiAgICAgKiBleGFtcGxlIGlmIHRoZSBpbnB1dCB2YWx1ZSBcIiQgMSw5OTkuODggc3VmZml4XCJcclxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBuU2VwXHJcbiAgICAgKi9cclxuICAgIG5vU2VwYXJhdG9yT25Gb2N1czogZmFsc2UsXHJcblxyXG4gICAgLyogRGlnaXRhbCBncm91cGluZyBmb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB1c2VkIGluIEZvcm1hdFxyXG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcclxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiMnNcIiwgcmVzdWx0cyBpbiA5OSw5OTksOTksOTksOTk5IEluZGlhJ3MgbGFraHMgc2NhbGVkXHJcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjNcIiwgcmVzdWx0cyBpbiA5OTksOTk5LDk5OSBkZWZhdWx0XHJcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZEdyb3VwXHJcbiAgICAgKi9cclxuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6ICczJyxcclxuXHJcbiAgICAvKiBBbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlcnMgOlxyXG4gICAgICogJywnIDogQ29tbWFcclxuICAgICAqICcuJyA6IERvdFxyXG4gICAgICogJ8K3JyA6IE1pZGRsZS1kb3RcclxuICAgICAqICfZqycgOiBBcmFiaWMgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgICAqICfijpYnIDogRGVjaW1hbCBzZXBhcmF0b3Iga2V5IHN5bWJvbFxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFEZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbENoYXJhY3RlcjogJy4nLFxyXG5cclxuICAgIC8qIEFsbG93IHRvIGRlY2xhcmUgYW4gYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Igd2hpY2ggaXMgYXV0b21hdGljYWxseSByZXBsYWNlZCBieSBgZGVjaW1hbENoYXJhY3RlcmAgd2hlbiB0eXBlZC5cclxuICAgICAqIFRoaXMgaXMgdXNlZCBieSBjb3VudHJpZXMgdGhhdCB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlXHJcbiAgICAgKiBhIHBlcmlvZCAnZnVsbCBzdG9wJyBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJzIChGcmFuY2Ugb3IgU3BhaW4gZm9yIGluc3RhbmNlKS5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhbHREZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiBudWxsLFxyXG5cclxuICAgIC8qIGN1cnJlbmN5U3ltYm9sID0gYWxsb3dlZCBjdXJyZW5jeSBzeW1ib2xcclxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGN1cnJlbmN5U3ltYm9sOiBcIiRcIlxyXG4gICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgY3VycmVuY3lTeW1ib2w6ICckICdcclxuICAgICAqIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgY3VycmVuY3lTeW1ib2w6ICcgJCdcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2lnblxyXG4gICAgICovXHJcbiAgICBjdXJyZW5jeVN5bWJvbDogJycsXHJcblxyXG4gICAgLyogY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XHJcbiAgICAgKiBmb3IgcHJlZml4IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInBcIiAoZGVmYXVsdClcclxuICAgICAqIGZvciBzdWZmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcFNpZ25cclxuICAgICAqL1xyXG4gICAgLy9UT0RPIFJlbmFtZSB0aGUgb3B0aW9ucyB0byBtb3JlIGV4cGxpY2l0IG5hbWVzICgncCcgPT4gJ3ByZWZpeCcsIGV0Yy4pXHJcbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxyXG5cclxuICAgIC8qIFBsYWNlbWVudCBvZiBuZWdhdGl2ZS9wb3NpdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW5jeVN5bWJvbCBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XHJcbiAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxyXG4gICAgICogLSQxLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwifSBvciB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJsXCJ9XHJcbiAgICAgKiAkLTEsMjM0LjU2ID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn0gLy8gRGVmYXVsdCBpZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyAnbnVsbCcgYW5kIGN1cnJlbmN5U3ltYm9sIGlzIG5vdCBlbXB0eVxyXG4gICAgICogLTEsMjM0LjU2JCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0gLy8gRGVmYXVsdCBpZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyAnbnVsbCcgYW5kIGN1cnJlbmN5U3ltYm9sIGlzIG5vdCBlbXB0eVxyXG4gICAgICogMSwyMzQuNTYtICA9PiB7bmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxyXG4gICAgICogJDEsMjM0LjU2LSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XHJcbiAgICAgKiAxLDIzNC41Ni0kID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIn1cclxuICAgICAqIDEsMjM0LjU2JC0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcE5lZ1xyXG4gICAgICovXHJcbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdwJyA9PiAncHJlZml4JywgZXRjLilcclxuICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBudWxsLFxyXG5cclxuXHJcbiAgICAvKiBBbGxvdyB0aGUgcG9zaXRpdmUgc2lnbiBzeW1ib2wgYCtgIHRvIGJlIGRpc3BsYXllZCBmb3IgcG9zaXRpdmUgbnVtYmVycy5cclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcG9zaXRpdmUgc2lnbiBpcyBub3Qgc2hvd24uXHJcbiAgICAgKiBUaGUgc2lnbiBwbGFjZW1lbnQgaXMgY29udHJvbGxlZCBieSB0aGUgJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBvcHRpb24sIG1pbWlja2luZyB0aGUgbmVnYXRpdmUgc2lnbiBwbGFjZW1lbnQgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIHNob3dQb3NpdGl2ZVNpZ246IGZhbHNlLFxyXG5cclxuICAgIC8qIEFkZGl0aW9uYWwgc3VmZml4XHJcbiAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBzdWZmaXhUZXh0OiAnZ3Jvc3MnLCBhIHNwYWNlIGlzIGFsbG93ZWQgc3VmZml4VGV4dDogJyBkb2xsYXJzJ1xyXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFTdWZmaXhcclxuICAgICAqL1xyXG4gICAgc3VmZml4VGV4dDogJycsXHJcblxyXG4gICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcclxuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcclxuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImZsb29yXCIgYWRoZXJlcyB0byBtaW5pbXVtVmFsdWUgYW5kIGlnbm9yZXMgbWF4aW11bVZhbHVlIHNldHRpbmdzXHJcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJpZ25vcmVcIiBpZ25vcmVzIGJvdGggbWluaW11bVZhbHVlICYgbWF4aW11bVZhbHVlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogb0xpbWl0c1xyXG4gICAgICovXHJcbiAgICBvdmVycmlkZU1pbk1heExpbWl0czogbnVsbCxcclxuXHJcbiAgICAvKiBNYXhpbXVtIHBvc3NpYmxlIHZhbHVlXHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIG1pbmltdW1WYWx1ZVxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHZNYXhcclxuICAgICAqL1xyXG4gICAgbWF4aW11bVZhbHVlOiAnOTk5OTk5OTk5OTk5OS45OScsIC8vIDkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXHJcblxyXG4gICAgLyogTWluaW11bSBwb3NzaWJsZSB2YWx1ZVxyXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxyXG4gICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4aW11bVZhbHVlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdk1pblxyXG4gICAgICovXHJcbiAgICBtaW5pbXVtVmFsdWU6ICctOTk5OTk5OTk5OTk5OS45OScsIC8vIC05Ljk5OS45OTkuOTk5Ljk5OSw5OSB+PSAxMDAwMCBiaWxsaW9uc1xyXG5cclxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIG1pbmltdW1WYWx1ZSAmIG1heGltdW1WYWx1ZSB2YWx1ZXNcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBtRGVjXHJcbiAgICAgKi9cclxuICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZTogbnVsbCxcclxuXHJcbiAgICAvKiBFeHBhbmRlZCBkZWNpbWFsIHBsYWNlcyB2aXNpYmxlIHdoZW4gaW5wdXQgaGFzIGZvY3VzIC0gZXhhbXBsZTpcclxuICAgICAqIHtkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcclxuICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGVEZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1czogbnVsbCxcclxuXHJcbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbFBsYWNlcyAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xyXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgbm9uLXNjYWxlZCB2YWx1ZSBpcyBoZWxkIGluIGRhdGEgYW5kIGl0IGlzIGFkdmlzZWQgdGhhdCB5b3UgdXNlIHRoZSBcInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2VcIiBvcHRpb24gdG8gZW5zdXJlIHJldGFpbmluZyB0aGUgdmFsdWVcclxuICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxyXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsUGxhY2VzOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxyXG4gICAgICogRXhhbXBsZTogZm9jdXNpbiB2YWx1ZSBcIjEsMTExLjExXCIgZm9jdXNvdXQgdmFsdWUgXCIxLjEgS1wiXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiBUaGUgYHNjYWxlRGl2aXNvcmAgZGVjaWRlcyB0aGUgb24gZm9jdXMgdmFsdWUgYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBvbiBmb2N1c291dFxyXG4gICAgICogRXhhbXBsZSB7c2NhbGVEaXZpc29yOiAnMTAwMCd9IG9yIDxpbnB1dCBkYXRhLXNjYWxlLWRpdmlzb3I9XCIxMDAwXCI+XHJcbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxyXG4gICAgICogVGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgJ2hpZGRlbicgZGVjaW1hbHMuXHJcbiAgICAgKi9cclxuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxQbGFjZXNgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxyXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCA7IGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIHRoZSBmb2N1cy5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBzY2FsZURlY2ltYWxcclxuICAgICAqL1xyXG4gICAgc2NhbGVEZWNpbWFsUGxhY2VzOiBudWxsLFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgYHNjYWxlU3ltYm9sYCBvcHRpb24gaXMgYSBzeW1ib2wgcGxhY2VkIGFzIGEgc3VmZml4IHdoZW4gbm90IGluIGZvY3VzLlxyXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCB0b28uXHJcbiAgICAgKi9cclxuICAgIHNjYWxlU3ltYm9sOiBudWxsLFxyXG5cclxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcclxuICAgICAqIGlmIGllIDYgb3IgNyB0aGUgdmFsdWUgd2lsbCBiZSBzYXZlZCBhcyBhIHNlc3Npb24gY29va2llXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVN0b3JcclxuICAgICAqL1xyXG4gICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZTogZmFsc2UsXHJcblxyXG4gICAgLypcclxuICAgICAqIE1hbmFnZSBob3cgYXV0b051bWVyaWMgcmVhY3Qgd2hlbiB0aGUgdXNlciB0cmllcyB0byBwYXN0ZSBhbiBpbnZhbGlkIG51bWJlci5cclxuICAgICAqIC0gJ2Vycm9yJyAgICA6IChUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yKSBUaGUgaW5wdXQgdmFsdWUgaXMgbm90IGNoYW5nZWQgYW5kIGFuIGVycm9yIGlzIG91dHB1dCBpbiB0aGUgY29uc29sZS5cclxuICAgICAqIC0gJ2lnbm9yZScgICA6IGlkZW0gdGhhbiAnZXJyb3InLCBidXQgZmFpbCBzaWxlbnRseSB3aXRob3V0IG91dHB1dHRpbmcgYW55IGVycm9yL3dhcm5pbmcgaW4gdGhlIGNvbnNvbGUuXHJcbiAgICAgKiAtICdjbGFtcCcgICAgOiBpZiB0aGUgcGFzdGVkIHZhbHVlIGlzIGVpdGhlciB0b28gc21hbGwgb3IgdG9vIGJpZyByZWdhcmRpbmcgdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIHJhbmdlLCB0aGVuIHRoZSByZXN1bHQgaXMgY2xhbXBlZCB0byB0aG9zZSBsaW1pdHMuXHJcbiAgICAgKiAtICd0cnVuY2F0ZScgOiBhdXRvTnVtZXJpYyB3aWxsIGluc2VydCBhcyBtYW55IHBhc3RlZCBudW1iZXJzIGl0IGNhbiBhdCB0aGUgaW5pdGlhbCBjYXJldC9zZWxlY3Rpb24sIHVudGlsIGV2ZXJ5dGhpbmcgaXMgcGFzdGVkLCBvciB0aGUgcmFuZ2UgbGltaXQgaXMgaGl0LlxyXG4gICAgICogICAgICAgICAgICAgICAgVGhlIG5vbi1wYXN0ZWQgbnVtYmVycyBhcmUgZHJvcHBlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkIGF0IGFsbC5cclxuICAgICAqIC0gJ3JlcGxhY2UnICA6IGF1dG9OdW1lcmljIHdpbGwgZmlyc3QgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdGhlbiBpZiB0aGUgcmFuZ2UgbGltaXQgaXMgaGl0LCBpdCB3aWxsIHRyeVxyXG4gICAgICogICAgICAgICAgICAgICAgdG8gcmVwbGFjZSBvbmUgYnkgb25lIHRoZSByZW1haW5pbmcgaW5pdGlhbCBudW1iZXJzIChvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQpIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHBhc3RlZCBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgMSA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbmVnYXRpdmUgc2lnbiAnLScgd2lsbCBiZSBhY2NlcHRlZCBhbnl3aGVyZSBpbiB0aGUgaW5wdXQsIGFuZCB3aWxsIHNldCB0aGUgcmVzdWx0aW5nIHZhbHVlIGFzIGEgbmVnYXRpdmUgbnVtYmVyXHJcbiAgICAgKiBOb3RlIDIgOiBBIHBhc3RlIGNvbnRlbnQgc3RhcnRpbmcgd2l0aCBhIG51bWJlciB3aWxsIGJlIGFjY2VwdGVkLCBldmVuIGlmIHRoZSByZXN0IGlzIGdpYmJlcmlzaCAoaWUuICcxMjNmb29iYXI0NTYnKS5cclxuICAgICAqICAgICAgICAgIE9ubHkgdGhlIGZpcnN0IG51bWJlciB3aWxsIGJlIHVzZWQgKGhlcmUgJzEyMycpLlxyXG4gICAgICogTm90ZSAzIDogVGhlIHBhc3RlIGV2ZW50IHdvcmtzIHdpdGggdGhlIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBvcHRpb24gdG9vLlxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gU2hvdWxkbid0IHdlIHVzZSBgdHJ1bmNhdGVgIGFzIHRoZSBkZWZhdWx0IHZhbHVlP1xyXG4gICAgb25JbnZhbGlkUGFzdGU6ICdlcnJvcicsXHJcblxyXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJTXCIsIFJvdW5kLUhhbGYtVXAgU3ltbWV0cmljIChkZWZhdWx0KVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiYVwiLCBSb3VuZC1IYWxmLURvd24gQXN5bW1ldHJpYyAobG93ZXIgY2FzZSBhKVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEXCIsIFJvdW5kIERvd24gXCJSb3VuZC1Ub3dhcmQtWmVyb1wiIC0gc2FtZSBhcyB0cnVuY2F0ZVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiTjA1XCIgUm91bmRzIHRvIHRoZSBuZWFyZXN0IC4wNSA9PiBzYW1lIGFzIFwiQ0hGXCIgdXNlZCBpbiAxLjlYIGFuZCBzdGlsbCB2YWxpZFxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG1Sb3VuZFxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdTJyA9PiAnUm91bmRIYWxmVXBTeW1tZXRyaWMnLCBldGMuKVxyXG4gICAgLy9UT0RPIEFkZCBhbiBgYW4ucm91bmRpbmdNZXRob2RgIG9iamVjdCB0aGF0IGVudW0gdGhvc2Ugb3B0aW9ucyBjbGVhcmx5XHJcbiAgICByb3VuZGluZ01ldGhvZDogJ1MnLFxyXG5cclxuICAgIC8qIEFsbG93IHBhZGRpbmcgdGhlIGRlY2ltYWwgcGxhY2VzIHdpdGggemVyb3NcclxuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IHRydWUgLSBhbHdheXMgUGFkIGRlY2ltYWxzIHdpdGggemVyb3NcclxuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXHJcbiAgICAgKiBOb3RlOiBzZXR0aW5nIGFsbG93RGVjaW1hbFBhZGRpbmcgdG8gJ2ZhbHNlJyB3aWxsIG92ZXJyaWRlIHRoZSAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVBhZFxyXG4gICAgICovXHJcbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB0cnVlLFxyXG5cclxuICAgIC8qIEFkZHMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzIChpZS4gdHJhbnNmb3JtcyAnLSQgOTk5Ljk5JyB0byAnKDk5OS45OSknKVxyXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cclxuICAgICAqIFRoZSBsZWZ0IGFuZCByaWdodCBzeW1ib2xzIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHNlcGFyYXRlZCBieSBhIGNvbW1hXHJcbiAgICAgKiBUaGlzIG9wdGlvbiBjYW4gYmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXMgOlxyXG4gICAgICogbnVsbCwgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSwgd2hpY2ggZGVhY3RpdmF0ZSB0aGlzIGZlYXR1cmVcclxuICAgICAqICcoLCknLFxyXG4gICAgICogJ1ssXScsXHJcbiAgICAgKiAnPCw+JyBvclxyXG4gICAgICogJ3ssfSdcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBuQnJhY2tldFxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCcoLCknID0+ICdwYXJlbnRoZXNlcycsIGV0Yy4pXHJcbiAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogbnVsbCxcclxuXHJcbiAgICAvKiBEaXNwbGF5ZWQgb24gZW1wdHkgc3RyaW5nIFwiXCJcclxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcclxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJwcmVzc1wiIC0gY3VycmVuY3kgc2lnbiBkaXNwbGF5cyBvbiBhbnkga2V5IGJlaW5nIHByZXNzZWRcclxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJhbHdheXNcIiAtIGFsd2F5cyBkaXNwbGF5cyB0aGUgY3VycmVuY3kgc2lnbiBvbmx5XHJcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ25cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB3RW1wdHlcclxuICAgICAqL1xyXG4gICAgZW1wdHlJbnB1dEJlaGF2aW9yOiAnZm9jdXMnLFxyXG5cclxuICAgIC8qIENvbnRyb2xzIGxlYWRpbmcgemVybyBiZWhhdmlvclxyXG4gICAgICogbGVhZGluZ1plcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgKiBsZWFkaW5nWmVybzogXCJkZW55XCIsIC0gYWxsb3dzIG9ubHkgb25lIGxlYWRpbmcgemVybyBvbiB2YWx1ZXMgbGVzcyB0aGFuIG9uZVxyXG4gICAgICogbGVhZGluZ1plcm86IFwia2VlcFwiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIG9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgcmV0YWluZWQuXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbFplcm9cclxuICAgICAqL1xyXG4gICAgbGVhZGluZ1plcm86ICdkZW55JyxcclxuXHJcbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiB0cnVlID0gYXV0b21hdGljYWxseSBmb3JtYXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFGb3JtXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdE9uUGFnZUxvYWQ6IHRydWUsXHJcblxyXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QgYWxsIGtleWJvYXJkIGNvbW1hbmQgd2lsbCBzZWxlY3QgdGhlIGNvbXBsZXRlIGlucHV0IHRleHQsIG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcclxuICAgICAqIE5vdGUgOiBJZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduLCBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBzTnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdE51bWJlck9ubHk6IGZhbHNlLFxyXG5cclxuICAgIC8qIEhlbHBlciBvcHRpb24gZm9yIEFTUC5ORVQgcG9zdGJhY2tcclxuICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcclxuICAgICAqIGV4YW1wbGVzOlxyXG4gICAgICogbm8gZGVmYXVsdCB2YWx1ZT1cIlwiIHtkZWZhdWx0VmFsdWVPdmVycmlkZTogXCJcIn1cclxuICAgICAqIHZhbHVlPTEyMzQuNTYge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiAnMTIzNC41Nid9XHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYW5EZWZhdWx0XHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlOiBudWxsLFxyXG5cclxuICAgIC8qIFJlbW92ZXMgZm9ybWF0dGluZyBvbiBzdWJtaXQgZXZlbnRcclxuICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cclxuICAgICAqIHJldmlldyB0aGUgJ3VuU2V0JyBtZXRob2QgZm9yIG90aGVyIGZvcm1hdHNcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB1blNldE9uU3VibWl0XHJcbiAgICAgKi9cclxuICAgIHVuZm9ybWF0T25TdWJtaXQ6IGZhbHNlLFxyXG5cclxuICAgIC8qIEFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXHJcbiAgICAgKiBudWxsIG9yICdzdHJpbmcnID0+ICdubm5uLm5uJyBvciAnLW5ubm4ubm4nIGFzIHRleHQgdHlwZS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cclxuICAgICAqICdudW1iZXInICAgICAgICAgPT4gbm5ubi5ubiBvciAtbm5ubi5ubiBhcyBhIE51bWJlciAoV2FybmluZzogdGhpcyB3b3JrcyBvbmx5IGZvciBpbnRlZ2VycyBpbmZlcmlvciB0byBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcclxuICAgICAqICcsJyBvciAnLSwnICAgICAgPT4gJ25ubm4sbm4nIG9yICctbm5ubixubidcclxuICAgICAqICcuLScgICAgICAgICAgICAgPT4gJ25ubm4ubm4nIG9yICdubm5uLm5uLSdcclxuICAgICAqICcsLScgICAgICAgICAgICAgPT4gJ25ubm4sbm4nIG9yICdubm5uLG5uLSdcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBvdXRwdXRUeXBlXHJcbiAgICAgKi9cclxuICAgIG91dHB1dEZvcm1hdDogbnVsbCxcclxuXHJcbiAgICAvKiBEZWZpbmVzIGlmIHdhcm5pbmdzIHNob3VsZCBiZSBzaG93blxyXG4gICAgICogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cclxuICAgICAqIHRydWUgPT4gYWxsIHdhcm5pbmcgYXJlIHNob3duXHJcbiAgICAgKiBmYWxzZSA9PiBubyB3YXJuaW5ncyBhcmUgc2hvd24sIG9ubHkgdGhlIHRocm93biBlcnJvcnNcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBkZWJ1Z1xyXG4gICAgICovXHJcbiAgICBzaG93V2FybmluZ3M6IHRydWUsXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoaXMgb3B0aW9uIGlzIHRoZSAnc3RyaWN0IG1vZGUnIChha2EgJ2RlYnVnJyBtb2RlKSwgd2hpY2ggYWxsb3dzIGF1dG9OdW1lcmljIHRvIHN0cmljdGx5IGFuYWx5c2UgdGhlIG9wdGlvbnMgcGFzc2VkLCBhbmQgZmFpbHMgaWYgYW4gdW5rbm93biBvcHRpb25zIGlzIHVzZWQgaW4gdGhlIHNldHRpbmdzIG9iamVjdC5cclxuICAgICAqIFlvdSBzaG91bGQgc2V0IHRoYXQgdG8gJ1RSVUUnIGlmIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSB5b3UgYXJlIG9ubHkgdXNpbmcgJ3B1cmUnIGF1dG9OdW1lcmljIHNldHRpbmdzIG9iamVjdHMgaW4geW91ciBjb2RlLlxyXG4gICAgICogSWYgeW91IHNlZSB1bmNhdWdodCBlcnJvcnMgaW4gdGhlIGNvbnNvbGUgYW5kIHlvdXIgY29kZSBzdGFydHMgdG8gZmFpbCwgdGhpcyBtZWFucyBzb21laG93IHRob3NlIG9wdGlvbnMgZ2V0cyBjb3JydXB0ZWQgYnkgYW5vdGhlciBwcm9ncmFtLlxyXG4gICAgICovXHJcbiAgICBmYWlsT25Vbmtub3duT3B0aW9uOiBmYWxzZSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXlDb2RlIGFzIHNlZW4gaW4gRE9NIGV2ZW50cy5cclxuICogLy9UT0RPIFJlcGxhY2UgZXZlcnkgY2FsbCB0byB0aGlzIG9iamVjdCB3aXRoIGEgY2FsbCB0byBga2V5TmFtZWBcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbmNvbnN0IGtleUNvZGUgPSB7XHJcbiAgICBCYWNrc3BhY2U6ICAgICAgOCxcclxuICAgIFRhYjogICAgICAgICAgICA5LFxyXG4gICAgRW50ZXI6ICAgICAgICAgIDEzLFxyXG4gICAgU2hpZnQ6ICAgICAgICAgIDE2LFxyXG4gICAgQ3RybDogICAgICAgICAgIDE3LFxyXG4gICAgQWx0OiAgICAgICAgICAgIDE4LFxyXG4gICAgUGF1c2VCcmVhazogICAgIDE5LFxyXG4gICAgQ2Fwc0xvY2s6ICAgICAgIDIwLFxyXG4gICAgRXNjOiAgICAgICAgICAgIDI3LFxyXG4gICAgU3BhY2U6ICAgICAgICAgIDMyLFxyXG4gICAgUGFnZVVwOiAgICAgICAgIDMzLFxyXG4gICAgUGFnZURvd246ICAgICAgIDM0LFxyXG4gICAgRW5kOiAgICAgICAgICAgIDM1LFxyXG4gICAgSG9tZTogICAgICAgICAgIDM2LFxyXG4gICAgTGVmdEFycm93OiAgICAgIDM3LFxyXG4gICAgVXBBcnJvdzogICAgICAgIDM4LFxyXG4gICAgUmlnaHRBcnJvdzogICAgIDM5LFxyXG4gICAgRG93bkFycm93OiAgICAgIDQwLFxyXG4gICAgSW5zZXJ0OiAgICAgICAgIDQ1LFxyXG4gICAgRGVsZXRlOiAgICAgICAgIDQ2LFxyXG4gICAgbnVtMDogICAgICAgICAgIDQ4LFxyXG4gICAgbnVtMTogICAgICAgICAgIDQ5LFxyXG4gICAgbnVtMjogICAgICAgICAgIDUwLFxyXG4gICAgbnVtMzogICAgICAgICAgIDUxLFxyXG4gICAgbnVtNDogICAgICAgICAgIDUyLFxyXG4gICAgbnVtNTogICAgICAgICAgIDUzLFxyXG4gICAgbnVtNjogICAgICAgICAgIDU0LFxyXG4gICAgbnVtNzogICAgICAgICAgIDU1LFxyXG4gICAgbnVtODogICAgICAgICAgIDU2LFxyXG4gICAgbnVtOTogICAgICAgICAgIDU3LFxyXG4gICAgYTogICAgICAgICAgICAgIDY1LFxyXG4gICAgYjogICAgICAgICAgICAgIDY2LFxyXG4gICAgYzogICAgICAgICAgICAgIDY3LFxyXG4gICAgZDogICAgICAgICAgICAgIDY4LFxyXG4gICAgZTogICAgICAgICAgICAgIDY5LFxyXG4gICAgZjogICAgICAgICAgICAgIDcwLFxyXG4gICAgZzogICAgICAgICAgICAgIDcxLFxyXG4gICAgaDogICAgICAgICAgICAgIDcyLFxyXG4gICAgaTogICAgICAgICAgICAgIDczLFxyXG4gICAgajogICAgICAgICAgICAgIDc0LFxyXG4gICAgazogICAgICAgICAgICAgIDc1LFxyXG4gICAgbDogICAgICAgICAgICAgIDc2LFxyXG4gICAgbTogICAgICAgICAgICAgIDc3LFxyXG4gICAgbjogICAgICAgICAgICAgIDc4LFxyXG4gICAgbzogICAgICAgICAgICAgIDc5LFxyXG4gICAgcDogICAgICAgICAgICAgIDgwLFxyXG4gICAgcTogICAgICAgICAgICAgIDgxLFxyXG4gICAgcjogICAgICAgICAgICAgIDgyLFxyXG4gICAgczogICAgICAgICAgICAgIDgzLFxyXG4gICAgdDogICAgICAgICAgICAgIDg0LFxyXG4gICAgdTogICAgICAgICAgICAgIDg1LFxyXG4gICAgdjogICAgICAgICAgICAgIDg2LFxyXG4gICAgdzogICAgICAgICAgICAgIDg3LFxyXG4gICAgeDogICAgICAgICAgICAgIDg4LFxyXG4gICAgeTogICAgICAgICAgICAgIDg5LFxyXG4gICAgejogICAgICAgICAgICAgIDkwLFxyXG4gICAgV2luZG93czogICAgICAgIDkxLFxyXG4gICAgUmlnaHRDbGljazogICAgIDkzLFxyXG4gICAgbnVtcGFkMDogICAgICAgIDk2LFxyXG4gICAgbnVtcGFkMTogICAgICAgIDk3LFxyXG4gICAgbnVtcGFkMjogICAgICAgIDk4LFxyXG4gICAgbnVtcGFkMzogICAgICAgIDk5LFxyXG4gICAgbnVtcGFkNDogICAgICAgIDEwMCxcclxuICAgIG51bXBhZDU6ICAgICAgICAxMDEsXHJcbiAgICBudW1wYWQ2OiAgICAgICAgMTAyLFxyXG4gICAgbnVtcGFkNzogICAgICAgIDEwMyxcclxuICAgIG51bXBhZDg6ICAgICAgICAxMDQsXHJcbiAgICBudW1wYWQ5OiAgICAgICAgMTA1LFxyXG4gICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcclxuICAgIFBsdXNOdW1wYWQ6ICAgICAxMDcsXHJcbiAgICBNaW51c051bXBhZDogICAgMTA5LFxyXG4gICAgRG90TnVtcGFkOiAgICAgIDExMCxcclxuICAgIFNsYXNoTnVtcGFkOiAgICAxMTEsXHJcbiAgICBGMTogICAgICAgICAgICAgMTEyLFxyXG4gICAgRjI6ICAgICAgICAgICAgIDExMyxcclxuICAgIEYzOiAgICAgICAgICAgICAxMTQsXHJcbiAgICBGNDogICAgICAgICAgICAgMTE1LFxyXG4gICAgRjU6ICAgICAgICAgICAgIDExNixcclxuICAgIEY2OiAgICAgICAgICAgICAxMTcsXHJcbiAgICBGNzogICAgICAgICAgICAgMTE4LFxyXG4gICAgRjg6ICAgICAgICAgICAgIDExOSxcclxuICAgIEY5OiAgICAgICAgICAgICAxMjAsXHJcbiAgICBGMTA6ICAgICAgICAgICAgMTIxLFxyXG4gICAgRjExOiAgICAgICAgICAgIDEyMixcclxuICAgIEYxMjogICAgICAgICAgICAxMjMsXHJcbiAgICBOdW1Mb2NrOiAgICAgICAgMTQ0LFxyXG4gICAgU2Nyb2xsTG9jazogICAgIDE0NSxcclxuICAgIE15Q29tcHV0ZXI6ICAgICAxODIsXHJcbiAgICBNeUNhbGN1bGF0b3I6ICAgMTgzLFxyXG4gICAgU2VtaWNvbG9uOiAgICAgIDE4NixcclxuICAgIEVxdWFsOiAgICAgICAgICAxODcsXHJcbiAgICBDb21tYTogICAgICAgICAgMTg4LFxyXG4gICAgSHlwaGVuOiAgICAgICAgIDE4OSxcclxuICAgIERvdDogICAgICAgICAgICAxOTAsXHJcbiAgICBTbGFzaDogICAgICAgICAgMTkxLFxyXG4gICAgQmFja3F1b3RlOiAgICAgIDE5MixcclxuICAgIExlZnRCcmFja2V0OiAgICAyMTksXHJcbiAgICBCYWNrc2xhc2g6ICAgICAgMjIwLFxyXG4gICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcclxuICAgIFF1b3RlOiAgICAgICAgICAyMjIsXHJcbiAgICBDb21tYW5kOiAgICAgICAgMjI0LFxyXG4gICAgQW5kcm9pZERlZmF1bHQ6IDIyOSwgLy8gQW5kcm9pZCBDaHJvbWUgcmV0dXJucyB0aGUgc2FtZSBrZXljb2RlIG51bWJlciAyMjkgZm9yIGFsbCBrZXlzIHByZXNzZWRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXkgbmFtZSAoYXMgc2V0IGluIEtleWJvYXJkRXZlbnQua2V5KS5cclxuICogVGhvc2UgbmFtZXMgYXJlIGxpc3RlZCBoZXJlIDpcclxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5L0tleV9WYWx1ZXNcclxuICovXHJcbmNvbnN0IGtleU5hbWUgPSB7XHJcbiAgICAvLyBTcGVjaWFsIHZhbHVlc1xyXG4gICAgVW5pZGVudGlmaWVkOiAgICdVbmlkZW50aWZpZWQnLFxyXG5cclxuICAgIC8vIE1vZGlmaWVyIGtleXNcclxuICAgIEFsdDogICAgICAgICAgICAnQWx0JyxcclxuICAgIEFsdEdyOiAgICAgICAgICAnQWx0R3JhcGgnLFxyXG4gICAgQ2Fwc0xvY2s6ICAgICAgICdDYXBzTG9jaycsIC8vIFVuZGVyIENocm9tZSwgZS5rZXkgaXMgZW1wdHkgZm9yIENhcHNMb2NrXHJcbiAgICBDdHJsOiAgICAgICAgICAgJ0NvbnRyb2wnLFxyXG4gICAgRm46ICAgICAgICAgICAgICdGbicsXHJcbiAgICBGbkxvY2s6ICAgICAgICAgJ0ZuTG9jaycsXHJcbiAgICBIeXBlcjogICAgICAgICAgJ0h5cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XHJcbiAgICBNZXRhOiAgICAgICAgICAgJ01ldGEnLCAvLyBUaGUgV2luZG93cywgQ29tbWFuZCBvciDijJgga2V5IC8vICdPUycgdW5kZXIgRmlyZWZveCBhbmQgSUU5XHJcbiAgICBXaW5kb3dzOiAgICAgICAgJ01ldGEnLCAvLyBUaGlzIGlzIGEgbm9uLW9mZmljaWFsIGtleSBuYW1lXHJcbiAgICBDb21tYW5kOiAgICAgICAgJ01ldGEnLCAvLyBUaGlzIGlzIGEgbm9uLW9mZmljaWFsIGtleSBuYW1lXHJcbiAgICBOdW1Mb2NrOiAgICAgICAgJ051bUxvY2snLFxyXG4gICAgU2Nyb2xsTG9jazogICAgICdTY3JvbGxMb2NrJyxcclxuICAgIFNoaWZ0OiAgICAgICAgICAnU2hpZnQnLFxyXG4gICAgU3VwZXI6ICAgICAgICAgICdTdXBlcicsIC8vICdPUycgdW5kZXIgRmlyZWZveFxyXG4gICAgU3ltYm9sOiAgICAgICAgICdTeW1ib2wnLFxyXG4gICAgU3ltYm9sTG9jazogICAgICdTeW1ib2xMb2NrJyxcclxuXHJcbiAgICAvLyBXaGl0ZXNwYWNlIGtleXNcclxuICAgIEVudGVyOiAgICAgICAgICAnRW50ZXInLFxyXG4gICAgVGFiOiAgICAgICAgICAgICdUYWInLFxyXG4gICAgU3BhY2U6ICAgICAgICAgICcgJywgLy8gJ1NwYWNlYmFyJyBmb3IgRmlyZWZveCA8MzcsIGFuZCBJRTlcclxuXHJcbiAgICAvLyBOYXZpZ2F0aW9uIGtleXNcclxuICAgIERvd25BcnJvdzogICAgICAnQXJyb3dEb3duJywgLy8gJ0Rvd24nIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIExlZnRBcnJvdzogICAgICAnQXJyb3dMZWZ0JywgLy8gJ0xlZnQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIFJpZ2h0QXJyb3c6ICAgICAnQXJyb3dSaWdodCcsIC8vICdSaWdodCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgVXBBcnJvdzogICAgICAgICdBcnJvd1VwJywgLy8gJ1VwJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBFbmQ6ICAgICAgICAgICAgJ0VuZCcsXHJcbiAgICBIb21lOiAgICAgICAgICAgJ0hvbWUnLFxyXG4gICAgUGFnZURvd246ICAgICAgICdQYWdlRG93bicsXHJcbiAgICBQYWdlVXA6ICAgICAgICAgJ1BhZ2VVcCcsXHJcblxyXG4gICAgLy8gRWRpdGluZyBrZXlzXHJcbiAgICBCYWNrc3BhY2U6ICAgICAgJ0JhY2tzcGFjZScsXHJcbiAgICBDbGVhcjogICAgICAgICAgJ0NsZWFyJyxcclxuICAgIENvcHk6ICAgICAgICAgICAnQ29weScsXHJcbiAgICBDclNlbDogICAgICAgICAgJ0NyU2VsJywgLy8gJ0Nyc2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBDdXQ6ICAgICAgICAgICAgJ0N1dCcsXHJcbiAgICBEZWxldGU6ICAgICAgICAgJ0RlbGV0ZScsIC8vICdEZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEVyYXNlRW9mOiAgICAgICAnRXJhc2VFb2YnLFxyXG4gICAgRXhTZWw6ICAgICAgICAgICdFeFNlbCcsIC8vICdFeHNlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgSW5zZXJ0OiAgICAgICAgICdJbnNlcnQnLFxyXG4gICAgUGFzdGU6ICAgICAgICAgICdQYXN0ZScsXHJcbiAgICBSZWRvOiAgICAgICAgICAgJ1JlZG8nLFxyXG4gICAgVW5kbzogICAgICAgICAgICdVbmRvJyxcclxuXHJcbiAgICAvLyBVSSBrZXlzXHJcbiAgICBBY2NlcHQ6ICAgICAgICAgJ0FjY2VwdCcsXHJcbiAgICBBZ2FpbjogICAgICAgICAgJ0FnYWluJyxcclxuICAgIEF0dG46ICAgICAgICAgICAnQXR0bicsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94LCBDaHJvbWUsIGFuZCBJRTkgKCdLYW5hTW9kZScgd2hlbiB1c2luZyB0aGUgSmFwYW5lc2Uga2V5Ym9hcmQgbGF5b3V0KVxyXG4gICAgQ2FuY2VsOiAgICAgICAgICdDYW5jZWwnLFxyXG4gICAgQ29udGV4dE1lbnU6ICAgICdDb250ZXh0TWVudScsIC8vICdBcHBzJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBFc2M6ICAgICAgICAgICAgJ0VzY2FwZScsIC8vICdFc2MnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEV4ZWN1dGU6ICAgICAgICAnRXhlY3V0ZScsXHJcbiAgICBGaW5kOiAgICAgICAgICAgJ0ZpbmQnLFxyXG4gICAgRmluaXNoOiAgICAgICAgICdGaW5pc2gnLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCwgQ2hyb21lLCBhbmQgSUU5ICgnS2F0YWthbmEnIHdoZW4gdXNpbmcgdGhlIEphcGFuZXNlIGtleWJvYXJkIGxheW91dClcclxuICAgIEhlbHA6ICAgICAgICAgICAnSGVscCcsXHJcbiAgICBQYXVzZTogICAgICAgICAgJ1BhdXNlJyxcclxuICAgIFBsYXk6ICAgICAgICAgICAnUGxheScsXHJcbiAgICBQcm9wczogICAgICAgICAgJ1Byb3BzJyxcclxuICAgIFNlbGVjdDogICAgICAgICAnU2VsZWN0JyxcclxuICAgIFpvb21JbjogICAgICAgICAnWm9vbUluJyxcclxuICAgIFpvb21PdXQ6ICAgICAgICAnWm9vbU91dCcsXHJcblxyXG4gICAgLy8gRGV2aWNlIGtleXNcclxuICAgIEJyaWdodG5lc3NEb3duOiAnQnJpZ2h0bmVzc0Rvd24nLFxyXG4gICAgQnJpZ2h0bmVzc1VwOiAgICdCcmlnaHRuZXNzVXAnLFxyXG4gICAgRWplY3Q6ICAgICAgICAgICdFamVjdCcsXHJcbiAgICBMb2dPZmY6ICAgICAgICAgJ0xvZ09mZicsXHJcbiAgICBQb3dlcjogICAgICAgICAgJ1Bvd2VyJyxcclxuICAgIFBvd2VyT2ZmOiAgICAgICAnUG93ZXJPZmYnLFxyXG4gICAgUHJpbnRTY3JlZW46ICAgICdQcmludFNjcmVlbicsXHJcbiAgICBIaWJlcm5hdGU6ICAgICAgJ0hpYmVybmF0ZScsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94IDw9MzdcclxuICAgIFN0YW5kYnk6ICAgICAgICAnU3RhbmRieScsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIFdha2VVcDogICAgICAgICAnV2FrZVVwJyxcclxuXHJcbiAgICAvLyBJTUUgYW5kIGNvbXBvc2l0aW9uIGtleXNcclxuICAgIENvbXBvc2U6ICAgICAgICAnQ29tcG9zZScsXHJcbiAgICBEZWFkOiAgICAgICAgICAgJ0RlYWQnLFxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIGtleXNcclxuICAgIEYxOiAgICAgICAgICAgICAnRjEnLFxyXG4gICAgRjI6ICAgICAgICAgICAgICdGMicsXHJcbiAgICBGMzogICAgICAgICAgICAgJ0YzJyxcclxuICAgIEY0OiAgICAgICAgICAgICAnRjQnLFxyXG4gICAgRjU6ICAgICAgICAgICAgICdGNScsXHJcbiAgICBGNjogICAgICAgICAgICAgJ0Y2JyxcclxuICAgIEY3OiAgICAgICAgICAgICAnRjcnLFxyXG4gICAgRjg6ICAgICAgICAgICAgICdGOCcsXHJcbiAgICBGOTogICAgICAgICAgICAgJ0Y5JyxcclxuICAgIEYxMDogICAgICAgICAgICAnRjEwJyxcclxuICAgIEYxMTogICAgICAgICAgICAnRjExJyxcclxuICAgIEYxMjogICAgICAgICAgICAnRjEyJyxcclxuXHJcbiAgICAvLyBEb2N1bWVudCBrZXlzXHJcbiAgICBQcmludDogICAgICAgICAgJ1ByaW50JyxcclxuXHJcbiAgICAvLyAnTm9ybWFsJyBrZXlzXHJcbiAgICBudW0wOiAgICAgICAgICAgJzAnLFxyXG4gICAgbnVtMTogICAgICAgICAgICcxJyxcclxuICAgIG51bTI6ICAgICAgICAgICAnMicsXHJcbiAgICBudW0zOiAgICAgICAgICAgJzMnLFxyXG4gICAgbnVtNDogICAgICAgICAgICc0JyxcclxuICAgIG51bTU6ICAgICAgICAgICAnNScsXHJcbiAgICBudW02OiAgICAgICAgICAgJzYnLFxyXG4gICAgbnVtNzogICAgICAgICAgICc3JyxcclxuICAgIG51bTg6ICAgICAgICAgICAnOCcsXHJcbiAgICBudW05OiAgICAgICAgICAgJzknLFxyXG4gICAgbnVtcGFkMDogICAgICAgICcwJyxcclxuICAgIG51bXBhZDE6ICAgICAgICAnMScsXHJcbiAgICBudW1wYWQyOiAgICAgICAgJzInLFxyXG4gICAgbnVtcGFkMzogICAgICAgICczJyxcclxuICAgIG51bXBhZDQ6ICAgICAgICAnNCcsXHJcbiAgICBudW1wYWQ1OiAgICAgICAgJzUnLFxyXG4gICAgbnVtcGFkNjogICAgICAgICc2JyxcclxuICAgIG51bXBhZDc6ICAgICAgICAnNycsXHJcbiAgICBudW1wYWQ4OiAgICAgICAgJzgnLFxyXG4gICAgbnVtcGFkOTogICAgICAgICc5JyxcclxuICAgIGE6ICAgICAgICAgICAgICAnYScsXHJcbiAgICBiOiAgICAgICAgICAgICAgJ2InLFxyXG4gICAgYzogICAgICAgICAgICAgICdjJyxcclxuICAgIGQ6ICAgICAgICAgICAgICAnZCcsXHJcbiAgICBlOiAgICAgICAgICAgICAgJ2UnLFxyXG4gICAgZjogICAgICAgICAgICAgICdmJyxcclxuICAgIGc6ICAgICAgICAgICAgICAnZycsXHJcbiAgICBoOiAgICAgICAgICAgICAgJ2gnLFxyXG4gICAgaTogICAgICAgICAgICAgICdpJyxcclxuICAgIGo6ICAgICAgICAgICAgICAnaicsXHJcbiAgICBrOiAgICAgICAgICAgICAgJ2snLFxyXG4gICAgbDogICAgICAgICAgICAgICdsJyxcclxuICAgIG06ICAgICAgICAgICAgICAnbScsXHJcbiAgICBuOiAgICAgICAgICAgICAgJ24nLFxyXG4gICAgbzogICAgICAgICAgICAgICdvJyxcclxuICAgIHA6ICAgICAgICAgICAgICAncCcsXHJcbiAgICBxOiAgICAgICAgICAgICAgJ3EnLFxyXG4gICAgcjogICAgICAgICAgICAgICdyJyxcclxuICAgIHM6ICAgICAgICAgICAgICAncycsXHJcbiAgICB0OiAgICAgICAgICAgICAgJ3QnLFxyXG4gICAgdTogICAgICAgICAgICAgICd1JyxcclxuICAgIHY6ICAgICAgICAgICAgICAndicsXHJcbiAgICB3OiAgICAgICAgICAgICAgJ3cnLFxyXG4gICAgeDogICAgICAgICAgICAgICd4JyxcclxuICAgIHk6ICAgICAgICAgICAgICAneScsXHJcbiAgICB6OiAgICAgICAgICAgICAgJ3onLFxyXG4gICAgTXVsdGlwbHlOdW1wYWQ6ICcqJyxcclxuICAgIFBsdXNOdW1wYWQ6ICAgICAnKycsXHJcbiAgICBNaW51c051bXBhZDogICAgJy0nLFxyXG4gICAgRG90TnVtcGFkOiAgICAgICcuJyxcclxuICAgIFNsYXNoTnVtcGFkOiAgICAnLycsXHJcbiAgICBTZW1pY29sb246ICAgICAgJzsnLFxyXG4gICAgRXF1YWw6ICAgICAgICAgICc9JyxcclxuICAgIENvbW1hOiAgICAgICAgICAnLCcsXHJcbiAgICBIeXBoZW46ICAgICAgICAgJy0nLFxyXG4gICAgTWludXM6ICAgICAgICAgICctJyxcclxuICAgIFBsdXM6ICAgICAgICAgICAnKycsXHJcbiAgICBEb3Q6ICAgICAgICAgICAgJy4nLFxyXG4gICAgU2xhc2g6ICAgICAgICAgICcvJyxcclxuICAgIEJhY2txdW90ZTogICAgICAnYCcsXHJcbiAgICBMZWZ0QnJhY2tldDogICAgJ1snLFxyXG4gICAgUmlnaHRCcmFja2V0OiAgICddJyxcclxuICAgIEJhY2tzbGFzaDogICAgICAnXFxcXCcsXHJcbiAgICBRdW90ZTogICAgICAgICAgXCInXCIsXHJcbiAgICBOdW1wYWREb3Q6ICAgICAgJy4nLFxyXG4gICAgTnVtcGFkRG90QWx0OiAgICcsJywgLy8gTW9kZXJuIGJyb3dzZXJzIGF1dG9tYXRpY2FsbHkgYWRhcHQgdGhlIGNoYXJhY3RlciBzZW50IGJ5IHRoaXMga2V5IHRvIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBsYW5ndWFnZVxyXG4gICAgTnVtcGFkTXVsdGlwbHk6ICcqJyxcclxuICAgIE51bXBhZFBsdXM6ICAgICAnKycsXHJcbiAgICBOdW1wYWRNaW51czogICAgJy0nLFxyXG4gICAgTnVtcGFkU2xhc2g6ICAgICcvJyxcclxuICAgIE51bXBhZERvdE9ic29sZXRlQnJvd3NlcnM6ICAgICAgJ0RlY2ltYWwnLFxyXG4gICAgTnVtcGFkTXVsdGlwbHlPYnNvbGV0ZUJyb3dzZXJzOiAnTXVsdGlwbHknLFxyXG4gICAgTnVtcGFkUGx1c09ic29sZXRlQnJvd3NlcnM6ICAgICAnQWRkJyxcclxuICAgIE51bXBhZE1pbnVzT2Jzb2xldGVCcm93c2VyczogICAgJ1N1YnRyYWN0JyxcclxuICAgIE51bXBhZFNsYXNoT2Jzb2xldGVCcm93c2VyczogICAgJ0RpdmlkZScsXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0TWluaW11bVZhbHVlICAgICA9ICctOTk5OTk5OTk5OTk5Ljk5JztcclxuY29uc3QgZGVmYXVsdE1heGltdW1WYWx1ZSAgICAgPSAnOTk5OTk5OTk5OTk5Ljk5JztcclxuY29uc3QgZGVmYXVsdFJvdW5kaW5nTWV0aG9kICAgPSAnVSc7XHJcbmNvbnN0IGRlZmF1bHRMZWFkaW5nWmVybyAgICAgID0gJ2RlbnknO1xyXG5jb25zdCBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSA9IHRydWU7XHJcblxyXG4vKipcclxuICogUHJlZGVmaW5lZCBvcHRpb25zIGZvciB0aGUgbW9zdCBjb21tb24gbGFuZ3VhZ2VzXHJcbiAqL1xyXG5jb25zdCBsYW5ndWFnZU9wdGlvbiA9IHtcclxuICAgIEZyZW5jaDogeyAvLyBGcmFuw6dhaXNcclxuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICA6ICcuJywgLy8gb3IgJ1xcdTIwMmYnXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiAnLicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgOiAnXFx1MjAyZuKCrCcsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgOiAncycsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcclxuICAgICAgICBsZWFkaW5nWmVybyAgICAgICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXHJcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxyXG4gICAgfSxcclxuICAgIE5vcnRoQW1lcmljYW46IHtcclxuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgIDogJywnLFxyXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICA6ICckJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxyXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXHJcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgQnJpdGlzaDoge1xyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICA6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgIDogJ8KjJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxyXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXHJcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgU3dpc3M6IHsgLy8gU3Vpc3NlXHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6IGAnYCxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnXFx1MjAyZkNIRicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6ICdzJyxcclxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgIDogZGVmYXVsdFNlbGVjdE51bWJlck9ubHksXHJcbiAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcclxuICAgICAgICBsZWFkaW5nWmVybyAgICAgICAgICAgIDogZGVmYXVsdExlYWRpbmdaZXJvLFxyXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWluaW11bVZhbHVlLFxyXG4gICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxyXG4gICAgfSxcclxuICAgIEphcGFuZXNlOiB7IC8vIOaXpeacrOiqnlxyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICA6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgIDogJ8KlJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxyXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXHJcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgVHVya2lzaDoge1xyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiAnLicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2w6ICfigK/igronLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncycsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seTogZGVmYXVsdFNlbGVjdE51bWJlck9ubHksXHJcbiAgICAgICAgcm91bmRpbmdNZXRob2Q6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcclxuICAgICAgICBsZWFkaW5nWmVybzogZGVmYXVsdExlYWRpbmdaZXJvLFxyXG4gICAgICAgIG1pbmltdW1WYWx1ZTogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWU6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6ICdwJyxcclxuICAgIH0sXHJcbn07XHJcbmxhbmd1YWdlT3B0aW9uLlNwYW5pc2ggPSBsYW5ndWFnZU9wdGlvbi5GcmVuY2g7IC8vIEVzcGHDsW9sIChpZGVtIEZyZW5jaClcclxubGFuZ3VhZ2VPcHRpb24uQ2hpbmVzZSA9IGxhbmd1YWdlT3B0aW9uLkphcGFuZXNlOyAvLyDkuK3lm73oqp4gKENoaW5lc2UpXHJcblxyXG4vKipcclxuICogVU1EIHN0cnVjdHVyZVxyXG4gKi9cclxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcclxuICAgIC8vVE9ETyBUaGlzIHN1cmVseSBjYW4gYmUgaW1wcm92ZWQgYnkgbGV0dGluZyB3ZWJwYWNrIHRha2UgY2FyZSBvZiBnZW5lcmF0aW5nIHRoaXMgVU1EIHBhcnRcclxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcclxufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcbn0gZWxzZSB7XHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xyXG59XHJcbn0oJCA9PiB7XHJcbiAgICBjb25zdCBqUXVlcnlPcmlnaW5hbFZhbCA9ICQuZm4udmFsO1xyXG5cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIG51bGxcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbCwgRkFMU0Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIEZBTFNFIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCgwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgbnVsbCBvciBlbXB0eVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQoMCkgfHwgJycgPT09IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdib29sZWFuJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW55IGNhc2VzIGZvciB0aG9zZSBzdHJpbmdzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVZhbHVlID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBsb3dlcmNhc2VWYWx1ZSA9PT0gJ3RydWUnIHx8IGxvd2VyY2FzZVZhbHVlID09PSAnZmFsc2UnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHJlZmVyZW5jZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHJlZmVyZW5jZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHlcclxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3OTkxNS9ob3ctZG8taS10ZXN0LWZvci1hbi1lbXB0eS1qYXZhc2NyaXB0LW9iamVjdCBhbmQgaHR0cDovL2pzcGVyZi5jb20vZW1wdHktb2JqZWN0LXRlc3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNFbXB0eU9iaihvYmopIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIgKG9yIGEgbnVtYmVyIHdyaXR0ZW4gYXMgYSBzdHJpbmcpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gblxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcclxuICAgICAgICByZXR1cm4gIWlzQXJyYXkobikgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBpbnRlZ2VyIChhbmQgbm90IGEgZmxvYXQpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gblxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmIHBhcnNlRmxvYXQobikgPT09IHBhcnNlSW50KG4sIDEwKSAmJiAhaXNOYU4obik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHBhc3RlZCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJlcGFyZVBhc3RlZFRleHQodGV4dCwgaG9sZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSwgdHJ1ZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXHJcbiAgICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvZXJjZSB0aGUgcGFyYW1ldGVycyB0eXBlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkbGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIG5lZWRsZSkge1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcobmVlZGxlKSB8fCBzdHIgPT09ICcnIHx8IG5lZWRsZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGBuZWVkbGVgIGlzIGluIHRoZSBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzSW5BcnJheShuZWVkbGUsIGFycmF5KSB7XHJcbiAgICAgICAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgaXNVbmRlZmluZWQobmVlZGxlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gQXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IGFyclxyXG4gICAgICogQHRocm93cyBFcnJvclxyXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgeyAvLyBNYWtlIHN1cmUgYW4gYXJyYXkgaGFzIGEgY2xhc3MgYXR0cmlidXRlIG9mIFtvYmplY3QgQXJyYXldXHJcbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSB8fCAodHlwZW9mIGFyciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b1N0cmluZyBtZXNzYWdlIGNoYW5nZWQgZm9yIE9iamVjdCBBcnJheScpOyAvLyBWZXJpZnkgdGhhdCB0aGUgc3RyaW5nIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AgZG9lcyBub3QgY2hhbmdlIGluIHRoZSBmdXR1cmUgKGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MzY1MjE1KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIC8vIGZ1bmN0aW9uIGhhc0RlY2ltYWxzKHN0cikge1xyXG4gICAgLy8gICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xyXG4gICAgLy8gICAgIHJldHVybiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHJldHVybnMge2ludH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhzdHIpIHtcclxuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbFBhcnQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNvZGUgZm9yIHRoZSBrZXkgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBrZXlDb2RlTnVtYmVyKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gYGV2ZW50LmtleUNvZGVgIGFuZCBgZXZlbnQud2hpY2hgIGFyZSBkZXByZWNhdGVkLCBgS2V5Ym9hcmRFdmVudC5rZXlgIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpIG11c3QgYmUgdXNlZCBub3dcclxuICAgICAgICByZXR1cm4gKHR5cGVvZiBldmVudC53aGljaCA9PT0gJ3VuZGVmaW5lZCcpP2V2ZW50LmtleUNvZGU6ZXZlbnQud2hpY2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNoYXJhY3RlciBmcm9tIHRoZSBldmVudCBrZXkgY29kZS5cclxuICAgICAqIEBleGFtcGxlIGNoYXJhY3Rlcig1MCkgPT4gJzInXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoYXJhY3RlcihldmVudCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQua2V5ID09PSAndW5kZWZpbmVkJyB8fCBldmVudC5rZXkgPT09ICdVbmlkZW50aWZpZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGVOdW1iZXIoZXZlbnQpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIG9ic29sZXRlIGJyb3dzZXJzIGxpa2UgSUUgdGhhdCByZXR1cm4gdGhlIG9sZCBuYW1lc1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnRGVjaW1hbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWREb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdNdWx0aXBseSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWRNdWx0aXBseTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0FkZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWRQbHVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnU3VidHJhY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkTWludXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdEaXZpZGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkU2xhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdEZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgd29ya2Fyb3VuZCBmb3IgdGhlIG9ic29sZXRlIGJyb3dzZXIgSUUxMSB3aGljaCBvdXRwdXQgYSAnRGVsZXRlJyBrZXkgd2hlbiB1c2luZyB0aGUgbnVtcGFkICdkb3QnIG9uZSEgVGhpcyBmaXhlcyBpc3N1ZSAjNDAxIC8vRklYTUUgw6AgdGVybWluZXJcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlOYW1lLkRvdDsgLy8gYXMgb2YgdmVyc2lvbiAyLjAuOCB0aGUgY2hhcmFjdGVyKCkgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgb24ga2V5cHJlc3MgZXZlbnQuIFRoZSAnRGVsJyBkb2VzIG5vdCB0aHJvdyB0aGUga2V5cHJlc3MgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50LmtleTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gdmFsdWUgKGEgbnVtYmVyIGFzIGEgc3RyaW5nKSBpcyB3aXRoaW4gdGhlIHJhbmdlIHNldCBpbiB0aGUgc2V0dGluZ3MgYG1pbmltdW1WYWx1ZWAgYW5kIGBtYXhpbXVtVmFsdWVgLCBGQUxTRSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWluVmFsdWUgUGFyc2VkIHZpYSB0aGUgYHBhcnNlU3RyKClgIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWF4VmFsdWUgUGFyc2VkIHZpYSB0aGUgYHBhcnNlU3RyKClgIGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hlY2tJZkluUmFuZ2UodmFsdWUsIHBhcnNlZE1pblZhbHVlLCBwYXJzZWRNYXhWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VTdHIodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0ZXN0TWluTWF4KHBhcnNlZE1pblZhbHVlLCBwYXJzZWRWYWx1ZSkgPiAtMSAmJiB0ZXN0TWluTWF4KHBhcnNlZE1heFZhbHVlLCBwYXJzZWRWYWx1ZSkgPCAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBhIG5lZ2F0aXZlIHNpZ24gOlxyXG4gICAgICogLSBldmVyeXdoZXJlIGluIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQpLCBvclxyXG4gICAgICogLSBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9ubHkgaWYgdGhlIGBjaGVja0V2ZXJ5d2hlcmVgIHBhcmFtZXRlciBpcyBzZXQgdG8gYGZhbHNlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZyBBIG51bWJlciByZXByZXNlbnRlZCBieSBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGVja0V2ZXJ5d2hlcmUgSWYgVFJVRSwgdGhlbiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBzZWFyY2ggZXZlcnl3aGVyZSBpbiB0aGUgbnVtZXJpYyBzdHJpbmcgKHRoaXMgaXMgbmVlZGVkIGZvciBpbnN0YW5jZSBpZiB0aGUgc3RyaW5nIGlzICcxMjM0LjU2LScpXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNOZWdhdGl2ZShudW1lcmljU3RyaW5nLCBjaGVja0V2ZXJ5d2hlcmUgPSB0cnVlKSB7XHJcbiAgICAgICAgLy9UT0RPIFVzZSB0aGUgYG5lZ2F0aXZlU2lnbkNoYXJhY3RlcmAgZnJvbSB0aGUgc2V0dGluZ3MgaGVyZVxyXG4gICAgICAgIGlmIChjaGVja0V2ZXJ5d2hlcmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKG51bWVyaWNTdHJpbmcsICctJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZVN0cmljdChudW1lcmljU3RyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBuZWdhdGl2ZSBzaWduIG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXIgKG9uIHRoZSBmYXIgbGVmdCkuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnMTIzNC41NicpICAgICA9PiBmYWxzZVxyXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnMTIzNC41Ni0nKSAgICA9PiBmYWxzZVxyXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnLTEyMzQuNTYnKSAgICA9PiB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCctMSwyMzQuNTYg4oKsJykgPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNOZWdhdGl2ZVN0cmljdChudW1lcmljU3RyaW5nKSB7XHJcbiAgICAgICAgLy9UT0RPIFVzaW5nIHRoZSBgbmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBmcm9tIHRoZSBzZXR0aW5ncyBoZXJlXHJcbiAgICAgICAgcmV0dXJuIG51bWVyaWNTdHJpbmcuY2hhckF0KDApID09PSAnLSc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZm9ybWF0dGVkIG9yIHVuZm9ybWF0dGVkIG51bWVyaWMgc3RyaW5nIHJlcHJlc2VudCB0aGUgdmFsdWUgMCAoaWUuICcwLDAwIOKCrCcpLCBvciBpcyBlbXB0eSAoJyDigqwnKS5cclxuICAgICAqIFRoaXMgd29ya3Mgc2luY2Ugd2UgdGVzdCBpZiB0aGVyZSBhcmUgYW55IG51bWJlcnMgZnJvbSAxIHRvIDkgaW4gdGhlIHN0cmluZy4gSWYgdGhlcmUgaXMgbm9uZSwgdGhlbiB0aGUgbnVtYmVyIGlzIHplcm8gKG9yIHRoZSBzdHJpbmcgaXMgZW1wdHkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNaZXJvT3JIYXNOb1ZhbHVlKG51bWVyaWNTdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gISgvWzEtOV0vZykudGVzdChudW1lcmljU3RyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbmVnYXRpdmUgdmVyc2lvbiBvZiB0aGUgdmFsdWUgKHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nKSBnaXZlbiBhcyBhIHBhcmFtZXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRSYXdOZWdhdGl2ZVNpZ24odmFsdWUpIHtcclxuICAgICAgICBpZiAoIWlzTmVnYXRpdmVTdHJpY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgLSR7dmFsdWV9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2UgdGhlIGNoYXJhY3RlciBhdCB0aGUgcG9zaXRpb24gYGluZGV4YCBpbiB0aGUgc3RyaW5nIGBzdHJpbmdgIGJ5IHRoZSBjaGFyYWN0ZXIocykgYG5ld0NoYXJhY3RlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtpbnR9IGluZGV4XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2hhcmFjdGVyXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlQ2hhckF0KHN0cmluZywgaW5kZXgsIG5ld0NoYXJhY3Rlcikge1xyXG4gICAgICAgIHJldHVybiBgJHtzdHJpbmcuc3Vic3RyKDAsIGluZGV4KX0ke25ld0NoYXJhY3Rlcn0ke3N0cmluZy5zdWJzdHIoaW5kZXggKyBuZXdDaGFyYWN0ZXIubGVuZ3RoKX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBjbGFtcGVkIHRvIHRoZSBuZWFyZXN0IG1pbmltdW0vbWF4aW11bSB2YWx1ZSwgYXMgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGFtcFRvUmFuZ2VMaW1pdHModmFsdWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgLy9YWFggVGhpcyBmdW5jdGlvbiBhbHdheXMgYXNzdW1lIGBzZXR0aW5ncy5taW5pbXVtVmFsdWVgIGlzIGxvd2VyIHRoYW4gYHNldHRpbmdzLm1heGltdW1WYWx1ZWBcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBNYXRoLm1pbihzZXR0aW5ncy5tYXhpbXVtVmFsdWUsIHZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBudW1iZXIgb3IgZG90IGNoYXJhY3RlcnMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgY2FyZXQsIGluIGEgZm9ybWF0dGVkIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbiBUaGlzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjaW1hbENoYXJhY3RlclxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGZvcm1hdHRlZE51bWJlclN0cmluZywgY2FyZXRQb3NpdGlvbiwgZGVjaW1hbENoYXJhY3Rlcikge1xyXG4gICAgICAgIC8vIEhlcmUgd2UgY291bnQgdGhlIGRvdCBhbmQgcmVwb3J0IGl0IGFzIGEgbnVtYmVyIGNoYXJhY3RlciB0b28sIHNpbmNlIGl0IHdpbGwgJ3N0YXknIGluIHRoZSBKYXZhc2NyaXB0IG51bWJlciB3aGVuIHVuZm9ybWF0dGVkXHJcbiAgICAgICAgY29uc3QgbnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24gPSBuZXcgUmVnRXhwKGBbMC05JHtkZWNpbWFsQ2hhcmFjdGVyfS1dYCk7IC8vIE5vIG5lZWQgdG8gZXNjYXBlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBoZXJlLCBzaW5jZSBpdCdzIGluIGBbXWBcclxuXHJcbiAgICAgICAgbGV0IG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmV0UG9zaXRpb247IGkrKykge1xyXG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1iZXIsIGEgZG90IG9yIGFuIGh5cGhlbi4gSWYgaXQgaXMsIGNvdW50IGl0LCBvdGhlcndpc2UgaWdub3JlIGl0XHJcbiAgICAgICAgICAgIGlmIChudW1iZXJEb3RPck5lZ2F0aXZlU2lnbi50ZXN0KGZvcm1hdHRlZE51bWJlclN0cmluZ1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdhbGsgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdgIGZyb20gbGVmdCB0byByaWdodCwgb25lIGNoYXIgYnkgb25lLCBjb3VudGluZyB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YC5cclxuICAgICAqIElmIHRoZSBjaGFyIGlzIGluIHRoZSBgcmF3TnVtYmVyU3RyaW5nYCAoc3RhcnRpbmcgYXQgaW5kZXggMCksIHRoZW4gYHJhd051bWJlclN0cmluZ0luZGV4KytgLCBhbmQgY29udGludWUgdW50aWxcclxuICAgICAqIHRoZXJlIGlzIG5vIG1vcmUgY2hhcmFjdGVycyBpbiBgcmF3TnVtYmVyU3RyaW5nYCkgb3IgdGhhdCBgcmF3TnVtYmVyU3RyaW5nSW5kZXggPT09IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlYC5cclxuICAgICAqIFdoZW4geW91IHN0b3AsIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhgIGlzIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgY2FyZXQgc2hvdWxkIGJlIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogMTIzNDU2N3w4OS4wMSAgIDogcG9zaXRpb24gNyAocmF3TnVtYmVyU3RyaW5nKVxyXG4gICAgICogMTIzLjQ1Ni43fDg5LDAxIDogcG9zaXRpb24gOSAoZm9ybWF0dGVkTnVtYmVyU3RyaW5nKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXdOdW1iZXJTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7aW50fSBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZE51bWJlclN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKHJhd051bWJlclN0cmluZywgY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUsIGZvcm1hdHRlZE51bWJlclN0cmluZywgZGVjaW1hbENoYXJhY3Rlcikge1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUgPSBmb3JtYXR0ZWROdW1iZXJTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJhd051bWJlclN0cmluZ1NpemUgPSByYXdOdW1iZXJTdHJpbmcubGVuZ3RoO1xyXG5cclxuICAgICAgICBsZXQgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXg7XHJcbiAgICAgICAgbGV0IHJhd051bWJlclN0cmluZ0luZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4ID0gMDtcclxuICAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4IDwgZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSAmJlxyXG4gICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXggPCByYXdOdW1iZXJTdHJpbmdTaXplICYmXHJcbiAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlO1xyXG4gICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAocmF3TnVtYmVyU3RyaW5nW3Jhd051bWJlclN0cmluZ0luZGV4XSA9PT0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSB8fFxyXG4gICAgICAgICAgICAgICAgKHJhd051bWJlclN0cmluZ1tyYXdOdW1iZXJTdHJpbmdJbmRleF0gPT09ICcuJyAmJiBmb3JtYXR0ZWROdW1iZXJTdHJpbmdbZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhdID09PSBkZWNpbWFsQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ291bnQgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlIG9mIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGluIHRoZSBnaXZlbiB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3VudENoYXJJblRleHQoY2hhcmFjdGVyLCB0ZXh0KSB7XHJcbiAgICAgICAgbGV0IGNoYXJDb3VudGVyID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRleHRbaV0gPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgY2hhckNvdW50ZXIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoYXJDb3VudGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCB0aGUgY2FyZXQgcG9zaXRpb24uXHJcbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBwb3NpdGlvbiBpcyBzdGFydGluZyBhdCAnMCcsIG5vdCAxLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW50fSBjaGFyYWN0ZXJDb3VudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNoYXJhY3RlckNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNoYXJhY3RlckNvdW50LCBjaGFyYWN0ZXJDb3VudCAtIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBnZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8RXZlbnRUYXJnZXR9IHRoYXRcclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGF0KSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcclxuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcclxuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gc2VsZWN0LnRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBzZWxlY3QubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtdGhhdC52YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24ubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gdGhhdC5zZWxlY3Rpb25FbmQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLnN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8RXZlbnRUYXJnZXR9IHRoYXRcclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxyXG4gICAgICogQHBhcmFtIHtpbnR8bnVsbH0gZW5kXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGVuZCkpIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcclxuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoYXQuY3JlYXRlVGV4dFJhbmdlKCk7XHJcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xyXG4gICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xyXG4gICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcclxuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRocm93IGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdGhhdCBkaXNwbGF5IGEgd2FybmluZyBtZXNzYWdlcywgYWNjb3JkaW5nIHRvIHRoZSBkZWJ1ZyBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG93V2FybmluZyBJZiBGQUxTRSwgdGhlbiB0aGUgd2FybmluZyBtZXNzYWdlIGlzIG5vdCBkaXNwbGF5ZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlLCBzaG93V2FybmluZyA9IHRydWUpIHtcclxuICAgICAgICBpZiAoc2hvd1dhcm5pbmcpIHtcclxuICAgICAgICAgICAgLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiAke21lc3NhZ2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGF1dG9OdW1lcmljLXNwZWNpZmljIGZ1bmN0aW9uc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVuIGFueSBjYWxsYmFja3MgZm91bmQgaW4gdGhlIHNldHRpbmdzIG9iamVjdC5cclxuICAgICAqIEFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcclxuICAgICAqIC0gYSBmdW5jdGlvbiwgd2hpY2ggaW52b2tlZCB3aXRoIGpRdWVyeSBlbGVtZW50LCBwYXJhbWV0ZXJzIGFuZCB0aGlzIHBhcmFtZXRlciBuYW1lIGFuZCByZXR1cm5zIHBhcmFtZXRlciB2YWx1ZVxyXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QoJHRoaXMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xyXG4gICAgICAgICQuZWFjaChzZXR0aW5ncywgKGssIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgJHRoaXMuYXV0b051bWVyaWNbdmFsXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEgZXhhbXBsZTogZGF0YS1hLXNpZ249XCJmdW5jdGlvbk5hbWVcIlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB0aGUgbWF4aW11bSBkZWNpbWFsIGxlbmd0aCBmcm9tIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaW5pbXVtVmFsdWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXhpbXVtVmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgobWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVjaW1hbFBsYWNlcyhtaW5pbXVtVmFsdWUpLCBkZWNpbWFsUGxhY2VzKG1heGltdW1WYWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaXAgYWxsIHVud2FudGVkIG5vbi1udW1iZXIgY2hhcmFjdGVycy5cclxuICAgICAqIFRoaXMga2VlcHMgdGhlIG51bWJlcnMsIHRoZSBuZWdhdGl2ZSBzaWduIGFzIHdlbGwgYXMgdGhlIGN1c3RvbSBkZWNpbWFsIGNoYXJhY3Rlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxlZnRPckFsbFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocywgc2V0dGluZ3MsIGxlZnRPckFsbCkge1xyXG4gICAgICAgIC8vVE9ETyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCAxMCB0aW1lcyAoc2ljISkgb24gZWFjaCBrZXkgaW5wdXQsIGNvdWxkbid0IHdlIGxvd2VyIHRoYXQgbnVtYmVyPyBjZi4gaXNzdWUgIzMyNVxyXG4gICAgICAgIC8vVE9ETyBSZWZhY3RvciB0aGlzIHdpdGggYGNvbnZlcnRUb051bWVyaWNTdHJpbmcoKWAgaWYgcG9zc2libGU/XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICE9PSAnJykge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgY3VycmVuY3kgc2lnblxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdWZmaXhcclxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5zKHMsIHNldHRpbmdzLnN1ZmZpeFRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN1ZmZpeFRleHQsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyc3QgcmVwbGFjZSBhbnl0aGluZyBiZWZvcmUgZGlnaXRzXHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XHJcblxyXG4gICAgICAgIGlmICgoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJyB8fFxyXG4gICAgICAgICAgICAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkgJiZcclxuICAgICAgICAgICAgaXNOZWdhdGl2ZShzKSAmJlxyXG4gICAgICAgICAgICBzICE9PSAnJykge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RpbmcgY2hhcmFjdGVyc1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUsIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IG9ubHkgbnVtYmVyIHN0cmluZ1xyXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XHJcbiAgICAgICAgcyA9IG0gPyBbbVsxXSwgbVsyXSwgbVszXV0uam9pbignJykgOiAnJztcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKG1vZGlmaWVkSW50ZWdlclBhcnQsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcclxuICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnRQb3MgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXHJcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzID0gYCR7blNpZ259JHttb2RpZmllZEludGVnZXJQYXJ0fSR7aXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpPycnOnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgKyBkZWNpbWFsUGFydH1gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChsZWZ0T3JBbGwgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09ICdkZW55JykgfHxcclxuICAgICAgICAgICAgKCFzZXR0aW5ncy5oYXNGb2N1cyAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdHJpcFJlZywgJyQxJDInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvciByZW1vdmVzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBmb2N1cyBzdGF0ZS5cclxuICAgICAqIFRoZSBmb2N1cyBzdGF0ZSBpcyAnc3RvcmVkJyBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0IHVuZGVyIHRoZSBgc2V0dGluZ3MuaGFzRm9jdXNgIGF0dHJpYnV0ZS5cclxuICAgICAqIC8vVE9ETyBVc2UgYW5vdGhlciBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBpbnRlcm5hbCBkYXRhIHRoYXQgYXJlIG5vdCBzZXR0aW5nc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQocywgc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykgfHxcclxuICAgICAgICAgICAgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdwJykpIHtcclxuICAgICAgICAgICAgLy9UT0RPIFNwbGl0IHRoZSBmaXJzdCBhbmQgbGFzdCBicmFja2V0IG9ubHkgb25jZSBkdXJpbmcgdGhlIHNldHRpbmdzIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdEJyYWNrZXQsIGxhc3RCcmFja2V0XSA9IHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaGFzRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuaGFzRm9jdXMgJiYgcy5jaGFyQXQoMCkgPT09IGZpcnN0QnJhY2tldCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQsIHNob3VsZG4ndCB3ZSByZXBsYWNlIHRoZSAnLScgc2lnbiBhdCB0aGUgcmlnaHQgcGxhY2U/XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UobGFzdEJyYWNrZXQsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBudW1iZXIgYXMgYSBudW1lcmljIHN0cmluZyB0aGF0IGNhbiBiZSB0eXBlY2FzdCB0byBhIE51bWJlciB0aGF0IEphdmFzY3JpcHQgd2lsbCB1bmRlcnN0YW5kLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJuIHRoZSBnaXZlbiBzdHJpbmcgYnkgc3RyaXBwaW5nIHRoZSBjdXJyZW5jeSBzaWduIChjdXJyZW5jeVN5bWJvbCksIHRoZSBncm91cGluZyBzZXBhcmF0b3JzIChkaWdpdGFsR3JvdXBTcGFjaW5nKSBhbmQgYnkgcmVwbGFjaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAoZGVjaW1hbENoYXJhY3RlcikgYnkgYSBkb3QuXHJcbiAgICAgKiBMYXN0bHksIGl0IGFsc28gcHV0IHRoZSBuZWdhdGl2ZSBzaWduIGJhY2sgdG8gaXRzIG5vcm1hbCBwb3NpdGlvbiBpZiBuZWVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW5jeSBzeW1ib2xcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZ3JvdXBpbmcgc2VwYXJhdG9ycyAodGhvdXNhbmRzIHNlcGFyYXRvcnMgdXN1YWxseSlcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsICcnKTtcclxuXHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYnkgYSBkb3RcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1vdmUgdGhlIHRyYWlsaW5nIG5lZ2F0aXZlIHNpZ24gdG8gdGhlIHJpZ2h0IHBvc2l0aW9uLCBpZiBhbnlcclxuICAgICAgICBpZiAoaXNOZWdhdGl2ZShzKSAmJiBzLmxhc3RJbmRleE9mKCctJykgPT09IHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgICAgICBzID0gJy0nICsgcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYW55IGFyYWJpYyBudW1iZXJzIHRvIGxhdGluIG9uZXNcclxuICAgICAgICBjb25zdCB0ZW1wID0gYXJhYmljVG9MYXRpbk51bWJlcnMocywgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICBpZiAoIWlzTmFOKHRlbXApKSB7XHJcbiAgICAgICAgICAgIHMgPSB0ZW1wLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudC5cclxuICAgICAqIFNlZSB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xyXG4gICAgICAgIGlmIChpc051bGwobG9jYWxlKSB8fCBsb2NhbGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoIChsb2NhbGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnLi0nOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXNOZWdhdGl2ZSh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICAgIGNhc2UgJy0sJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJywtJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXNOZWdhdGl2ZShyZXN1bHQpID8gcmVzdWx0LnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY2FzZVxyXG4gICAgICAgICAgICBjYXNlICcuJzpcclxuICAgICAgICAgICAgY2FzZSAnLS4nOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gb3V0cHV0Rm9ybWF0IFske2xvY2FsZX1dIG9wdGlvbiBpcyBub3QgcmVjb2duaXplZC5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvZiB0aGUgZ2l2ZW4gc3RyaW5nIHZhbHVlIHRvIGFuIGh5cGhlbiAoLSkgYW5kIGEgZG90ICguKSBpbiBvcmRlciB0byBtYWtlIHRoYXQgdmFsdWUgJ3R5cGVjYXN0YWJsZScgdG8gYSByZWFsIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUocywgc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJy0nICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICctJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcy5tYXRjaCgvXFxkLykpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgYGdldGAgaXMgbm90IGZvcm1hdHRlZCB3aXRoIGRlY2ltYWxzXHJcbiAgICAgICAgICAgIHMgKz0gJzAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlciB0byB1c2UgdGhvc2UgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJy0nICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLicsIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxyXG4gICAgICogLy9UT0RPIE1vZGlmeSB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgaXQgcmV0dXJuIGVpdGhlciBUUlVFIG9yIEZBTFNFIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eS4gVGhlbiBjcmVhdGUgYW5vdGhlciBmdW5jdGlvbiB0byByZXR1cm4gdGhlIGlucHV0IHZhbHVlIGlmIGl0J3Mgbm90IGVtcHR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lnbk9uRW1wdHlcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGVja0VtcHR5KGlucHV0VmFsdWUsIHNldHRpbmdzLCBzaWduT25FbXB0eSkge1xyXG4gICAgICAgIGlmIChpbnB1dFZhbHVlID09PSAnJyB8fCBpbnB1dFZhbHVlID09PSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykgPyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBzZXR0aW5ncy5zdWZmaXhUZXh0IDogc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgaW5wdXQgdmFsdWUgYnkgYWRkaW5nIHRoZSBncm91cCBzZXBhcmF0b3JzLCBhcyBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkR3JvdXBTZXBhcmF0b3JzKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETyBUaGlzIGZ1bmN0aW9uIGBhZGRHcm91cFNlcGFyYXRvcnMoKWAgYWRkIGdyb3VwIHNlcGFyYXRvcnMuIEFkZGluZyB0aGUgbmVnYXRpdmUgc2lnbiBhcyB3ZWxsIGlzIG91dCBvZiBpdHMgc2NvcGUuIE1vdmUgdGhhdCB0byBhbm90aGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFpc05lZ2F0aXZlKGlucHV0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnLScgKyBpbnB1dFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZW1wdHkgPSBjaGVja0VtcHR5KGlucHV0VmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBpc1ZhbHVlTmVnYXRpdmUgPSBpc05lZ2F0aXZlKGlucHV0VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGlzWmVybyA9IGlzWmVyb09ySGFzTm9WYWx1ZShpbnB1dFZhbHVlKTtcclxuICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChlbXB0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZyA9IHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcudG9TdHJpbmcoKTtcclxuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwO1xyXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZykge1xyXG4gICAgICAgICAgICBjYXNlICcyJzpcclxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkKShcXGR7Mn0/KSspJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnMnMnOlxyXG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnNCc6XHJcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezN9PykrKSQvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3BsaXRzIHRoZSBzdHJpbmcgYXQgdGhlIGRlY2ltYWwgc3RyaW5nXHJcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICYmIGlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJykge1xyXG4gICAgICAgICAgICAvLyBSZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIHdoaWxlIChkaWdpdGFsR3JvdXAudGVzdChpbnRlZ2VyUGFydCkpIHtcclxuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcn0kMmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSm9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgKyBkZWNpbWFsUGFydDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgaXQncyBhbiBpbnRlZ2VyXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsdWVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVybykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn0ke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVybykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIGFuZCBwbGFjZXMgYnJhY2tldHNcclxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgKHNldHRpbmdzLnJhd1ZhbHVlIDwgMCB8fCBpc05lZ2F0aXZlU3RyaWN0KGlucHV0VmFsdWUpKSkge1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGlucHV0VmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91bmRlZElucHV0VmFsdWVcclxuICAgICAqIEBwYXJhbSB7aW50fSB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfFhNTHxzdHJpbmd8Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhyb3VuZGVkSW5wdXRWYWx1ZSwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgbGV0IHJlZ2V4O1xyXG4gICAgICAgIHN3aXRjaCAodGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIHBhZGRpbmcgLSByZW1vdmVzIHRyYWlsaW5nIHplcm9zIHVudGlsIHRoZSBmaXJzdCBzaWduaWZpY2FudCBkaWdpdCBpcyBlbmNvdW50ZXJlZFxyXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgLy8gQWxsb3dzIHBhZGRpbmcgd2hlbiBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgZXF1YWxzIG9uZSAtIGxlYXZlcyBvbmUgemVybyB0cmFpbGluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC5cXGQoPzpcXGQqWzEtOV0pPykwKiQvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhY2Nlc3MgemVyb3MgdG8gdGhlIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBsZW5ndGggd2hlbiBhbGxvd0RlY2ltYWxQYWRkaW5nIGlzIHNldCB0byB0cnVlXHJcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcLlxcXFxkeyR7dGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcclxuICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UocmVnZXgsICckMScpO1xyXG4gICAgICAgIGlmICh0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPT09IDApIHtcclxuICAgICAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnB1dFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm91bmQgdGhlIGlucHV0IHZhbHVlIHVzaW5nIHRoZSByb3VuZGluZyBtZXRob2QgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcy4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgdGhvc2UuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSA6IFRoaXMgaXMgaGFuZGxlZCBhcyB0ZXh0IHNpbmNlIEphdmFTY3JpcHQgbWF0aCBmdW5jdGlvbiBjYW4gcmV0dXJuIGluYWNjdXJhdGUgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZFZhbHVlKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaW5wdXRWYWx1ZSA9IChpbnB1dFZhbHVlID09PSAnJykgPyAnMCcgOiBpbnB1dFZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0NIRicgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdVMDUnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnRDA1Jykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdOMDUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAoTWF0aC5yb3VuZChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdVMDUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAoTWF0aC5jZWlsKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAoTWF0aC5mbG9vcihpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmICghY29udGFpbnMoaW5wdXRWYWx1ZSwgJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcuMDAnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0VmFsdWUubGVuZ3RoIC0gaW5wdXRWYWx1ZS5pbmRleE9mKCcuJykgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgJzAnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGl2Um91bmRlZCA9ICcnO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgblNpZ24gPSAnJztcclxuICAgICAgICBsZXQgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlO1xyXG5cclxuICAgICAgICAvLyBzZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBpbnB1dFZhbHVlIChpbnB1dCBWYWx1ZSkgaXMgYSBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICAgIGlmIChpc05lZ2F0aXZlU3RyaWN0KGlucHV0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiB0aGF0IHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGEgemVybyBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhIGRpZ2l0ICh0aGVuIGl0IGlzIGxpa2VseSB0byBiZSBhIGRvdClcclxuICAgICAgICBpZiAoIWlucHV0VmFsdWUubWF0Y2goL15cXGQvKSkge1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gJzAnICsgaW5wdXRWYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHplcm8uIElmIGl0IGlzLCByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ25cclxuICAgICAgICBpZiAoTnVtYmVyKGlucHV0VmFsdWUpID09PSAwKSB7XHJcbiAgICAgICAgICAgIG5TaWduID0gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUcmltcyBsZWFkaW5nIHplcm8ncyBhcyBuZWVkZWRcclxuICAgICAgICBpZiAoKE51bWJlcihpbnB1dFZhbHVlKSA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykgfHwgKGlucHV0VmFsdWUubGVuZ3RoID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRQb3MgPSBpbnB1dFZhbHVlLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgICAgICAgY29uc3QgaW5wdXRWYWx1ZUhhc0FEb3QgPSBkUG9zID09PSAtMTtcclxuXHJcbiAgICAgICAgLy8gVmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXHJcbiAgICAgICAgY29uc3QgdmRQb3MgPSBpbnB1dFZhbHVlSGFzQURvdCA/IGlucHV0VmFsdWUubGVuZ3RoIC0gMSA6IGRQb3M7XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxyXG4gICAgICAgIC8vIENoZWNrIGlmIG5vIHJvdW5kaW5nIGlzIHJlcXVpcmVkXHJcbiAgICAgICAgbGV0IGNEZWMgPSAoaW5wdXRWYWx1ZS5sZW5ndGggLSAxKSAtIHZkUG9zO1xyXG5cclxuICAgICAgICBpZiAoY0RlYyA8PSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xyXG4gICAgICAgICAgICBpdlJvdW5kZWQgPSBpbnB1dFZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoY0RlYyA8IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSAtIGNEZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSB6ZXJvcztcclxuICAgICAgICAgICAgICAgICAgICBjRGVjICs9IHplcm9zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID4gdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSb3VuZGVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGFmdGVyIHJvdW5kaW5nXHJcbiAgICAgICAgbGV0IHJMZW5ndGg7XHJcbiAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XHJcbiAgICAgICAgICAgIHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgLSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKyBkUG9zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggKyAxKSk7XHJcbiAgICAgICAgY29uc3Qgb2RkID0gKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggLSAxKSAlIDIpIDogKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGgpICUgMik7XHJcbiAgICAgICAgbGV0IGl2QXJyYXkgPSBpbnB1dFZhbHVlLnN1YnN0cmluZygwLCByTGVuZ3RoICsgMSkuc3BsaXQoJycpO1xyXG5cclxuICAgICAgICBpZiAoKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdTJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIHVwIHN5bW1ldHJpY1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAncycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBkb3duIHN5bW1ldHJpY1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ2EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ2EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0InKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcclxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0InICYmIG9kZCA9PT0gMSkgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXHJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdGJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCB0byBmbG9vciB0b3dhcmQgbmVnYXRpdmUgaW5maW5pdGVcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdVJykpIHsgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCBhd2F5IGZyb20gemVyb1xyXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXHJcbiAgICAgICAgaXZBcnJheSA9IGl2QXJyYXkuc2xpY2UoMCwgckxlbmd0aCArIDEpO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJvdW5kZWQgdmFsdWVcclxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGFzdGVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIGlzUGFzdGUpIHtcclxuICAgICAgICBzID0gKGlzUGFzdGUpID8gcm91bmRWYWx1ZShzLCBzZXR0aW5ncykgOiBzO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAmJiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgZGVjaW1hbCBwYXJ0IHRvIHNhdGlzZnlpbmcgbGVuZ3RoIHNpbmNlIHdlIHdvdWxkIHJvdW5kIGl0IGFueXdheVxyXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gaW50ZWdlclBhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gcGFyc2UgbWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUgJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlLlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiBtaW5pbXVtVmFsdWU6IFwiOTk5OTk5OTk5OTk5OTk5Ljk5XCIgcmV0dXJucyB0aGUgZm9sbG93aW5nIFwie3M6IC0xLCBlOiAxMiwgYzogQXJyYXlbMTVdfVwiLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbiBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7e319XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyKG4pIHtcclxuICAgICAgICBjb25zdCB4ID0ge307IC8vIEEgQmlnIG51bWJlciBpbnN0YW5jZS5cclxuICAgICAgICBsZXQgZTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgbkw7XHJcbiAgICAgICAgbGV0IGo7XHJcblxyXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XHJcbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSAnLTAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24uIDEgcG9zaXRpdmUsIC0xIG5lZ2F0aXZlXHJcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoaXNOZWdhdGl2ZVN0cmljdChuKSkge1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZSgxKTtcclxuICAgICAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5zID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xyXG4gICAgICAgIGlmIChlID4gLTEpIHtcclxuICAgICAgICAgICAgbiA9IG4ucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxlbmd0aCBvZiBzdHJpbmcgaWYgbm8gZGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAgICBpZiAoZSA8IDApIHtcclxuICAgICAgICAgICAgLy8gSW50ZWdlclxyXG4gICAgICAgICAgICBlID0gbi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvc1xyXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcclxuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xyXG4gICAgICAgIGlmIChpID09PSBuTCkge1xyXG4gICAgICAgICAgICAvLyBaZXJvXHJcbiAgICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICAgIHguYyA9IFswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcclxuICAgICAgICAgICAgZm9yIChqID0gbkwgLSAxOyBuLmNoYXJBdChqKSA9PT0gJzAnOyBqIC09IDEpIHtcclxuICAgICAgICAgICAgICAgIG5MIC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbkwgLT0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cclxuICAgICAgICAgICAgeC5lID0gZSAtIGkgLSAxO1xyXG4gICAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3NcclxuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBlICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzLlxyXG4gICAgICogVGhpcyB1c2VzIHRoZSBwYXJzZWQgc3RyaW5ncyBmb3IgdGhlIGFib3ZlIHBhcnNlU3RyIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB5IEJpZyBudW1iZXIgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB4IEJpZyBudW1iZXIgaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0ZXN0TWluTWF4KHksIHgpIHtcclxuICAgICAgICBjb25zdCB4YyA9IHguYztcclxuICAgICAgICBjb25zdCB5YyA9IHkuYztcclxuICAgICAgICBsZXQgaSA9IHgucztcclxuICAgICAgICBsZXQgaiA9IHkucztcclxuICAgICAgICBsZXQgayA9IHguZTtcclxuICAgICAgICBsZXQgbCA9IHkuZTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKCF4Y1swXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gIXljWzBdPzA6LWo7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICAgaWYgKGkgIT09IGopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHhOZWcgPSBpIDwgMDtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcclxuICAgICAgICBpZiAoayAhPT0gbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGsgPiBsIF4geE5lZyk/MTotMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgIGsgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcclxuICAgICAgICBqID0gKGsgPCBsKSA/IGsgOiBsO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XHJcbiAgICAgICAgZm9yIChpICs9IDE7IGkgPCBqOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKHhjW2ldICE9PSB5Y1tpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAoayA9PT0gbCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgbnVtYmVyIHNhdGlzZnkgdGhlIGZvcm1hdCBjb25kaXRpb25zXHJcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXHJcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3MubWluaW11bVZhbHVlIGFuZCBzZXR0aW5ncy5tYXhpbXVtVmFsdWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24ocywgc2V0dGluZ3MpIHtcclxuICAgICAgICBzID0gcy50b1N0cmluZygpO1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xyXG4gICAgICAgIGNvbnN0IG1pblBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3MubWluaW11bVZhbHVlKTtcclxuICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm92ZXJyaWRlTWluTWF4TGltaXRzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdHJ1ZV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGFua3MgdG8gQW50aG9ueSAmIEV2YW4gQ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeXxIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogSWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAoYW5kIHRoZXJlZm9yZSBpcyBhIENTUyBzZWxlY3RvciksIHRoZW4gd2UgbmVlZCB0byBtb2RpZnkgdGhpcyBzdHJpbmcgaW4gb3JkZXJcclxuICAgICAgICAgKiBmb3IgalF1ZXJ5IHRvIGJlIGFibGUgdG8gcGFyc2UgdGhlIHNlbGVjdG9yIGNvcnJlY3RseS5cclxuICAgICAgICAgKiBjZi4gaHR0cDovL2xlYXJuLmpxdWVyeS5jb20vdXNpbmctanF1ZXJ5LWNvcmUvZmFxL2hvdy1kby1pLXNlbGVjdC1hbi1lbGVtZW50LWJ5LWFuLWlkLXRoYXQtaGFzLWNoYXJhY3RlcnMtdXNlZC1pbi1jc3Mtbm90YXRpb24vXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGJsb2NrIGlzIGFwcGFyZW50bHkgbmV2ZXIgZW50ZXJlZC4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBhZnRlciBtYWtpbmcgc3VyZSB0aGF0J3MgMTAwJSB0aGUgY2FzZVxyXG4gICAgICAgICAgICBlbGVtZW50ID0gYCMke2VsZW1lbnQucmVwbGFjZSgvKDp8XFwufFxcW3xdfCx8PSkvZywgJ1xcXFwkMScpfWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gJChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRoYXQgYXR0YWNoIHRoZSBhdXRvTnVtZXJpYyBmaWVsZCBwcm9wZXJ0aWVzIHRvIHRoZSBET00gZWxlbWVudCB2aWEgYW4gQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBdXRvTnVtZXJpY0hvbGRlcigkdGhpcywgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XHJcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCAoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLmdldCgwKSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBob2xkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAmIG5vU2VwYXJhdG9yT25Gb2N1cyBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxyXG4gICAgICogVGhvc2Ugb3JpZ2luYWwgc2V0dGluZ3MgYXJlIHVzZWQgZXhjbHVzaXZlbHkgaW4gdGhlIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudCBoYW5kbGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24ga2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkoc2V0dGluZ3MpIHtcclxuICAgICAgICAvL1RPRE8gUmVuYW1lIHRoZSBvbGQgb3B0aW9uIG5hbWVzIHRvIHRoZSBuZXcgb25lc1xyXG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xyXG4gICAgICAgIHNldHRpbmdzLm9QYWQgICAgID0gc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZztcclxuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyO1xyXG4gICAgICAgIHNldHRpbmdzLm9TZXAgICAgID0gc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcjtcclxuICAgICAgICBzZXR0aW5ncy5vU2lnbiAgICA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xyXG4gICAgICAgIHNldHRpbmdzLm9TdWZmaXggID0gc2V0dGluZ3Muc3VmZml4VGV4dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2AgJiBgbm9TZXBhcmF0b3JPbkZvY3VzYCBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxyXG4gICAgICogVGhpcyBpcyB0YWtlbiBmcm9tIFF1aXJrc21vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcclxuICAgICAgICBjb25zdCBuYW1lRVEgPSBuYW1lICsgJz0nO1xyXG4gICAgICAgIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XHJcbiAgICAgICAgbGV0IGMgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGMgPSBjYVtpXTtcclxuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkLlxyXG4gICAgICogVGhpcyBpcyB0YWtlbiBmcm9tIE1vZGVybml6ci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RvcmFnZVRlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XHJcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcHJvcGVybHkgZm9ybWF0cyB0aGUgc3RyaW5nIHRvIGEgbnVtZXJpYyB3aGVuIGxlYWRpbmdaZXJvIGRvZXMgbm90ICdrZWVwJy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBpcyB0aGUgdmFsdWUgaXMgYWxyZWFkeSBlbXB0eS4gVGhpcyBwcmV2ZW50IGNvbnZlcnRpbmcgdGhhdCB2YWx1ZSB0byAnMCcuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gJzAnIGlmIHRoZSB2YWx1ZSBpcyB6ZXJvXHJcbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgLy8gVHJpbSBsZWFkaW5nIHplcm8ncyAtIGxlYXZlcyBvbmUgemVybyB0byB0aGUgbGVmdCBvZiB0aGUgZGVjaW1hbCBwb2ludFxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oLSk/MCsoPz1cXGQpL2csJyQxJyk7XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gcmVtb3ZlIHRoaXMgZnJvbSB0aGF0IGZ1bmN0aW9uIGFuZCB1c2UgYHRyaW1QYWRkZWRaZXJvc0Zyb21EZWNpbWFsUGxhY2VzKClgIGluc3RlYWQuIEFsc28gY3JlYXRlIGEgbmV3IGB0cmFpbGluZ1plcm9gIG9wdGlvbi5cclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHZhbHVlLCAnLicpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcmltcyB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oXFwuWzAtOV0qPykwKyQvLCAnJDEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdHJpcHMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludFxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMobnVtZXJpY1N0cmluZykge1xyXG4gICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gbnVtZXJpY1N0cmluZy5zcGxpdCgnLicpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZGVjaW1hbFBhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlZ2VyUGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRyaW1tZWREZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnJlcGxhY2UoLzArJC9nLCAnJyk7XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHRyaW1tZWREZWNpbWFsUGFydCA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gaW50ZWdlclBhcnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gYCR7aW50ZWdlclBhcnR9LiR7dHJpbW1lZERlY2ltYWxQYXJ0fWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBvciByZW1vdmVzIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gd2hhdCB0aGUgYnJvd3NlciBpcyBzdXBwb3J0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxFdmVudFRhcmdldH0gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlbGVtZW50LCBzZXR0aW5ncywgYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9IChlbGVtZW50Lm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZChlbGVtZW50Lm5hbWUpKSA/YEFVVE9fJHtkZWNvZGVVUklDb21wb25lbnQoZWxlbWVudC5uYW1lKX1gIDpgQVVUT18ke2VsZW1lbnQuaWR9YDtcclxuICAgICAgICAgICAgbGV0IGRhdGU7XHJcbiAgICAgICAgICAgIGxldCBleHBpcmVzO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0cyBjb29raWUgZm9yIGJyb3dzZXIgdGhhdCBkbyBub3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSBJRSA2ICYgSUUgN1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZVRlc3QoKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JHtzZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PScnIDske2V4cGlyZXN9OyBwYXRoPS9gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvb2tpZShzdG9yZWROYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvbGRlciBvYmplY3QgZm9yIGZpZWxkIHByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgY2xhc3MgQXV0b051bWVyaWNIb2xkZXIge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0aGF0IC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdHJ1Y3Rvcih0aGF0LCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHRoaXMudGhhdCA9IHRoYXQ7XHJcbiAgICAgICAgICAgIHRoaXMuJHRoYXQgPSAkKHRoYXQpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzQ2xvbmUgPSBzZXR0aW5ncztcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoYXQudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgdGhlIHZhbHVlIGFuZCB0aGUgc2VsZWN0aW9uIHZhbHVlcyBpbnNpZGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdC5cclxuICAgICAgICAgKiBUaGlzIGtlZXBzIHRyYWNrcyBvZiB0aGUgaW5wdXQgdmFsdWUsIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAgICAgICAqIFRoaXMgYWxzbyByZXNldHMgdGhlICdwcm9jZXNzZWQnIGFuZCAnZm9ybWF0dGVkJyBzdGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgOiBUaG9zZSB0d28gY2FuIGNoYW5nZSBiZXR3ZWVuIHRoZSBrZXlkb3duLCBrZXlwcmVzcyBhbmQga2V5dXAgZXZlbnRzLCB0aGF0J3Mgd2h5XHJcbiAgICAgICAgICogICAgICAgIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggZXZlbnQgaGFuZGxlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcygpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgdGhlIGtleWNvZGUgb2YgdGhlIGtleSB0aGF0IHRyaWdnZXJlZCB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgICAgICogTm90ZSA6IGUud2hpY2ggaXMgc29tZXRpbWVzIGRpZmZlcmVudCB0aGFuIGUua2V5Q29kZSBkdXJpbmcgdGhlIGtleXByZXNzIGV2ZW50LCB3aGVuIGVudGVyaW5nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBrZXkgKGllLiAndCcpLiBgZS53aGljaGAgZXF1YWxzIDAgZm9yIG5vbi1wcmludGFibGUgY2hhcmFjdGVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vVE9ETyBTd2l0Y2ggdG8gdGhlIG5vbi1kZXByZWNhdGVkIGUua2V5IGF0dHJpYnV0ZSwgaW5zdGVhZCBvZiBpbmNvbnNpc3RhbnQgZS53aGljaCBhbmQgZS5rZXlDb2RlLlxyXG4gICAgICAgICAqIGUua2V5IGRlc2NyaWJlIHRoZSBrZXkgbmFtZSB1c2VkIHRvIHRyaWdnZXIgdGhlIGV2ZW50LlxyXG4gICAgICAgICAqIGUua2V5Q29kZSBiZWluZyBkZXByZWNhdGVkIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZVxyXG4gICAgICAgICAqIEhvdyBlLmtleSB3b3JrcyA6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxyXG4gICAgICAgICAqIFRoZSBrZXkgbGlzdCBpcyBkZXNjcmliZWQgaGVyZVxyXG4gICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleS9LZXlfVmFsdWVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUoZSkge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZSwgaGVuY2Ugd2UgZG8gbm90IHVwZGF0ZSB0aGF0IHZhbHVlIG9uICdrZXlwcmVzcydcclxuICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPSBrZXlDb2RlTnVtYmVyKGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0IHNlbGVjdGlvbiBpbnNpZGUgdGhlIGlucHV0IHdpdGggdGhlIGdpdmVuIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRcclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZW5kXHJcbiAgICAgICAgICogQHBhcmFtIHt1bmRlZmluZWR8Ym9vbGVhbn0gc2V0UmVhbFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3NldFNlbGVjdGlvbihzdGFydCwgZW5kLCBzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuKVxyXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcclxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTsgLy9UT0RPIFJlcGxhY2UgYHRoaXMudGhhdC52YWx1ZS5sZW5ndGhgIHdpdGggYHRoaXMudmFsdWUubGVuZ3RoYFxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzZXRSZWFsKSB8fCBzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgY2FyZXQgcG9zaXRpb24gaW5zaWRlIHRoZSBpbnB1dCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gcG9zXHJcbiAgICAgICAgICogQHBhcmFtIHt1bmRlZmluZWR8Ym9vbGVhbn0gc2V0UmVhbFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3NldENhcmV0UG9zaXRpb24ocG9zLCBzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuKVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBwYXJ0cyBsb2NhdGVkIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb24uXHJcbiAgICAgICAgICogVGhvc2UgcGFydHMgYXJlIGxlZnQgJ3VudG91Y2hlZCcsIGllLiBmb3JtYXR0ZWQgYnkgYXV0b051bWVyaWMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX0gVGhlIHBhcnRzIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc2VsZWN0aW9uLnN0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cclxuICAgICAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgdW5mb3JtYXR0ZWQgKHN0cmlwcGVkKSBvZiBhbnkgbm9uLW51bWJlcnMgY2hhcmFjdGVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb24sIHVuZm9ybWF0dGVkLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiByaWdodCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIGNoYW5naW5nIHRoZSBzaWduIGFuZCBsZWZ0IGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgemVybyAtIHByZXZlbnRzIHN0cmlwcGluZyB0aGUgbGVhZGluZyB6ZXJvc1xyXG4gICAgICAgICAgICBsZXQgc3RyaXBaZXJvcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpcFplcm9zID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVmdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIHN0cmlwWmVyb3MpO1xyXG4gICAgICAgICAgICByaWdodCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgdGhpcy5zZXR0aW5nc0Nsb25lLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFpc05lZ2F0aXZlKGxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0cmlwIHBhcnRzIGZyb20gZXhjZXNzIGNoYXJhY3RlcnMgYW5kIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtbKiwqXX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgY2hhbmdpbmcgdGhlIHNpZ24gYW5kIGxlZnQgaXMgZXF1YWwgdG8gdGhlIG51bWJlciB6ZXJvIC0gcHJldmVudHMgc3RyaXBwaW5nIHRoZSBsZWFkaW5nIHplcm9zXHJcbiAgICAgICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkh5cGhlbiAmJiBOdW1iZXIobGVmdCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWZ0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGxlZnQsIHNldHRpbmdzQ2xvbmUsIHN0cmlwWmVyb3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGRlY2ltYWxDaGFyYWN0ZXJcclxuICAgICAgICAgICAgcmlnaHQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocmlnaHQsIHNldHRpbmdzQ2xvbmUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnRzIG11bHRpcGxlIGxlYWRpbmcgemVyb3MgZnJvbSBiZWluZyBlbnRlcmVkXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmxlYWRpbmdaZXJvID09PSAnZGVueScgJiZcclxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW0wIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bXBhZDApICYmXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIobGVmdCkgPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICFjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpICAmJiByaWdodCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFpc05lZ2F0aXZlKGxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbnNlcnQgemVybyBpZiBoYXMgbGVhZGluZyBkb3RcclxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHRoaXMubmV3VmFsdWUubWF0Y2gobmV3IFJlZ0V4cChgXiR7c2V0dGluZ3NDbG9uZS5hTmVnUmVnQXV0b1N0cmlwfVxcXFwke3NldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcn1gKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgcGFydCBvZiBudW1iZXIgdG8gdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uLiAvL1RPRE8gV2hhdCBhYm91dCB0aGUgY3Vyc29yIHNlbGVjdGlvbj9cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bhc3RlXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgaXNQYXN0ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5fbm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gcGFydHMuam9pbignJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gdHJ1bmNhdGVEZWNpbWFsKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUsIGlzUGFzdGUpO1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIENoZWNrIGlmIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCAnLCcgd2l0aCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0VmFsdWUgPT09ICcnIHx8IHRlc3RWYWx1ZSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gKHNldHRpbmdzQ2xvbmUuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnemVybycpID8gJzAnIDogJyc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHRlc3RWYWx1ZSwgc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uZXdWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMubmV3VmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3aGVuIHRoZSB1c2VyIGVudGVyIGEgJzAnIG9uIHRoZSBmYXIgbGVmdCB3aXRoIGEgbGVhZGluZyB6ZXJvIG9wdGlvbiBzZXQgdG8gJ2RlbnknLCB0aGF0IHRoZSBjYXJldCBkb2VzIG5vdCBtb3ZlcyBzaW5jZSB0aGUgaW5wdXQgaXMgZHJvcHBlZCAoZml4IGlzc3VlICMyODMpXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDEgJiYgcGFydHNbMF0gPT09ICcwJyAmJiBzZXR0aW5nc0Nsb25lLmxlYWRpbmdaZXJvID09PSAnZGVueScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBlbnRlciBgMGAsIHRoZW4gdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgcmlnaHQgc2lkZSBvZiBpdCAoRml4IGlzc3VlICMyOTkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnJyB8fCBwYXJ0c1swXSA9PT0gJzAnICYmIHBhcnRzWzFdICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5uZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24sIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBgX2V4cGFuZFNlbGVjdGlvbk9uU2lnbigpYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBTaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfZ2V0U2lnblBvc2l0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbCA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2w7XHJcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzLnRoYXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc05lZyA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNOZWcgPyBbMSwgY3VycmVuY3lTeW1ib2xMZW4gKyAxXSA6IFswLCBjdXJyZW5jeVN5bWJvbExlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZUxlbiAtIGN1cnJlbmN5U3ltYm9sTGVuLCB2YWx1ZUxlbl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbMTAwMCwgLTFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxyXG4gICAgICAgICAqIFByZXZlbnRzIHBhcnRpYWwgZGVsZXRpb24vY29weWluZy9vdmVyd3JpdGluZyBvZiBhIHNpZ25cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9leHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xyXG4gICAgICAgICAgICAvL1RPRE8gTW9kaWZ5IHNldFJlYWwgdG8gYmUgbW9yZSBleHBsaWNpdCAoYW5kIGEgYm9vbGVhbiBvbmx5KVxyXG4gICAgICAgICAgICAvL1RPRE8gVXNlIGFycmF5IGRlc3RydWN0dXJpbmcgaGVyZSB0byBzZXQgc2lnblBvc2l0aW9uIHRvIG1vcmUgZXhwbGljaXQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25Qb3NpdGlvbiA9IHRoaXMuX2dldFNpZ25Qb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGlvbiBjYXRjaGVzIHNvbWV0aGluZyBleGNlcHQgc2lnbiBhbmQgY2F0Y2hlcyBvbmx5IHNwYWNlIGZyb20gc2lnblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcclxuICAgICAgICAgICAgICAgIGlmICgoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdIHx8IHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMV0pICYmIHRoaXMudmFsdWUuc3Vic3RyaW5nKE1hdGgubWF4KHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5taW4oc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSkubWF0Y2goL15cXHMqJC8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgdG8gZGlnaXRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NoZWNrUGFzdGUoKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRQYXJ0cyA9IHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gc3RyaXAgdGhlIHBhc3RlZCB2YWx1ZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0LnN1YnN0cigwLCBvbGRQYXJ0c1swXS5sZW5ndGgpICsgc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGxlZnQuc3Vic3RyKG9sZFBhcnRzWzBdLmxlbmd0aCksIHRoaXMuc2V0dGluZ3NDbG9uZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NldFZhbHVlUGFydHMobW9kaWZpZWRMZWZ0UGFydCwgcmlnaHQsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZFBhcnRzLmpvaW4oJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ob2xkUGFydHNbMF0ubGVuZ3RoLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3MgcGFzdGluZywgY3Vyc29yIG1vdmluZyBhbmQgc2tpcHBpbmcgb2Ygbm90IGludGVyZXN0aW5nIGtleXMuXHJcbiAgICAgICAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIFRSVUUsIHRoZW4gZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfc2tpcEFsd2F5cyhlKSB7XHJcbiAgICAgICAgICAgIC8vIENhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxyXG4gICAgICAgICAgICBpZiAoKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKGUuc2hpZnRLZXkgJiYgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhpcyB0ZXN0IGluc2lkZSB0aGUgYG9uS2V5dXBgIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2tpcCBhbGwgZnVuY3Rpb24ga2V5cyAoRjEtRjEyKSwgV2luZG93cyBrZXlzLCB0YWIgYW5kIG90aGVyIHNwZWNpYWwga2V5c1xyXG4gICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuRjEgJiYgdGhpcy5ldmVudEtleUNvZGUgPD0ga2V5Q29kZS5GMTIpIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIHRoaXMuZXZlbnRLZXlDb2RlIDw9IGtleUNvZGUuUmlnaHRDbGljaykgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA+PSBrZXlDb2RlLlRhYiAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8IGtleUNvZGUuU3BhY2UpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBgZS53aGljaGAgaXMgc29tZXRpbWVzIGRpZmZlcmVudCB0aGFuIGB0aGlzLmV2ZW50S2V5Q29kZWAgZHVyaW5nIHRoZSBrZXlwcmVzcyBldmVudCB3aGVuIGVudGVyaW5nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBrZXkgKGllLiAndCcpLiBBbHNvLCBgZS53aGljaGAgZXF1YWxzIDAgZm9yIG5vbi1wcmludGFibGUgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA8IGtleUNvZGUuQmFja3NwYWNlICYmXHJcbiAgICAgICAgICAgICAgICAoZS53aGljaCA9PT0gMCB8fCBlLndoaWNoID09PSB0aGlzLmV2ZW50S2V5Q29kZSkpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5OdW1Mb2NrIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkNvbW1hbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhIFwiU2VsZWN0IGFsbFwiIGtleWJvYXJkIHNob3J0Y3V0IGlzIGRldGVjdGVkIChjdHJsICsgYSlcclxuICAgICAgICAgICAgaWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5hKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZWxlY3ROdW1iZXJPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGlzIHVzZWQgaGVyZSB0byBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGZpcnN0IHNlbGVjdCBhbGwgdGhlIGlucHV0IHRleHQgKGluY2x1ZGluZyB0aGUgY3VycmVuY3kgc2lnbiksIG90aGVyd2lzZSB3ZSB3b3VsZCBzZWUgdGhhdCB3aG9sZSBzZWxlY3Rpb24gZmlyc3QgaW4gYSBmbGFzaCwgdGhlbiB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgbnVtYmVyIHBhcnQgd2l0aG91dCB0aGUgY3VycmVuY3kgc2lnbi5cclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVnTGVuID0gKCFpc05lZ2F0aXZlKHRoaXMudGhhdC52YWx1ZSkpPzA6MTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXhUZXh0TGVuID0gdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcgJiYgbmVnTGVuID09PSAxICYmIGN1cnJlbmN5U3ltYm9sTGVuID4gMCk/Y3VycmVuY3lTeW1ib2xMZW4gKyAxOmN1cnJlbmN5U3ltYm9sTGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIHN1ZmZpeFRleHRMZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoc3VmZml4VGV4dExlbiArIGN1cnJlbmN5U3ltYm9sTGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChjdXJyZW5jeVN5bWJvbExlbiA+IDApP3ZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sTGVuICsgbmVnTGVuICsgc3VmZml4VGV4dExlbik6dmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBzdWZmaXhUZXh0TGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sTGVuICsgc3VmZml4VGV4dExlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYSBcIkNvcHlcIiwgXCJQYXN0ZVwiIG9yIFwiQ3V0XCIga2V5Ym9hcmQgc2hvcnRjdXQgaXMgZGV0ZWN0ZWQgKHJlc3BlY3RpdmVseSAnY3RybCArIGMnLCAnY3RybCArIHYnIG9yICdjdHJsICsgeCcpXHJcbiAgICAgICAgICAgIGlmICgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmMgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUudiB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS54KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHByZXZlbnQgd3JvbmcgcGFzdGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS52IHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUgPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBKdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgIC8vVE9ETyBNb3ZlIHRoaXMgdGVzdCBpbnNpZGUgdGhlIGBvbktleWRvd25gIGhhbmRsZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIWUuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnRoYXQudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMikgPT09IHRoaXMuc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAyKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLlJpZ2h0QXJyb3cgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5QYWdlRG93biAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8PSBrZXlDb2RlLkRvd25BcnJvdztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnQgVGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodCBUaGUgcGFydCBvbiB0aGUgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgJiYgc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmxlbmd0aCAtIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpICYmIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgKyBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZShsZWZ0KSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTWVyZ2UgdGhlIHR3byBmb2xsb3dpbmcgJ2lmJyBibG9ja3MgaW50byBvbmUgYGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtgIGFuZCBhIHN3aXRjaCBvbiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB8fCAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIC0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJycgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzIHRoZSBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcblxyXG4gICAgICAgICAgICBsZXQgbGVmdDtcclxuICAgICAgICAgICAgbGV0IHJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiByaWdodCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJyB8fCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc05lZ2F0aXZlKHRoaXMudmFsdWUpKSB7IC8vVE9ETyBDaGFuZ2UgYHRoaXMudmFsdWVgIHRvIGB0aGlzLnRoYXQudmFsdWVgP1xyXG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGRlY2lkZXMgaWYgdGhlIGtleSBwcmVzc2VkIHNob3VsZCBiZSBkcm9wcGVkIG9yIGFjY2VwdGVkLCBhbmQgbW9kaWZ5IHRoZSB2YWx1ZSAnb24tdGhlLWZseScgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICogUmV0dXJucyBUUlVFIGlmIHRoZSBrZXljb2RlIGlzIGFsbG93ZWQuXHJcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbnMgYWxzbyBtb2RpZnkgdGhlIHZhbHVlIG9uLXRoZS1mbHkuIC8vRklYTUUgVGhpcyBzaG91bGQgdXNlIGFub3RoZXIgZnVuY3Rpb24gaW4gb3JkZXIgdG8gc2VwYXJhdGUgdGhlIHRlc3QgYW5kIHRoZSBtb2RpZmljYXRpb25cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR8c3RyaW5nfSBldmVudE9yQ2hhciBUaGUgZXZlbnQgb2JqZWN0LCBvciB0aGUgY2hhcmFjdGVyIGVudGVyZWQgKGZyb20gYW4gYW5kcm9pZCBkZXZpY2UpXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oZXZlbnRPckNoYXIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBldmVudENoYXJhY3RlcjtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV2ZW50T3JDaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQW5kcm9pZCBicm93c2Vyc1xyXG4gICAgICAgICAgICAgICAgZXZlbnRDaGFyYWN0ZXIgPSBldmVudE9yQ2hhcjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBicm93c2Vyc1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVhbCBjaGFyYWN0ZXIgdGhhdCBoYXMgYmVlbiBlbnRlcmVkIChpZS4gJ2EnIGluc3RlYWQgb2YgdGhlIGtleSBjb2RlKVxyXG4gICAgICAgICAgICAgICAgZXZlbnRDaGFyYWN0ZXIgPSBjaGFyYWN0ZXIoZXZlbnRPckNoYXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydCBydWxlcyB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBrZXkgaXMgcHJlc3NlZCBhbHdheXMgdXNlIG51bWVyaWMgcGFkIGRvdCB0byBpbnNlcnQgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXHJcbiAgICAgICAgICAgIGlmIChldmVudENoYXJhY3RlciA9PT0gc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgZXZlbnRDaGFyYWN0ZXIgPT09IHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB8fFxyXG4gICAgICAgICAgICAgICAgKChldmVudENoYXJhY3RlciA9PT0gJy4nIHx8IGV2ZW50Q2hhcmFjdGVyID09PSAnLCcpICYmIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkRvdE51bXBhZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZS5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgfHwgIXNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBiZWZvcmUgbmVnYXRpdmVTaWduQ2hhcmFjdGVyIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIsIHJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxyXG4gICAgICAgICAgICBpZiAoKGV2ZW50Q2hhcmFjdGVyID09PSAnLScgfHwgZXZlbnRDaGFyYWN0ZXIgPT09ICcrJykgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FyZXQgaXMgYWx3YXlzIGFmdGVyIG1pbnVzXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmVTdHJpY3QobGVmdCkgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChldmVudENoYXJhY3RlciA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdCA6IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbnVtYmVyIHNpZ24sIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGV2ZW50Q2hhcmFjdGVyID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0IDogbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHRyaWVzIHRvIGluc2VydCBkaWdpdCBiZWZvcmUgbWludXMgc2lnblxyXG4gICAgICAgICAgICBjb25zdCBldmVudE51bWJlciA9IE51bWJlcihldmVudENoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudE51bWJlciA+PSAwICYmIGV2ZW50TnVtYmVyIDw9IDkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubWF4aW11bVZhbHVlIDw9IDAgJiYgc2V0dGluZ3NDbG9uZS5taW5pbXVtVmFsdWUgPCBzZXR0aW5nc0Nsb25lLm1heGltdW1WYWx1ZSAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIGV2ZW50Q2hhcmFjdGVyICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIGV2ZW50Q2hhcmFjdGVyLCByaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvcm1hdHRpbmcgb2YganVzdCBwcm9jZXNzZWQgdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfZm9ybWF0VmFsdWUoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0TGVuZ3RoID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXHJcbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IpKSkgJiZcclxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpKSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZShzdWJQYXJ0cykpIHtcclxuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcclxuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50TmVnICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduUGFydHMgPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLnNwbGl0KCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZUNociA9IFsnXFxcXCcsICdeJywgJyQnLCAnLicsICd8JywgJz8nLCAnKicsICcrJywgJygnLCAnKScsICdbJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzaWduUGFydHMsIChpLCBtaW5pUGFydHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pUGFydHMgPSBzaWduUGFydHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheShtaW5pUGFydHMsIGVzY2FwZUNocikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJ1xcXFwnICsgbWluaVBhcnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaChtaW5pUGFydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdGhlIGVzY2FwZWQgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goZXNjYXBlZFBhcnRzLmpvaW4oJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRBci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IHZhbHVlLm1hdGNoKGxlZnRSZWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcG9zaXRpdmUgc2lnbiBpcyBzaG93biwgY2FsY3VsYXRlIHRoZSBjYXJldCBwb3NpdGlvbiBhY2NvcmRpbmdseVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnNob3dQb3NpdGl2ZVNpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmIG5ld0xlZnQuaW5wdXQuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAobmV3TGVmdC5pbnB1dC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpID09PSAxKSA/IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgMSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBuZXdMZWZ0LmlucHV0LmNoYXJBdChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkgPT09IHNldHRpbmdzQ2xvbmUucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGp1c3QgYmVmb3JlIHRoZSBzaWduIHdoaWNoIGlzIGluIHByZWZpeCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHx8IChwb3NpdGlvbiA9PT0gMSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgJiYgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFNob3VsZCB0aGUgdGVzdCBiZSAnaXNOZWdhdGl2ZScgaW5zdGVhZCBvZiAnaXNOZWdhdGl2ZVN0cmljdCcgaW4gb3JkZXIgdG8gc2VhcmNoIGZvciAnLScgZXZlcnl3aGVyZSBpbiB0aGUgc3RyaW5nP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAoaXNOZWdhdGl2ZVN0cmljdCh2YWx1ZSkgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4IGN1cnJlbmN5IHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgdmFsdWUgaWYgaXQgaGFzIGNoYW5nZWQuIFRoaXMgcHJldmVudHMgbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24sIGlmIGFueS5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnRoYXQudmFsdWUgfHxcclxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB0aGlzLnRoYXQudmFsdWUgJiYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bTAgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtcGFkMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFuZHJvaWRTZWxlY3Rpb25TdGFydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gQW5kcm9pZCBicm93c2VyIGlzIGRldGVjdGVkLCBmaXggdGhlIGNhcmV0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgZG9lcyBub3QgZml4IGFsbCBhbmRyb2lkIGJyb3dzZXJzLCBvbmx5IEFuZHJvaWQgQ2hyb21lIGN1cnJlbnRseS5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgZHVlIHRvIHRoZSBmYWN0IHRob3NlIHByb3ZpZGUgZGlmZmVyZW50IG9yZGVyIG9mIGV2ZW50cyBhbmQvb3Iga2V5Y29kZXMgdGhyb3duICh0aGlzIGlzIGEgcmVhbCBtZXNzIDp8KS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24oc2V0dGluZ3NDbG9uZS5hbmRyb2lkU2VsZWN0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IHRydWU7IC8vVE9ETyBSZW5hbWUgYHRoaXMuZm9ybWF0dGVkYCB0byBgdGhpcy5fZm9ybWF0RXhlY3V0ZWRgLCBzaW5jZSBpdCdzIHBvc3NpYmxlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbmVlZCB0byBmb3JtYXQgYW55dGhpbmcgKGluIHRoZSBjYXNlIHdoZXJlIHRoZSBrZXljb2RlIGlzIGRyb3BwZWQgZm9yIGluc3RhbmNlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmFjdG9yaXNlIHRoZSBgZ2V0U3RyaW5nKClgIGFuZCBgZ2V0QXJyYXkoKWAgZnVuY3Rpb25zIHNpbmNlIHRoZXkgc2hhcmUgcXVpdGUgYSBsb3Qgb2YgY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxyXG4gICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBtb3JlIGRldGFpbHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XHJcbiAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGF0KTtcclxuICAgICAgICBjb25zdCBmb3JtSW5kZXggPSAkKCdmb3JtJykuaW5kZXgoJHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGFsbEZvcm1FbGVtZW50cyA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KWApWzBdO1xyXG4gICAgICAgIGNvbnN0IGFpSW5kZXggPSBbXTtcclxuXHJcbiAgICAgICAgLy8gYWxsIGlucHV0IGluZGV4XHJcbiAgICAgICAgY29uc3Qgc2NJbmRleCA9IFtdO1xyXG5cclxuICAgICAgICAvLyBzdWNjZXNzZnVsIGNvbnRyb2wgaW5kZXhcclxuICAgICAgICBjb25zdCByU3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2k7XHJcblxyXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcclxuICAgICAgICBjb25zdCByU3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XHJcblxyXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcclxuICAgICAgICBjb25zdCByQ2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xyXG4gICAgICAgIGNvbnN0IHJOb25BdXRvTnVtZXJpY1R5cGVzID0gL14oPzpidXR0b258Y2hlY2tib3h8Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxmaWxlfGltYWdlfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYWRpb3xyYW5nZXxyZXNldHxzZWFyY2h8c3VibWl0fHRpbWV8dXJsfHdlZWspL2k7XHJcblxyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcblxyXG4gICAgICAgIC8vIGluZGV4IG9mIHN1Y2Nlc3NmdWwgZWxlbWVudHNcclxuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgIT09ICcnICYmIHJTdWJtaXR0YWJsZS50ZXN0KGZpZWxkLmxvY2FsTmFtZSkgJiYgIXJTdWJtaXR0ZXJUeXBlcy50ZXN0KGZpZWxkLnR5cGUpICYmICFmaWVsZC5kaXNhYmxlZCAmJiAoZmllbGQuY2hlY2tlZCB8fCAhckNoZWNrYWJsZVR5cGUudGVzdChmaWVsZC50eXBlKSkpIHtcclxuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaChjb3VudCk7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBpbmRleCBvZiBhbGwgaW5wdXRzIHRhZ3MgZXhjZXB0IGNoZWNrYm94XHJcbiAgICAgICAgY291bnQgPSAwO1xyXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIChmaWVsZC50eXBlID09PSAnJyB8fCBmaWVsZC50eXBlID09PSAndGV4dCcgfHwgZmllbGQudHlwZSA9PT0gJ2hpZGRlbicgfHwgZmllbGQudHlwZSA9PT0gJ3RlbCcpKSB7XHJcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goY291bnQpO1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaCgtMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIHJOb25BdXRvTnVtZXJpY1R5cGVzLnRlc3QoZmllbGQudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChnZXRBcnJheUJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemVBcnJheSgpO1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKGZvcm1GaWVsZHMsIChpLCBmaWVsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gc2NJbmRleC5pbmRleE9mKGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtRmllbGRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZ2V0U3RyaW5nKCkgYmVoYXZpb3JcclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtUGFydHMgPSBmb3JtRmllbGRzLnNwbGl0KCcmJyk7XHJcblxyXG4gICAgICAgICAgICAkLmVhY2goZm9ybVBhcnRzLCBpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dE5hbWUsIGlucHV0VmFsdWVdID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSBzY0luZGV4LmluZGV4T2YoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHZhbGlkIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkSW5wdXRWYWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJ0c1tpXSA9IGAke2lucHV0TmFtZX09JHttb2RpZmllZElucHV0VmFsdWV9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybVBhcnRzLmpvaW4oJyYnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNpbicgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSkge1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XHJcblxyXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1c2luJyB8fCBlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiAhJHRoaXMuaXMoJzpmb2N1cycpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjbGVhbiB0aGUgdmFsdWUgdG8gY29tcGFyZSB0byByYXdWYWx1ZVxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnRUb051bWVyaWNTdHJpbmcocmVzdWx0LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3MocmVzdWx0LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnLScgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByb3VuZGVkVmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xyXG4gICAgICAgICAgICAgICAgcm91bmRlZFZhbHVlID0gcm91bmRWYWx1ZShzZXR0aW5ncy5yYXdWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZSwgc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcihzZXR0aW5ncy5vRGVjKTtcclxuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVmFsdWUoc2V0dGluZ3MucmF3VmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIGFkZEdyb3VwU2VwYXJhdG9ycyhyb3VuZGVkVmFsdWUsIHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgcm91bmRlZFZhbHVlID0gcm91bmRWYWx1ZShzZXR0aW5ncy5yYXdWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZSwgc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHNldHRpbmdzLnJhd1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRoZSByYXdWYWx1ZVxyXG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHNlbmQgYSAnbmF0aXZlJyBjaGFuZ2UgZXZlbnQgd2hlbiBibHVycmluZyB0aGUgaW5wdXQsIHdlIG5lZWQgdG8gZmlyc3Qgc3RvcmUgdGhlIGluaXRpYWwgaW5wdXQgdmFsdWUgb24gZm9jdXMuXHJcbiAgICAgICAgICAgIGhvbGRlci52YWx1ZU9uRm9jdXMgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIudmFsdWVPbkZvY3VzO1xyXG4gICAgICAgICAgICBjb25zdCBvbkVtcHR5ID0gY2hlY2tFbXB0eShob2xkZXIudmFsdWVPbkZvY3VzLCBzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICgob25FbXB0eSAhPT0gbnVsbCAmJiBvbkVtcHR5ICE9PSAnJykgJiYgc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnZm9jdXMnKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCBvbkVtcHR5KTtcclxuICAgICAgICAgICAgICAgIGlmIChvbkVtcHR5ID09PSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzLlxyXG4gICAgICogVGhlIHVzZXIganVzdCBzdGFydGVkIHB1c2hpbmcgYW55IGtleSwgaGVuY2Ugb25lIGV2ZW50IGlzIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSA6XHJcbiAgICAgKiBCeSBkZWZhdWx0IGEgJ25vcm1hbCcgaW5wdXQgb3V0cHV0IHRob3NlIGV2ZW50cyBpbiB0aGUgcmlnaHQgb3JkZXIgd2hlbiBpbnB1dHRpbmcgYSBjaGFyYWN0ZXIga2V5IChpZS4gJ2EnKSA6XHJcbiAgICAgKiAtIGtleWRvd25cclxuICAgICAqIC0ga2V5cHJlc3NcclxuICAgICAqIC0gaW5wdXRcclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqXHJcbiAgICAgKiAuLi53aGVuIGlucHV0dGluZyBhIG1vZGlmaWVyIGtleSAoaWUuICdjdHJsJykgOlxyXG4gICAgICogLSBrZXlkb3duXHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKlxyXG4gICAgICogSWYgJ2RlbGV0ZScgb3IgJ2JhY2tzcGFjZScgaXMgZW50ZXJlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxyXG4gICAgICogLSBrZXlkb3duXHJcbiAgICAgKiAtIGlucHV0XHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKlxyXG4gICAgICogSWYgJ2VudGVyJyBpcyBlbnRlcmVkIGFuZCB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XHJcbiAgICAgKiAtIGtleWRvd25cclxuICAgICAqIC0ga2V5cHJlc3NcclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqXHJcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XHJcbiAgICAgKiAtIGtleWRvd25cclxuICAgICAqIC0ga2V5cHJlc3NcclxuICAgICAqIC0gY2hhbmdlXHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBhIHBhc3RlIGlzIGRvbmUsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcclxuICAgICAqIC0gaW5wdXQgKGlmIHBhc3RlIGlzIGRvbmUgd2l0aCB0aGUgbW91c2UpXHJcbiAgICAgKlxyXG4gICAgICogLSBrZXlkb3duIChpZiBwYXN0ZSBpcyBkb25lIHdpdGggY3RybCt2KVxyXG4gICAgICogLSBrZXlkb3duXHJcbiAgICAgKiAtIGlucHV0XHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uS2V5ZG93bihob2xkZXIsIGUpIHtcclxuICAgICAgICAvL1RPRE8gQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZSB0aGUgZWxlbWVudCB2YWx1ZSAoZWl0aGVyIGJ5IHVzaW5nIGBlLnRhcmdldC52YWx1ZWAgd2hlbiB0aGUgZWxlbWVudCBpcyBhbiA8aW5wdXQ+LCBvciBieSB1c2luZyBgZWxlbWVudC50ZXh0Q29udGVudGAgd2hlbiB0aGUgZWxlbWVudCBhcyBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgc2V0IHRvIHRydWUpXHJcbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZShlKTtcclxuICAgICAgICBob2xkZXIuaW5pdGlhbFZhbHVlT25LZXlkb3duID0gZS50YXJnZXQudmFsdWU7IC8vIFRoaXMgaXMgbmVlZGVkIGluIGBvbktleXVwKClgIHRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBhcyBjaGFuZ2VkIGR1cmluZyB0aGUga2V5IHByZXNzXHJcblxyXG4gICAgICAgIGlmIChob2xkZXIudGhhdC5yZWFkT25seSkge1xyXG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBcImVudGVyXCIga2V5IHRocm93cyBhIGBjaGFuZ2VgIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgYGZvY3VzYCBldmVudFxyXG4gICAgICAgIGlmIChob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci52YWx1ZU9uRm9jdXMgIT09IGUudGFyZ2V0LnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY2hhbmdlJywgZS50YXJnZXQpO1xyXG4gICAgICAgICAgICBob2xkZXIudmFsdWVPbkZvY3VzID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcclxuXHJcbiAgICAgICAgaWYgKGhvbGRlci5fc2tpcEFsd2F5cyhlKSkge1xyXG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgaXMgYSBkZWxldGUvYmFja3NwYWNlIGtleVxyXG4gICAgICAgIGlmIChob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkge1xyXG4gICAgICAgICAgICBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpOyAvLyBCZWNhdXNlIGJhY2tzcGFjZSBhbmQgZGVsZXRlIG9ubHkgdHJpZ2dlcnMga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzLCBub3Qga2V5cHJlc3NcclxuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhbmQgb25seSBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGhhcyBjaGFuZ2VkIGFmdGVyIHRoYXQgYmFja3NwYWNlL2RlbGV0ZSwgdGhlbiB3ZSBoYXZlIHRvIHNlbmQgYW4gJ2lucHV0JyBldmVudCBsaWtlIGJyb3dzZXJzIG5vcm1hbGx5IGRvLlxyXG4gICAgICAgICAgICBpZiAoKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYW4gaW5wdXQgZXZlbnQgd2hlbiBhIGNoYXJhY3RlciBkZWxldGlvbiBpcyBkZXRlY3RlZFxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gLi4uYW5kIGltbWVkaWF0ZWx5IHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gZGVsZXRlIGEgc2Vjb25kIGNoYXJhY3RlclxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTsgLy9UT0RPIElzIHRoaXMgbGluZSBuZWVkZWQ/XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5cHJlc3MnIGV2ZW50cy5cclxuICAgICAqIFRoZSB1c2VyIGlzIHN0aWxsIHByZXNzaW5nIHRoZSBrZXksIHdoaWNoIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIChpZS4gJzInKSBjb250aW51b3VzbHkgdW50aWwgaXQgcmVsZWFzZXMgdGhlIGtleS5cclxuICAgICAqIE5vdGU6ICdrZXlwcmVzcycgZXZlbnRzIGFyZSBub3Qgc2VudCBmb3IgZGVsZXRlIGtleXMgbGlrZSBCYWNrc3BhY2UvRGVsZXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbktleXByZXNzKGhvbGRlciwgZSkge1xyXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSByZWFsIGNoYXJhY3RlciB0aGF0IGhhcyBiZWVuIGVudGVyZWQgKGllLiAnYScgaW5zdGVhZCBvZiB0aGUga2V5IGNvZGUpXHJcbiAgICAgICAgY29uc3QgZXZlbnRDaGFyYWN0ZXIgPSBjaGFyYWN0ZXIoZSk7XHJcblxyXG4gICAgICAgIC8vIEZpcmVmb3ggZ2VuZXJhdGUgYSAna2V5cHJlc3MnIGV2ZW50IChlLmtleUNvZGUgPT09IDApIGZvciB0aGUga2V5cyB0aGF0IGRvIG5vdCBwcmludCBhIGNoYXJhY3RlciAoaWUuICdJbnNlcnQnLCAnRGVsZXRlJywgJ0ZuJyBrZXlzLCAnUGFnZVVwJywgJ1BhZ2VEb3duJyBldGMuKS4gJ1NoaWZ0JyBvbiB0aGUgb3RoZXIgaGFuZCBkb2VzIG5vdCBnZW5lcmF0ZSBhIGtleXByZXNzIGV2ZW50LlxyXG4gICAgICAgIGlmIChldmVudENoYXJhY3RlciA9PT0ga2V5TmFtZS5JbnNlcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gaG9sZGVyLnByb2Nlc3NlZDtcclxuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcclxuXHJcbiAgICAgICAgaWYgKGhvbGRlci5fc2tpcEFsd2F5cyhlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCA9IGhvbGRlci5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbihlKTtcclxuICAgICAgICBpZiAoaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XHJcbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGEgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBhZGQgYSBzZWNvbmQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGV2ZW50Q2hhcmFjdGVyID09PSBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciB8fCBldmVudENoYXJhY3RlciA9PT0gaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAoZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IGdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLmVuZCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5zdGFydCA9PT0gZS50YXJnZXQudmFsdWUuaW5kZXhPZihob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLnN0YXJ0ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBwb3NpdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2lucHV0JyBldmVudHMuXHJcbiAgICAgKiBhZGRlZCB0byBzdXBwb3J0IGFuZHJvaWQgZGV2aWNlcyB3aXRoIG1vYmlsZSBjaHJvbWUgYnJvd3NlcnMgYW5kIG90aGVyc1xyXG4gICAgICogSGFzIHRoZSBwb3RlbnRpYWwgdG8gcmVwbGFjZSB0aGUga2V5cHJlc3MgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoaG9sZGVyLCBlKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gRml4IHRoZSBjYXJldCBwb3NpdGlvbiBvbiBrZXl1cCBpbiB0aGUgYF9mb3JtYXRWYWx1ZSgpYCBmdW5jdGlvblxyXG4gICAgICAgIGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5BbmRyb2lkRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAvLyBUaGUga2V5Q29kZSBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCBBbmRyb2lkIENocm9tZSBvbmUgKHdoaWNoIGlzIGFsd2F5cyBlcXVhbCB0byBga2V5Q29kZS5BbmRyb2lkRGVmYXVsdGApXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBob2xkZXIubGFzdFZhbC5sZW5ndGggfHwgdmFsdWUubGVuZ3RoID49IGhvbGRlci5sYXN0VmFsLmxlbmd0aCAtIGhvbGRlci5zZWxlY3Rpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGtleWNvZGUgb2YgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBlbnRlcmVkLCBhbmQgb3ZlcndyaXRlIHRoZSBmYXVsdHkgYGV2ZW50S2V5Q29kZWAgaW5mbyB3aXRoIGl0XHJcbiAgICAgICAgICAgICAgICBob2xkZXIuZXZlbnRLZXlDb2RlID0gdmFsdWUuY2hhckNvZGVBdChob2xkZXIuc2VsZWN0aW9uLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBhY3R1YWwgY2hhcmFjdGVyIGVudGVyZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuZHJvaWRDaGFyRW50ZXJlZCA9IHZhbHVlLmNoYXJBdChob2xkZXIuc2VsZWN0aW9uLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHNob3VsZCBiZSBpbnNlcnRlZCwgYW5kIGlmIHNvLCBkbyBpbnNlcnQgaXQgaW50byB0aGUgY3VycmVudCBlbGVtZW50IHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQgPSBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oYW5kcm9pZENoYXJFbnRlcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dlZCBjaGFyYWN0ZXIgZW50ZXJlZCAobnVtYmVyLCBkZWNpbWFsIG9yIHBsdXMvbWludXMgc2lnbilcclxuICAgICAgICAgICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFZhbHVlKGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBuZXcgY2FyZXQgcG9zaXRpb24uIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBvbiBrZXl1cCwgYF91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZSgpYCBjYXB0dXJlcyB0aGUgb2xkIGNhcmV0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIENoZWNrIGlmIHRoaXMgaXMgYW4gQW5kcm9pZCBidWcgb3IgYW4gYXV0b051bWVyaWMgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IGhvbGRlci5zZWxlY3Rpb24uc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiA9IGUudGFyZ2V0LnZhbHVlLmluZGV4T2YoaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0RlY2ltYWxDaGFyYWN0ZXIgPSBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPT09IC0xO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBjYXJldCB0byB0aGUgcmlnaHQgaWYgdGhlIGBhbmRyb2lkQ2hhckVudGVyZWRgIGlzIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvciBpZiBpdCdzIG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmRyb2lkQ2hhckVudGVyZWQgPT09IGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFoYXNEZWNpbWFsQ2hhcmFjdGVyICYmIGRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiA8IGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IGhvbGRlci5zZWxlY3Rpb24uc3RhcnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgY2FyZXQgcmlnaHQgbm93IGJlZm9yZSB0aGUgJ2tleXVwJyBldmVudCBpbiBvcmRlciB0byBwcmV2ZW50IHRoZSBjYXJldCBmcm9tIGp1bXBpbmcgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW50ZXJlZCBjaGFyYWN0ZXIgaXMgbm90IGFsbG93ZWQgOyBvdmVyd3JpdGUgdGhlIG5ldyBpbnZhbGlkIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIHZhbGlkIG9uZSwgYW5kIHNldCBiYWNrIHRoZSBjYXJldC9zZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9IGhvbGRlci5sYXN0VmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGhvbGRlci5zZWxlY3Rpb24uc3RhcnQsIGhvbGRlci5zZWxlY3Rpb24uZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gaG9sZGVyLnNlbGVjdGlvbi5zdGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vRklYTUUgSG93IGRvZXMgdGhhdCBhZmZlY3RzIHRoZSBub3JtYWwgdHJpZ2dlciBvZiB0aGUgaW5wdXQgZXZlbnQ/XHJcblxyXG4gICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhcmFjdGVyIGRlbGV0ZWRcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBXaGF0IGFib3V0IHRoZSBgRGVsZXRlYCBrZXk/XHJcbiAgICAgICAgICAgICAgICBob2xkZXIuZXZlbnRLZXlDb2RlID0ga2V5Q29kZS5CYWNrc3BhY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5dXAnIGV2ZW50cy5cclxuICAgICAqIFRoZSB1c2VyIGp1c3QgcmVsZWFzZWQgYW55IGtleSwgaGVuY2Ugb25lIGV2ZW50IGlzIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKSB7XHJcbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMoZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNraXAgPSBob2xkZXIuX3NraXBBbHdheXMoZSk7XHJcbiAgICAgICAgZGVsZXRlIGhvbGRlci52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XHJcbiAgICAgICAgY29uc3QgaXNPbkFuZHJvaWQgPSBob2xkZXIuc2V0dGluZ3NDbG9uZS5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgIT09IG51bGw7XHJcbiAgICAgICAgaWYgKHNraXAgJiYgIWlzT25BbmRyb2lkIHx8IGUudGFyZ2V0LnZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcclxuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5UYWIpIHtcclxuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpIHx8XHJcbiAgICAgICAgICAgIChob2xkZXIuc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9PT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKSkge1xyXG4gICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNhdmVzIHRoZSBleHRlbmRlZCBkZWNpbWFsIHRvIHByZXNlcnZlIHRoZSBkYXRhIHdoZW4gbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2VcclxuICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhvbGRlci5mb3JtYXR0ZWQpIHtcclxuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgY2hhbmdlZCBkdXJpbmcgdGhlIGtleSBwcmVzcyBldmVudCBjaGFpbiwgYW4gZXZlbnQgaXMgc2VudCB0byBhbGVydCB0aGF0IGEgZm9ybWF0dGluZyBoYXMgYmVlbiBkb25lIChjZi4gSXNzdWUgIzE4NylcclxuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5pbml0aWFsVmFsdWVPbktleWRvd24pIHtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdhdXRvTnVtZXJpYzpmb3JtYXR0ZWQnLCBlLnRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3Vzb3V0JyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSkge1xyXG4gICAgICAgIGlmICghJHRoaXMuaXMoJzpmb2N1cycpKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKGUudGFyZ2V0LCBzZXR0aW5ncywgJ3NldCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yID0gc2V0dGluZ3Mub1NlcDtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3Mub1NpZ247XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdWZmaXhUZXh0ID0gc2V0dGluZ3Mub1N1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLm9EZWM7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID0gc2V0dGluZ3Mub1BhZDtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyID0gc2V0dGluZ3Mub0JyYWNrZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICctJyArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSkgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgPyBOdW1iZXIoc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSA6IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKCcwJywgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgc2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IG9yaWdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKHNldHRpbmdzLnNjYWxlU3ltYm9sKSA/IGdyb3VwZWRWYWx1ZSArIHNldHRpbmdzLnNjYWxlU3ltYm9sIDogZ3JvdXBlZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgZ3JvdXBlZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gaG9sZGVyLnZhbHVlT25Gb2N1cykge1xyXG4gICAgICAgICAgICAgICAgJHRoaXMuY2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlT25Gb2N1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uUGFzdGUoJHRoaXMsIGhvbGRlciwgZSkge1xyXG4gICAgICAgIC8vVE9ETyBVc2luZyBjdHJsK3ogYWZ0ZXIgYSBwYXN0ZSBzaG91bGQgY2FuY2VsIGl0IC0+IEhvdyB3b3VsZCB0aGF0IGFmZmVjdCBvdGhlciBmcmFtZXdvcmtzL2NvbXBvbmVudCBidWlsdCB3aXRoIHRoYXQgZmVhdHVyZSBpbiBtaW5kIHRob3VnaD9cclxuICAgICAgICAvL0ZJWE1FIFdoZW4gcGFzdGluZyAnMDAwJyBvbiBhIHRob3VzYW5kIGdyb3VwIHNlbGVjdGlvbiwgdGhlIHdob2xlIHNlbGVjdGlvbiBnZXRzIGRlbGV0ZWQsIGFuZCBvbmx5IG9uZSAnMCcgaXMgcGFzdGVkIChjZi4gaXNzdWUgIzMwMilcclxuICAgICAgICAvLyBUaGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGRlZmF1bHQsIHNpbmNlIG90aGVyd2lzZSB0aGUgdXNlciB3b3VsZCBiZSBhYmxlIHRvIHBhc3RlIGludmFsaWQgY2hhcmFjdGVycyBpbnRvIHRoZSBpbnB1dFxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHJhd1Bhc3RlZFRleHQgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xyXG5cclxuICAgICAgICAvLyAwLiBTcGVjaWFsIGNhc2UgaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIGFsbCB0aGUgaW5wdXQgdGV4dCBiZWZvcmUgcGFzdGluZ1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQgfHwgMDtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQgfHwgMDtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TaXplID0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XHJcbiAgICAgICAgbGV0IGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdGlvblNpemUgPT09IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaXNBbGxJbnB1dFRleHRTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAxLiBDaGVjayBpZiB0aGUgcGFzdGUgaGFzIGEgbmVnYXRpdmUgc2lnbiAob25seSBpZiBpdCdzIHRoZSBmaXJzdCBjaGFyYWN0ZXIpLCBhbmQgc3RvcmUgdGhhdCBpbmZvcm1hdGlvbiBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgY29uc3QgaXNQYXN0ZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZVN0cmljdChyYXdQYXN0ZWRUZXh0KTtcclxuICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIC8vIDFhLiBSZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ24gZnJvbSB0aGUgcGFzdGVkIHRleHRcclxuICAgICAgICAgICAgcmF3UGFzdGVkVGV4dCA9IHJhd1Bhc3RlZFRleHQuc2xpY2UoMSwgcmF3UGFzdGVkVGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4gU3RyaXAgYWxsIHRob3VzYW5kIHNlcGFyYXRvcnMsIGJyYWNrZXRzIGFuZCBjdXJyZW5jeSBzaWduLCBhbmQgY29udmVydCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gYSBkb3RcclxuICAgICAgICBjb25zdCB1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0ID0gcHJlcGFyZVBhc3RlZFRleHQocmF3UGFzdGVkVGV4dCwgaG9sZGVyKTtcclxuXHJcbiAgICAgICAgbGV0IHBhc3RlZFRleHQ7XHJcbiAgICAgICAgaWYgKHVudHJhbnNsYXRlZFBhc3RlZFRleHQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgOiBJZiB0aGUgdXNlciB0cmllcyB0byBwYXN0ZSBhIHNpbmdsZSBkZWNpbWFsIGNoYXJhY3RlciAodGhhdCBoYXMgYmVlbiB0cmFuc2xhdGVkIHRvICcuJyBhbHJlYWR5KVxyXG4gICAgICAgICAgICBwYXN0ZWRUZXh0ID0gJy4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlXHJcbiAgICAgICAgICAgIC8vIEFsbG93IHBhc3RpbmcgYXJhYmljIG51bWJlcnNcclxuICAgICAgICAgICAgcGFzdGVkVGV4dCA9IGFyYWJpY1RvTGF0aW5OdW1iZXJzKHVudHJhbnNsYXRlZFBhc3RlZFRleHQsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMy4gVGVzdCBpZiB0aGUgcGFzdGUgaXMgdmFsaWQgKG9ubHkgaGFzIG51bWJlcnMgYW5kIGV2ZW50dWFsbHkgYSBkZWNpbWFsIGNoYXJhY3RlcikuIElmIGl0J3Mgbm90IHZhbGlkLCBzdG9wIGhlcmUuXHJcbiAgICAgICAgaWYgKHBhc3RlZFRleHQgIT09ICcuJyAmJiAoIWlzTnVtYmVyKHBhc3RlZFRleHQpIHx8IHBhc3RlZFRleHQgPT09ICcnKSkge1xyXG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGFzdGVkIHZhbHVlICcke3Jhd1Bhc3RlZFRleHR9JyBpcyBub3QgYSB2YWxpZCBwYXN0ZSBjb250ZW50LmApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA0LiBDYWxjdWxhdGUgdGhlIHBhc3RlIHJlc3VsdFxyXG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZztcclxuICAgICAgICBsZXQgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyO1xyXG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgLy8gYXV0b051bWVyaWMgJ2dldCcgcmV0dXJucyAnMC4wMCcgaWYgdGhlIGlucHV0IGlzIGVtcHR5LCBoZW5jZSB3ZSBuZWVkIHRvIHN0b3JlIHRoZSAncmVhbCcgZW1wdHkgaW5pdGlhbCB2YWx1ZSB3aGVuIG5lZWRlZFxyXG4gICAgICAgICAgICAvL0ZJWE1FIFRoaXMgaGFzIGJlZW4gZml4ZWQgaW4gYSBwcmV2aW91cyBjb21taXQsIGdldCBzaG91bGQgcmV0dXJuICcnIG9uIGFuIGVtcHR5IGlucHV0LiBSZW1vdmUgdGhpcyB1bm5lZWRlZCAnaWYnXHJcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9ICcnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUgPSBpc05lZ2F0aXZlU3RyaWN0KGluaXRpYWxVbmZvcm1hdHRlZE51bWJlcik7XHJcbiAgICAgICAgbGV0IGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmU7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCBjb250ZW50IGlzIG5lZ2F0aXZlLCB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZSB0b29cclxuICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlICYmICFpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9IGAtJHtpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXJ9YDtcclxuICAgICAgICAgICAgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxlZnRQYXJ0Q29udGFpbmVkQURvdCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBsZWZ0UGFydDtcclxuICAgICAgICBsZXQgcmlnaHRQYXJ0O1xyXG4gICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XHJcbiAgICAgICAgICAgIC8qIDRhLiBUcnVuY2F0ZSBwYXN0ZSBiZWhhdmlvcjpcclxuICAgICAgICAgICAgICogSW5zZXJ0IGFzIG1hbnkgbnVtYmVycyBhcyBwb3NzaWJsZSBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBjYXJldCBmcm9tIHRoZSBwYXN0ZWQgdGV4dCBjb250ZW50LCB1bnRpbCB0aGUgaW5wdXQgcmVhY2ggaXRzIHJhbmdlIGxpbWl0LlxyXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBpcyBtb3JlIGNoYXJhY3RlcnMgaW4gdGhlIGNsaXBib2FyZCBvbmNlIGEgbGltaXQgaXMgcmVhY2hlZCwgZHJvcCB0aGUgZXh0cmFuZW91cyBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UgcGFzdGUgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBjbGlwYm9hcmQuXHJcbiAgICAgICAgICAgICAqIFdoaWxlIGRvaW5nIHNvLCB3ZSBjaGVjayBpZiB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMgYWxsb3dlZCwgYW5kIHN0b3AgYXMgc29vbiBhcyB3ZSBlbmNvdW50ZXIgb25lIG9mIHRob3NlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiA0Yi4gUmVwbGFjZSBwYXN0ZSBiZWhhdmlvcjpcclxuICAgICAgICAgICAgICogSWRlbSB0aGFuIHRoZSAndHJ1bmNhdGUnIHBhc3RlIGJlaGF2aW9yLCBleGNlcHQgdGhhdCB3aGVuIGEgcmFuZ2UgbGltaXQgaXMgaGl0LCB3ZSB0cnkgdG8gcmVwbGFjZSB0aGUgc3Vic2VxdWVudCBpbml0aWFsIG51bWJlcnMgd2l0aCB0aGUgcGFzdGVkIG9uZXMsIHVudGlsIHdlIGhpdCB0aGUgcmFuZ2UgbGltaXQgYSBzZWNvbmQgKGFuZCBsYXN0KSB0aW1lLCBvciB3ZSBydW4gb3V0IG9mIG51bWJlcnMgdG8gcGFzdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jYXNlLWRlY2xhcmF0aW9uczogMCAqL1xyXG4gICAgICAgICAgICBjYXNlICd0cnVuY2F0ZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRGb3JtYXR0ZWRQYXJ0ID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKHNlbGVjdGlvbkVuZCwgaW5pdGlhbEZvcm1hdHRlZFZhbHVlLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhLiBJZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBzZWxlY3RlZCBwYXJ0LCBhbmQgcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQgKyByaWdodEZvcm1hdHRlZFBhcnQsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGIuIEVsc2UgaWYgdGhpcyBpcyBvbmx5IG9uZSBjYXJldCAoYW5kIHRoZXJlZm9yZSBubyBzZWxlY3Rpb24pLCB0aGVuIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2V0UmF3TmVnYXRpdmVTaWduKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBwYXN0ZSBpcyBuZWdhdGl2ZSBhbmQgdGhlIGluaXRpYWwgdmFsdWUgaXMgbm90LCB0aGVuIEkgbXVzdCBvZmZzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGJ5IG9uZSBwbGFjZSB0byB0aGUgcmlnaHQgdG8gdGFrZSB0aGUgYWRkaXRpb25hbCBoeXBoZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQgKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGFuZCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCk/XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGVmdFBhcnQgPSByZXN1bHQuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcpO1xyXG4gICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmVzdWx0LnNsaWNlKGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCByZXN1bHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXN0ZWRUZXh0ID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdFBhcnQsICcuJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgSSByZW1vdmUgYSBkb3QgaGVyZSwgdGhlbiBJIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvbiAoZGVjcmVtZW50IGl0IGJ5IDEpIHdoZW4gcG9zaXRpb25pbmcgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gZG8gc28sIHdlIGtlZXAgdGhhdCBpbmZvIGluIG9yZGVyIHRvIG1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnRDb250YWluZWRBRG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnQgPSBsZWZ0UGFydC5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByaWdodFBhcnQucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tIEhlcmUsIHdlIGFyZSBnb29kIHRvIGdvIHRvIGNvbnRpbnVlIG9uIHRoZSBzYW1lIGJhc2lzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYy4gQWRkIG51bWJlcnMgb25lIGJ5IG9uZSBhdCB0aGUgY2FyZXQgcG9zaXRpb24sIHdoaWxlIHRlc3RpbmcgaWYgdGhlIHJlc3VsdCBpcyB2YWxpZCBhbmQgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gICAgQ29udGludWUgdW50aWwgeW91IGVpdGhlciBydW4gb3V0IG9mIG51bWJlcnMgdG8gcGFzdGUsIG9yIHRoYXQgeW91IGdldCBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihob2xkZXIuc2V0dGluZ3MubWluaW11bVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoaG9sZGVyLnNldHRpbmdzLm1heGltdW1WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDsgLy8gVGhpcyBpcyBzZXQgYXMgdGhlIGRlZmF1bHQsIGluIGNhc2Ugd2UgZG8gbm90IGFkZCBldmVuIG9uZSBudW1iZXJcclxuICAgICAgICAgICAgICAgIGxldCBwYXN0ZWRUZXh0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0UGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFzdGVkVGV4dEluZGV4IDwgcGFzdGVkVGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHJlc3VsdCB3aXRoIGFub3RoZXIgcGFzdGVkIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVmdFBhcnQgKz0gcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1vZGlmaWVkTGVmdFBhcnQgKyByaWdodFBhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByYW5nZSBsaW1pdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSWZJblJhbmdlKHJlc3VsdCwgbWluUGFyc2UsIG1heFBhcnNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLCBzdG9wIHRoZSBsb29wIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGdvb2Qga25vd24gcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGxvb3BcclxuICAgICAgICAgICAgICAgICAgICBwYXN0ZWRUZXh0SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxyXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgKz0gcGFzdGVkVGV4dEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWFhYIEhlcmUgd2UgaGF2ZSB0aGUgcmVzdWx0IGZvciB0aGUgYHRydW5jYXRlYCBvcHRpb25cclxuICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICd0cnVuY2F0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gSWYgdGhlIHVzZXIgYXMgZGVmaW5lZCBhIHRydW5jYXRlIGNhbGxiYWNrIGFuZCB0aGVyZSBhcmUgc3RpbGwgc29tZSBudW1iZXJzICh0aGF0IHdpbGwgYmUgZHJvcHBlZCksIHRoZW4gY2FsbCB0aGlzIGNhbGxiYWNrIHdpdGggdGhlIGluaXRpYWwgcGFzdGUgYXMgd2VsbCBhcyB0aGUgcmVtYWluaW5nIG51bWJlcnNcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXN0R29vZEtub3duUmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFBhcnRDb250YWluZWRBRG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vWFhYIC4uLmVsc2Ugd2UgbmVlZCB0byBjb250aW51ZSBtb2RpZnlpbmcgdGhlIHJlc3VsdCBmb3IgdGhlICdyZXBsYWNlJyBvcHRpb25cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkLiBVbnRpbCB0aGVyZSBhcmUgbnVtYmVycyB0byBwYXN0ZSwgcmVwbGFjZSB0aGUgaW5pdGlhbCBudW1iZXJzIG9uZSBieSBvbmUsIGFuZCBzdGlsbCBkbyB0aGUgcmFuZ2UgdGVzdC5cclxuICAgICAgICAgICAgICAgIC8vICAgIFN0b3Agd2hlbiB5b3UgaGF2ZSBubyBtb3JlIG51bWJlcnMgdG8gcGFzdGUsIG9yIGlmIHlvdSBhcmUgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMuXHJcbiAgICAgICAgICAgICAgICAvLyAgICBJZiB5b3UgZG8gZ2V0IHRvIHRoZSByYW5nZSBsaW1pdHMsIHVzZSB0aGUgcHJldmlvdXMga25vd24gZ29vZCB2YWx1ZSB3aXRoaW4gdGhvc2UgbGltaXRzLlxyXG4gICAgICAgICAgICAgICAgLy8gICAgTm90ZTogVGhlIG51bWJlcnMgYXJlIHJlcGxhY2VkIG9uZSBieSBvbmUsIGluIHRoZSBpbnRlZ2VyIHRoZW4gZGVjaW1hbCBwYXJ0LCB3aGlsZSBpZ25vcmluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBXaGF0IHNob3VsZCBoYXBwZW4gaWYgdGhlIHVzZXIgdHJ5IHRvIHBhc3RlIGEgZGVjaW1hbCBudW1iZXI/IFNob3VsZCB3ZSBvdmVycmlkZSB0aGUgY3VycmVudCBpbml0aWFsIGRlY2ltYWwgY2hhcmFjdGVyIGluIGZhdm9yIG9mIHRoaXMgbmV3IG9uZT8gSWYgd2UgZG8sIHRoZW4gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGUgdk1pbi92TWF4IGZyb20gdGhlIHN0YXJ0IGluIG9yZGVyIHRvIHRha2UgaW50byBhY2NvdW50IHRoaXMgbmV3IGRlY2ltYWwgY2hhcmFjdGVyIHBvc2l0aW9uLi5cclxuICAgICAgICAgICAgICAgIGxldCBsYXN0R29vZEtub3duUmVzdWx0SW5kZXggPSBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RHb29kS25vd25SZXN1bHRTaXplID0gbGFzdEdvb2RLbm93blJlc3VsdC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhc3RlZFRleHRJbmRleCA8IHBhc3RlZFRleHQubGVuZ3RoICYmIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCA8IGxhc3RHb29kS25vd25SZXN1bHRTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RHb29kS25vd25SZXN1bHRbbGFzdEdvb2RLbm93blJlc3VsdEluZGV4XSA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNraXAgdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdyZXBsYWNlbWVudCcuIFRoYXQgd2F5LCB3ZSBkbyBub3QgY2hhbmdlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbiByZWdhcmRpbmcgdGhlIHJlbWFpbmluZyBudW1iZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcGxhY2Ugb25lIGNoYXJhY3RlciBhdCBhIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlQ2hhckF0KGxhc3RHb29kS25vd25SZXN1bHQsIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCwgcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlIGxpbWl0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkluUmFuZ2UocmVzdWx0LCBtaW5QYXJzZSwgbWF4UGFyc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMsIHN0b3AgdGhlIGxvb3AgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZ29vZCBrbm93biByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZFRleHRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBjYXJldCBwb3NpdGlvbiB3aGVyZSB0byBpbnNlcnQgYSBuZXcgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGxhc3RHb29kS25vd25SZXN1bHRJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdFBhcnRDb250YWluZWRBRG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXN0R29vZEtub3duUmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvKiA0Yy4gTm9ybWFsIHBhc3RlIGJlaGF2aW9yOlxyXG4gICAgICAgICAgICAgKiBJbnNlcnQgdGhlIHBhc3RlZCBudW1iZXIgaW5zaWRlIHRoZSBjdXJyZW50IHVuZm9ybWF0dGVkIHRleHQsIGF0IHRoZSByaWdodCBjYXJldCBwb3NpdGlvbiBvciBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcclxuICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gR2VuZXJhdGUgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEZvcm1hdHRlZFBhcnQyID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Rm9ybWF0dGVkUGFydDIgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChsZWZ0Rm9ybWF0dGVkUGFydDIgKyByaWdodEZvcm1hdHRlZFBhcnQyLCBob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiLiBFbHNlIGlmIHRoaXMgaXMgb25seSBvbmUgY2FyZXQgKGFuZCB0aGVyZWZvcmUgbm8gc2VsZWN0aW9uKSwgdGhlbiByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChpbml0aWFsRm9ybWF0dGVkVmFsdWUsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSB1bmZvcm1hdHRlZCByZXN1bHQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgcGFzdGUgaXMgbmVnYXRpdmUgYW5kIHRoZSBpbml0aWFsIHZhbHVlIGlzIG5vdCwgdGhlbiBJIG11c3Qgb2Zmc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBieSBvbmUgcGxhY2UgdG8gdGhlIHJpZ2h0IHRvIHRha2UgdGhlIGFkZGl0aW9uYWwgaHlwaGVuIGludG8gYWNjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKys7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJlc3VsdC5zbGljZShjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgcmVzdWx0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFzdGVkVGV4dCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgb25seSBwYXN0ZSBhIHNpbmdsZSBkZWNpbWFsIGNoYXJhY3RlciwgdGhlbiB3ZSByZW1vdmUgdGhlIHByZXZpb3VzbHkgZXhpc3Rpbmcgb25lIChpZiBhbnkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnRQYXJ0LCAnLicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIEkgcmVtb3ZlIGEgZG90IGhlcmUsIHRoZW4gSSBuZWVkIHRvIHVwZGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gKGRlY3JlbWVudCBpdCBieSAxKSB3aGVuIHBvc2l0aW9uaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGRvIHNvLCB3ZSBrZWVwIHRoYXQgaW5mbyBpbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0Q29udGFpbmVkQURvdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gbGVmdFBhcnQucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmlnaHRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAtLSBIZXJlLCB3ZSBhcmUgZ29vZCB0byBnbyB0byBjb250aW51ZSBvbiB0aGUgc2FtZSBiYXNpc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSB1bmZvcm1hdHRlZCByZXN1bHRcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGAke2xlZnRQYXJ0fSR7cGFzdGVkVGV4dH0ke3JpZ2h0UGFydH1gO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDIuIENhbGN1bGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gaW4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlLCBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgdGhlbiB0aGUgY2FyZXQgcG9zaXRpb24gaXMgc2V0IGFmdGVyIHRoZSBwYXN0ZWQgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQgKyBwYXN0ZWRUZXh0Lmxlbmd0aDsgLy8gSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbGxJbnB1dFRleHRTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBhbGwgdGhlIGlucHV0IHRleHQgaXMgc2VsZWN0ZWQgYmVmb3JlIHBhc3RpbmcsIHdoaWNoIG1lYW5zIHdlJ2xsIGNvbXBsZXRlbHkgZXJhc2UgaXRzIGNvbnRlbnQgYW5kIHBhc3RlIG9ubHkgdGhlIGNsaXBib2FyZCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gcmVzdWx0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0UGFydCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgc2VsZWN0ZWQgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQgKG9uIHRoZSBmYXIgcmlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpICsgcGFzdGVkVGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvbkVuZCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKSwgb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgaW4gdGhlIGluaXRpYWwgc2VsZWN0ZWQgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBlLnRhcmdldC52YWx1ZS5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUgLSBzZWxlY3Rpb25TaXplICsgY291bnRDaGFySW5UZXh0KGhvbGRlci5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBzZWxlY3RlZFRleHQpICsgcGFzdGVkVGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gZm9yIHNwZWNpYWwgY2FzZXMsIG9ubHkgaWYgdGhlIHdob2xlIGlucHV0IGhhcyBub3QgYmVlbiBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbElucHV0VGV4dFNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCB2YWx1ZSBoYXMgYSAnLScgc2lnbiwgYnV0IHRoZSBpbml0aWFsIHZhbHVlIGRvZXMgbm90LCBvZmZzZXQgdGhlIGluZGV4IGJ5IG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRvdCBoYXMgYmVlbiByZW1vdmVkIGZvciB0aGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQsIHdlIGRlY3JlbWVudCB0aGUgY2FyZXQgaW5kZXggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA1LiBDaGVjayBpZiB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgbnVtYmVyLCBpZiBub3QsIGRyb3AgdGhlIHBhc3RlIGFuZCBkbyBub3RoaW5nLlxyXG4gICAgICAgIGlmICghaXNOdW1iZXIocmVzdWx0KSB8fCByZXN1bHQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHdvdWxkIHJlc3VsdCBpbnRvIGFuIGludmFsaWQgY29udGVudCAnJHtyZXN1bHR9Jy5gKTsgLy9UT0RPIFNob3VsZCB3ZSBzZW5kIGEgd2FybmluZyBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yP1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgaXMgbm90IERSWSA7IHJlZmFjdG9yIHdpdGggYWJvdmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA2LiBJZiBpdCdzIGEgdmFsaWQgbnVtYmVyLCBjaGVjayBpZiBpdCBmYWxscyBpbnNpZGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuIElmIHRoaXMgZmFpbHMsIG1vZGlmeSB0aGUgdmFsdWUgZm9sbG93aW5nIHRoaXMgcHJvY2VkdXJlIDpcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIElmICdlcnJvcicgKHRoaXMgaXMgdGhlIGRlZmF1bHQpIDpcclxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxyXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCB0aGVuIHRocm93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlLlxyXG4gICAgICAgICAqICAgICAgLSBEbyBub3QgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgZG8gbm90IGNoYW5nZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICAgICAgICogSWYgJ2lnbm9yZScgOlxyXG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXHJcbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgaWYgaXQgZmFpbHMsIGRvIG5vdGhpbmcgbW9yZS5cclxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAgICAgICAqIElmICdjbGFtcCcgOlxyXG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXHJcbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgaWYgaXQgZmFpbHMsIHNldCB0aGUgdmFsdWUgdG8gdGhlIG1pbmltdW0gb3IgbWF4aW11bSBsaW1pdCwgd2hpY2hldmVyIGlzIGNsb3Nlc3QgdG8gdGhlXHJcbiAgICAgICAgICogICAgICAgIHBhc3RlIHJlc3VsdC5cclxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIG9uIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICogSWYgJ3RydW5jYXRlJyA6XHJcbiAgICAgICAgICogICAgICAtIFRydW5jYXRlIHBhc3RlIGJlaGF2aW9yLlxyXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIHVudGlsIGl0IGZhaWxzIChpZiB0aGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWUgbGltaXRzKS5cclxuICAgICAgICAgKiAgICAgIC0gRHJvcCB0aGUgcmVtYWluaW5nIG5vbi1wYXN0ZWQgbnVtYmVycywgYW5kIGtlZXAgdGhlIGxhc3Qga25vd24gbm9uLWZhaWxpbmcgcmVzdWx0LlxyXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGxhc3QgcGFzdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgKiBJZiAncmVwbGFjZScgOlxyXG4gICAgICAgICAqICAgICAgLSBSZXBsYWNlIHBhc3RlIGJlaGF2aW9yLlxyXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIHVudGlsIGl0IGZhaWxzIChpZiB0aGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWUgbGltaXRzKS5cclxuICAgICAgICAgKiAgICAgLSBUaGVuIHRyeSB0byByZXBsYWNlIGFzIG1hbnkgbnVtYmVycyBhcyBwb3NzaWJsZSB3aXRoIHRoZSBwYXN0ZWQgb25lcy4gT25jZSBpdCBmYWlscywga2VlcCB0aGUgbGFzdCBrbm93biBub24tZmFpbGluZyByZXN1bHQuXHJcbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBhZnRlciB0aGUgbGFzdCBwYXN0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCB2YWx1ZUhhc0JlZW5TZXQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbGV0IGNsYW1wZWRWYWx1ZTtcclxuICAgICAgICAgICAgc3dpdGNoIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYW1wJzpcclxuICAgICAgICAgICAgICAgICAgICBjbGFtcGVkVmFsdWUgPSBjbGFtcFRvUmFuZ2VMaW1pdHMocmVzdWx0LCBob2xkZXIuc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBjbGFtcGVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgRmF0YWwgZXJyb3I6IFVuYWJsZSB0byBzZXQgdGhlIGNsYW1wZWQgdmFsdWUgJyR7Y2xhbXBlZFZhbHVlfScuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0JlZW5DbGFtcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNsYW1wZWRWYWx1ZTsgLy8gVGhpcyBpcyB1c2VkIG9ubHkgZm9yIHNldHRpbmcgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0cnVuY2F0ZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgcmVzdWx0cyBpbiBhIHZhbHVlICcke3Jlc3VsdH0nIHRoYXQgaXMgb3V0c2lkZSBvZiB0aGUgbWluaW11bSBbJHtob2xkZXIuc2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW0gWyR7aG9sZGVyLnNldHRpbmdzLm1heGltdW1WYWx1ZX1dIHZhbHVlIHJhbmdlLmApO1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gLi4uYW5kIG5vdGhpbmcgZWxzZSBzaG91bGQgYmUgY2hhbmdlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA3LiBUaGVuIGxhc3RseSwgc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBhdCB0aGUgcmlnaHQgbG9naWNhbCBwbGFjZVxyXG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXI7XHJcbiAgICAgICAgaWYgKHZhbHVlSGFzQmVlblNldCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUhhc0JlZW5DbGFtcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoIC0gaG9sZGVyLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7IC8vIFRoaXMgcHV0cyB0aGUgY2FyZXQgb24gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCk7IC8vIC4uYW5kIHRoaXMgb24gdGhlIGZhciByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgaWYgdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjbGFtcGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB1c2VkLi4uXHJcbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbXVsdGlwbGUgY2hhcmFjdGVycyBhcmUgcGFzdGVkLCB0aGlzIG1lYW5zIHdlIGhhdmUgdG8gbWFuYWdlIHRoZSBwb3RlbnRpYWwgdGhvdXNhbmQgc2VwYXJhdG9ycyB0aGF0IGNvdWxkIGJlIGFkZGVkIGJ5IHRoZSBmb3JtYXR0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyID0gZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcihyZXN1bHQsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCBlLnRhcmdldC52YWx1ZSwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDguIFdlIG1ha2Ugc3VyZSB3ZSBzZW5kIGFuIGlucHV0IGV2ZW50IG9ubHkgaWYgdGhlIHJlc3VsdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgaW5pdGlhbCB2YWx1ZSBiZWZvcmUgdGhlIHBhc3RlXHJcbiAgICAgICAgaWYgKHZhbHVlSGFzQmVlblNldCAmJiBpbml0aWFsRm9ybWF0dGVkVmFsdWUgIT09IGUudGFyZ2V0LnZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIE9uIGEgJ25vcm1hbCcgbm9uLWF1dG9OdW1lcmljIGlucHV0LCBhbiBgaW5wdXRgIGV2ZW50IGlzIHNlbnQgd2hlbiBhIHBhc3RlIGlzIGRvbmUuIFdlIG1pbWljIHRoYXQuXHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBmb2N1c2luZyBvdXQgb2YgdGhlIGlucHV0LCB3ZSBjaGVjayBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsIHRoZW4gd2Ugc2VuZCBhIGBjaGFuZ2VgIGV2ZW50IChzaW5jZSB0aGUgbmF0aXZlIG9uZSB3b3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGBlLnByZXZlbnREZWZhdWx0KClgIGNhbGxlZCBpbiB0aGUgb3RoZXIgZXZlbnQgbGlzdGVuZXJzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25CbHVyKGhvbGRlciwgZSkge1xyXG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLnZhbHVlT25Gb2N1cykge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2NoYW5nZScsIGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBzZW5kIGEgc2Vjb25kIGNoYW5nZSBldmVudCAodGhhdCBzb21laG93IGdldHMgcGlja2VkIHVwIGJ5IGpRdWVyeSwgYnV0IG5vdCBieSBgYWRkRXZlbnRMaXN0ZW5lcigpYCAvL0ZJWE1FIEtOT1dOIEJVRyA6IFRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgc2Vjb25kIGNoYW5nZSBldmVudCB0byBiZSBwaWNrZWQgdXAgYnkgalF1ZXJ5LCB3aGljaCBhZGRzICcuMDAnIGF0IHRoZSBlbmQgb2YgYW4gaW50ZWdlclxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdzdWJtaXQnIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKSB7XHJcbiAgICAgICAgJHRoaXMuY2xvc2VzdCgnZm9ybScpLm9uKCdzdWJtaXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudW5mb3JtYXRPblN1Ym1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgalF1ZXJ5IHNlbGVjdGVkIGlucHV0IGlmIHRoZSB0YWcgYW5kIHR5cGUgYXJlIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpYy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgkdGhpcykge1xyXG4gICAgICAgIC8vIFN1cHBvcnRlZCBpbnB1dCB0eXBlXHJcbiAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xyXG5cclxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgaW5wdXQgdHlwZXNcclxuICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgaW5wdXQgdHlwZSBcIiR7JHRoaXMucHJvcCgndHlwZScpfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCB0YWdzXHJcbiAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRUYWcgPSAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnRUYWcgIT09ICdpbnB1dCcgJiYgIWlzSW5BcnJheShjdXJyZW50RWxlbWVudFRhZywgYWxsb3dlZFRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSA8JHtjdXJyZW50RWxlbWVudFRhZ30+IHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gJGlucHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIGxvYWQuXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBvbmx5IGlmIHRoZSBgZm9ybWF0T25QYWdlTG9hZGAgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJGlucHV0IGpRdWVyeS1zZWxlY3RlZCA8aW5wdXQ+IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcykge1xyXG4gICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmICgkaW5wdXQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0galF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcyk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcclxuICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcclxuICAgICAgICAgICAgICogZGV2ZWxvcGVyIHdhbnRzIGl0IGZvcm1hdHRlZCBvbiBpbml0IChjZi4gYHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWRgKSkuXHJcbiAgICAgICAgICAgICAqIE5vdGU7IHRoaXMgaXMgdHJ1ZSB3aGF0ZXZlciB0aGUgZGV2ZWxvcGVyIGhhcyBzZXQgZm9yIGBkYXRhLWFuLWRlZmF1bHRgIGluIHRoZSBodG1sIChhc3AubmV0IHVzZXJzKS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMgOiBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byBwcmV2ZW50IHBvc3RiYWNrIHByb2JsZW1zLlxyXG4gICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xyXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cclxuICAgICAgICAgICAgICogSGVuY2UsIGlmIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgaXMgbm90IG51bGwsIGJ1dCBgaW5wdXQudmFsdWVgIGlzIGEgbnVtYmVyIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCxcclxuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGlnbm9yZSBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGFsdG9nZXRoZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCB1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSA9IHRvTnVtZXJpY1ZhbHVlKGN1cnJlbnRWYWx1ZSwgc2V0dGluZ3MpOyAvLyBUaGlzIGFsbG93cyB0byB1c2UgYSBsb2NhbGl6ZWQgdmFsdWUgb24gc3RhcnR1cCBvRGVjXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KCR0aGlzLmF0dHIoJ3ZhbHVlJykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpICYmIEluZmluaXR5ICE9PSB1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90LCBpbmZvcm0gdGhlIGRldmVsb3BlciB0aGF0IG5vdGhpbmcgdXNhYmxlIGhhcyBiZWVuIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2N1cnJlbnRWYWx1ZX1dIHVzZWQgaW4gdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIHZhbHVlIGF1dG9OdW1lcmljIGNhbiB3b3JrIHdpdGguYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBDaGVja3MgZm9yIDpcclxuICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXHJcbiAgICAgICAgICAgICAgICAgKiAtIEFTUC5uZXQgZm9ybSBwb3N0IGJhY2tcclxuICAgICAgICAgICAgICAgICAqICAgICAgVGhlIGZvbGxvd2luZyBIVE1MIGRhdGEgYXR0cmlidXRlIGlzIFJFUVVJUkVEIChkYXRhLWFuLWRlZmF1bHQ9XCJzYW1lIHZhbHVlIGFzIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcIilcclxuICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZS50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgIWlzTnVtYmVyKHVuTG9jYWxpemVkQ3VycmVudFZhbHVlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnZ2V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB2YWx1ZSBzaG91bGQgTk9UIGJlIHNhdmVkIGluIHNlc3Npb25TdG9yYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnICYmIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZWdhdGl2ZShjdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0b1N0cmlwLCBzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0b1N0cmlwLCBzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd6ZXJvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICcwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0VmFsdWUgJiYgY3VycmVudFZhbHVlID09PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMudGV4dCgpICE9PSAnJykge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gJHRoaXMudGV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuaGFuY2UgdGhlIHVzZXIgZXhwZXJpZW5jZSBieSBtb2RpZnlpbmcgdGhlIGRlZmF1bHQgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gZGVwZW5kaW5nIG9uIGBjdXJyZW5jeVN5bWJvbGAgYW5kIGBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudGAuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIHVzZXIgaGFzIG5vdCBzZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiAoYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCksIGJ1dCBoYXMgc2V0IGEgY3VycmVuY3kgc3ltYm9sIChgY3VycmVuY3lTeW1ib2xgKSxcclxuICAgICAqIHRoZW4gd2UgbW9kaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgaW4gb3JkZXIgdG8ga2VlcCB0aGUgcmVzdWx0aW5nIG91dHB1dCBsb2dpY2FsIGJ5IGRlZmF1bHQgOlxyXG4gICAgICogLSBcIiQtMSwyMzQuNTZcIiBpbnN0ZWFkIG9mIFwiLSQxLDIzNC41NlwiICh7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9KVxyXG4gICAgICogLSBcIi0xLDIzNC41NiRcIiBpbnN0ZWFkIG9mIFwiMSwyMzQuNTYtJFwiICh7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0pXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcnJlY3ROZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudE9wdGlvbihzZXR0aW5ncykge1xyXG4gICAgICAgIC8vIElmIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGlzIGFscmVhZHkgc2V0LCB3ZSBkbyBub3Qgb3ZlcndyaXRlIGl0XHJcbiAgICAgICAgaWYgKCFpc051bGwoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoc2V0dGluZ3MpICYmXHJcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkgJiZcclxuICAgICAgICAgICAgIWlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAncCc7IC8vIERlZmF1bHQgLTEsMjM0LjU2IOKCrFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAnbCc7IC8vIERlZmF1bHQgLSQxLDIzNC41NlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGlzIGBudWxsYFxyXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9ICdsJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmFseXplIGFuZCBzYXZlIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBpbnRlZ2VyIHNpemUgZm9yIGxhdGVyIHVzZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpIHtcclxuICAgICAgICBsZXQgW21heGltdW1WYWx1ZUludGVnZXJQYXJ0XSA9IHNldHRpbmdzLm1heGltdW1WYWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgbGV0IFttaW5pbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSAoIXNldHRpbmdzLm1pbmltdW1WYWx1ZSAmJiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgIT09IDApP1tdOnNldHRpbmdzLm1pbmltdW1WYWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgbWF4aW11bVZhbHVlSW50ZWdlclBhcnQgPSBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgIG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWluaW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcclxuXHJcbiAgICAgICAgc2V0dGluZ3MubUludFBvcyA9IE1hdGgubWF4KG1heGltdW1WYWx1ZUludGVnZXJQYXJ0Lmxlbmd0aCwgMSk7XHJcbiAgICAgICAgc2V0dGluZ3MubUludE5lZyA9IE1hdGgubWF4KG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0Lmxlbmd0aCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgYGRlY2ltYWxQbGFjZXNPdmVycmlkZWAgYXMgbmVlZGVkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcnJlY3REZWNpbWFsUGxhY2VzT3ZlcnJpZGVPcHRpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHRpbmdzLm9EZWMgPSBTdHJpbmcoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuXHJcbiAgICAgICAgLy8gTW9zdCBjYWxjdWx1cyBhc3N1bWUgYGRlY2ltYWxQbGFjZXNPdmVycmlkZWAgaXMgYW4gaW50ZWdlciwgdGhlIGZvbGxvd2luZyBzdGF0ZW1lbnQgbWFrZXMgaXQgY2xlYXIgKG90aGVyd2lzZSBoYXZpbmcgaXQgYXMgYSBzdHJpbmcgbGVhZHMgdG8gcHJvYmxlbXMgaW4gcm91bmRpbmcgZm9yIGluc3RhbmNlKVxyXG4gICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRzQWx0ZXJuYXRpdmVEZWNpbWFsU2VwYXJhdG9yQ2hhcmFjdGVyKHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmIE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciA9PT0gJy4nICYmIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlID0gJywnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcsJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlcyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMoc2V0dGluZ3MpIHtcclxuICAgICAgICBjb25zdCBhbGxOdW1iZXJzUmVnID0gJ1swLTldJztcclxuICAgICAgICBjb25zdCBub0FsbE51bWJlcnNSZWcgPSAnW14wLTldJztcclxuXHJcbiAgICAgICAgLy8gVGVzdCBpZiB0aGVyZSBpcyBhIG5lZ2F0aXZlIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXHJcbiAgICAgICAgY29uc3QgYU5lZ1JlZyA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcj9gKFstXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfV0/KWA6JygtPyknO1xyXG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xyXG5cclxuICAgICAgICBsZXQgbmVnYXRpdmVTaWduUmVnUGFydDtcclxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSBgXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmVnYXRpdmVTaWduUmVnUGFydCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHtuZWdhdGl2ZVNpZ25SZWdQYXJ0fVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfV0uKj8oJHthbGxOdW1iZXJzUmVnfXxcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30pYCk7XHJcbiAgICAgICAgc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAoJHthbGxOdW1iZXJzUmVnfVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9PylbXlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfV0ke25vQWxsTnVtYmVyc1JlZ30qJGApO1xyXG5cclxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xyXG4gICAgICAgIHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2cnKTtcclxuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0/KCR7YWxsTnVtYmVyc1JlZ30rXFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9Kyl8KCR7YWxsTnVtYmVyc1JlZ30qKD86XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9Kik/KSlgKTtcclxuXHJcbiAgICAgICAgLy8gVXNpbmcgdGhpcyByZWdleCB2ZXJzaW9uIGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkfCQpYCBlbnRpcmVseSBjbGVhciB0aGUgaW5wdXQgb24gYmx1clxyXG4gICAgICAgIHNldHRpbmdzLnN0cmlwUmVnID0gbmV3IFJlZ0V4cChgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKigke2FsbE51bWJlcnNSZWd9KWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnIGxhdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoc2V0dGluZ3MpIHtcclxuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyAndHJ1ZScgYW5kICdmYWxzZScgdG8gcmVhbCBCb29sZWFuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUgPT09ICd0cnVlJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXJzIGluIG9wdGlvbnMgdG8gc3RyaW5nc1xyXG4gICAgICAgICAgICAvL1RPRE8gaWYgYSB2YWx1ZSBpcyBhbHJlYWR5IG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYga2V5ICE9PSAnYVNjYWxlJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIG9sZCBzZXR0aW5ncyBvcHRpb25zIG5hbWUgdG8gbmV3IG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucykge1xyXG4gICAgICAgIC8vVE9ETyBEZWxldGUgdGhpcyBmdW5jdGlvbiBvbmNlIHRoZSBvbGQgb3B0aW9ucyBhcmUgbm90IHVzZWQgYW55bW9yZVxyXG4gICAgICAgIGNvbnN0IG9sZE9wdGlvbnNDb252ZXJ0ZXIgPSB7XHJcbiAgICAgICAgICAgIC8vIE9sZCBvcHRpb24gbmFtZSwgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIG5ldyBvcHRpb25cclxuICAgICAgICAgICAgYVNlcCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdEdyb3VwU2VwYXJhdG9yJyxcclxuICAgICAgICAgICAgblNlcCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdub1NlcGFyYXRvck9uRm9jdXMnLFxyXG4gICAgICAgICAgICBkR3JvdXAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RpZ2l0YWxHcm91cFNwYWNpbmcnLFxyXG4gICAgICAgICAgICBhRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxDaGFyYWN0ZXInLFxyXG4gICAgICAgICAgICBhbHREZWMgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScsXHJcbiAgICAgICAgICAgIGFTaWduICAgICAgICAgICAgICAgICAgICAgICAgOiAnY3VycmVuY3lTeW1ib2wnLFxyXG4gICAgICAgICAgICBwU2lnbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sUGxhY2VtZW50JyxcclxuICAgICAgICAgICAgcE5lZyAgICAgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcsXHJcbiAgICAgICAgICAgIGFTdWZmaXggICAgICAgICAgICAgICAgICAgICAgOiAnc3VmZml4VGV4dCcsXHJcbiAgICAgICAgICAgIG9MaW1pdHMgICAgICAgICAgICAgICAgICAgICAgOiAnb3ZlcnJpZGVNaW5NYXhMaW1pdHMnLFxyXG4gICAgICAgICAgICB2TWF4ICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21heGltdW1WYWx1ZScsXHJcbiAgICAgICAgICAgIHZNaW4gICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWluaW11bVZhbHVlJyxcclxuICAgICAgICAgICAgbURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnLFxyXG4gICAgICAgICAgICBlRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnLFxyXG4gICAgICAgICAgICBzY2FsZURlY2ltYWwgICAgICAgICAgICAgICAgIDogJ3NjYWxlRGVjaW1hbFBsYWNlcycsXHJcbiAgICAgICAgICAgIGFTdG9yICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZScsXHJcbiAgICAgICAgICAgIG1Sb3VuZCAgICAgICAgICAgICAgICAgICAgICAgOiAncm91bmRpbmdNZXRob2QnLFxyXG4gICAgICAgICAgICBhUGFkICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2FsbG93RGVjaW1hbFBhZGRpbmcnLFxyXG4gICAgICAgICAgICBuQnJhY2tldCAgICAgICAgICAgICAgICAgICAgIDogJ25lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyJyxcclxuICAgICAgICAgICAgd0VtcHR5ICAgICAgICAgICAgICAgICAgICAgICA6ICdlbXB0eUlucHV0QmVoYXZpb3InLFxyXG4gICAgICAgICAgICBsWmVybyAgICAgICAgICAgICAgICAgICAgICAgIDogJ2xlYWRpbmdaZXJvJyxcclxuICAgICAgICAgICAgYUZvcm0gICAgICAgICAgICAgICAgICAgICAgICA6ICdmb3JtYXRPblBhZ2VMb2FkJyxcclxuICAgICAgICAgICAgc051bWJlciAgICAgICAgICAgICAgICAgICAgICA6ICdzZWxlY3ROdW1iZXJPbmx5JyxcclxuICAgICAgICAgICAgYW5EZWZhdWx0ICAgICAgICAgICAgICAgICAgICA6ICdkZWZhdWx0VmFsdWVPdmVycmlkZScsXHJcbiAgICAgICAgICAgIHVuU2V0T25TdWJtaXQgICAgICAgICAgICAgICAgOiAndW5mb3JtYXRPblN1Ym1pdCcsXHJcbiAgICAgICAgICAgIG91dHB1dFR5cGUgICAgICAgICAgICAgICAgICAgOiAnb3V0cHV0Rm9ybWF0JyxcclxuICAgICAgICAgICAgZGVidWcgICAgICAgICAgICAgICAgICAgICAgICA6ICdzaG93V2FybmluZ3MnLFxyXG4gICAgICAgICAgICAvLyBDdXJyZW50IG9wdGlvbnMgOlxyXG4gICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbm9TZXBhcmF0b3JPbkZvY3VzICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cFNwYWNpbmcgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICA6IHRydWUsXHJcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3dQb3NpdGl2ZVNpZ24gICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzdWZmaXhUZXh0ICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc092ZXJyaWRlICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzY2FsZURpdmlzb3IgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsUGxhY2VzICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNjYWxlU3ltYm9sICAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb25JbnZhbGlkUGFzdGUgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvciAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWFkaW5nWmVybyAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZm9ybWF0T25QYWdlTG9hZCAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPdmVycmlkZSAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgdW5mb3JtYXRPblN1Ym1pdCAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdCAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93V2FybmluZ3MgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZmFpbE9uVW5rbm93bk9wdGlvbiAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIC8vRklYTUUgRmluZCBhIHdheSB0byBleGNsdWRlIHRob3NlIGludGVybmFsIGRhdGEgZnJvbSB0aGUgc2V0dGluZ3Mgb2JqZWN0IChpZGVhbGx5IGJ5IHVzaW5nIGFub3RoZXIgb2JqZWN0LCBvciBiZXR0ZXIgeWV0LCBjbGFzcyBhdHRyaWJ1dGVzKSAtLT5cclxuICAgICAgICAgICAgaGFzRm9jdXMgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBydW5PbmNlICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZSAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBjYXJldEZpeCAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHRocm93SW5wdXQgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc3RyaXAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnbkNoYXJhY3RlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcG9zaXRpdmVTaWduQ2hhcmFjdGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBtSW50UG9zICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG1JbnROZWcgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb0RlYyAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvUGFkICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9CcmFja2V0ICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb1NlcCAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvU2lnbiAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9TdWZmaXggICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgYU5lZ1JlZ0F1dG9TdHJpcCAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBza2lwRmlyc3RBdXRvU3RyaXAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNraXBMYXN0QXV0b1N0cmlwICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgYWxsb3dlZEF1dG9TdHJpcCAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1SZWdBdXRvU3RyaXAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHN0cmlwUmVnICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgaG9sZGVyICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXMgYSAnbmV3JyBvcHRpb24sIHdlIGNvbnRpbnVlIGxvb3BpbmdcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlci5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSB3ZSBoYXZlIGFuICdvbGQnIG9wdGlvbiBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZyhgWW91IGFyZSB1c2luZyB0aGUgZGVwcmVjYXRlZCBvcHRpb24gbmFtZSAnJHtvcHRpb259Jy4gUGxlYXNlIHVzZSAnJHtvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl19JyBpbnN0ZWFkIGZyb20gbm93IG9uLiBUaGUgb2xkIG9wdGlvbiBuYW1lIHdpbGwgYmUgZHJvcHBlZCBzb29uLmAsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIHdlIG1vZGlmeSB0aGUgaW5pdGlhbCBvcHRpb24gb2JqZWN0IHRvIHVzZSB0aGUgbmV3IG9wdGlvbnMgaW5zdGVhZCBvZiB0aGUgb2xkIG9uZXNcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXV0gPSBvcHRpb25zW29wdGlvbl07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3IgdGhlIG9wdGlvbiBuYW1lIGlzIHVua25vd24uIFRoaXMgbWVhbnMgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIG9wdGlvbnMgb2JqZWN0LCB0aGVyZWZvcmUgd2UgdGhyb3cgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgT3B0aW9uIG5hbWUgJyR7b3B0aW9ufScgaXMgdW5rbm93bi4gUGxlYXNlIGZpeCB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gYXV0b051bWVyaWNgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuYWx5c2UgdGhlIHNldHRpbmdzL29wdGlvbnMgcGFzc2VkIGJ5IHRoZSB1c2VyLCB2YWxpZGF0ZSBhbmQgY2xlYW4gdGhlbSwgdGhlbiByZXR1cm4gdGhlbS5cclxuICAgICAqIE5vdGU6IFRoaXMgcmV0dXJucyBgbnVsbGAgaWYgc29tZWhvdyB0aGUgc2V0dGluZ3MgcmV0dXJuZWQgYnkgalF1ZXJ5IGlzIG5vdCBhbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlIC0gSWYgVFJVRSwgdGhlbiB0aGUgc2V0dGluZ3MgYWxyZWFkeSBleGlzdHMgYW5kIHRoaXMgZnVuY3Rpb24gb25seSB1cGRhdGVzIHRoZW0gaW5zdGVhZCBvZiByZWNyZWF0aW5nIHRoZW0gZnJvbSBzY3JhdGNoXHJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgdXBkYXRlID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgXCJhdXRvTnVtZXJpY1wiIHNldHRpbmdzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgaXQgcmV0dXJucyBcInVuZGVmaW5lZFwiLlxyXG4gICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHVzZWQgb2xkIG9wdGlvbnMsIHdlIGNvbnZlcnQgdGhlbSB0byBuZXcgb25lc1xyXG4gICAgICAgIGlmICh1cGRhdGUgfHwgIWlzTnVsbChvcHRpb25zKSkge1xyXG4gICAgICAgICAgICBjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyhvcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh1cGRhdGUgfHwgaXNVbmRlZmluZWQoc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgdXBkYXRlZFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBncmFiIGFueSBzZXR0aW5ncywgY3JlYXRlIHRoZW0gZnJvbSB0aGUgZGVmYXVsdCBvbmVzIGFuZCBjb21iaW5lIHRoZW0gd2l0aCB0aGUgb3B0aW9ucyBwYXNzZWRcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgZ2VuZXJhdGVkIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbHNvIGF0dGVtcHQgdG8gZ3JhYiB0aGUgSFRNTDUgZGF0YS4gSWYgaXQgZG9lc24ndCBleGlzdCwgd2UnbGwgZ2V0IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb2N1cyAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgICAgICAgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYW5kcm9pZFNlbGVjdGlvblN0YXJ0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93SW5wdXQgICAgICAgICAgIDogdHJ1ZSwgLy8gVGhyb3cgaW5wdXQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgICAgICAgOiBhbGxvd2VkVGFnTGlzdCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZSdcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEltcHJvdmUgdGhlIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBuZWdhdGl2ZSBhbmQgcG9zaXRpdmUgc2lnbnMsIGFzIG5lZWRlZFxyXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSBzZXR0aW5ncy5taW5pbXVtVmFsdWUgPCAwID8gJy0nIDogJyc7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3RlciA9IHNldHRpbmdzLm1heGltdW1WYWx1ZSA+PSAwID8gJysnIDogJyc7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGNoYW5nZXMgdG8gdGhlIHNldHRpbmdzIG9iamVjdCAoZnJvbSB0aGUgb3JpZ2luYWwgYXV0b0NvZGUoKSBmdW5jdGlvbilcclxuICAgICAgICAgICAgcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCR0aGlzLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgY29ycmVjdERlY2ltYWxQbGFjZXNPdmVycmlkZU9wdGlvbihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyhzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgdmFsaWRhdGUoc2V0dGluZ3MsIGZhbHNlKTsgLy8gVGhyb3dzIGlmIG5lY2Vzc2FyeVxyXG5cclxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMsIHNjYWxlRGl2aXNvciAmIG5vU2VwYXJhdG9yT25Gb2N1cyBvcHRpb25zIGFyZSBiZWluZyB1c2VkXHJcbiAgICAgICAgICAgIGtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5KHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIG5ldyBzZXR0aW5nc1xyXG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBgdmFsdWVgIHBhcmFtZXRlciB0aGF0IGNhbiBlaXRoZXIgYmUgOlxyXG4gICAgICogLSBhIHJlYWwgbnVtYmVyLFxyXG4gICAgICogLSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSByZWFsIG51bWJlciwgb3JcclxuICAgICAqIC0gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbG9jYWxpemVkIG51bWJlciAod2l0aCBzcGVjaWZpYyBncm91cCBzZXBhcmF0b3JzIGFuZCBkZWNpbWFsIGNoYXJhY3RlciksXHJcbiAgICAgKiAuLi50byBhIHN0cmluZyByZXByZXNlbnRpbmcgYSByZWFsICdqYXZhc2NyaXB0JyBudW1iZXIgKGllLiAnMTIzNCcgb3IgJzEyMzQuNTY3JykuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGBOYU5gIGlmIHN1Y2ggY29udmVyc2lvbiBmYWlscy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ludHxmbG9hdHxzdHJpbmd9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TmFOfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b051bWVyaWNWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGlmIChpc051bWJlcihOdW1iZXIodmFsdWUpKSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaGFzIGVpdGhlciBhbHJlYWR5IGJlZW4gc3RyaXBwZWQsIG9yIGEgJ3JlYWwnIGphdmFzY3JpcHQgbnVtYmVyIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxyXG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBFbHNlIGlmIGl0J3MgYSBzdHJpbmcgdGhhdCBgTnVtYmVyKClgIGNhbm5vdCB0eXBlY2FzdCwgdGhlbiB3ZSB0cnkgdG8gY29udmVydCB0aGUgbG9jYWxpemVkIG51bWVyaWMgc3RyaW5nIHRvIGEgbnVtZXJpYyBvbmVcclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1lcmljIHN0cmluZywgc3RyaXBwaW5nIHVubmVjZXNzYXJ5IGNoYXJhY3RlcnMgaW4gdGhlIHByb2Nlc3NcclxuICAgICAgICAgICAgcmVzdWx0ID0gY29udmVydFRvTnVtZXJpY1N0cmluZyh2YWx1ZS50b1N0cmluZygpLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHN0aWxsIG5vdCBhIG51bWVyaWMgc3RyaW5nLCB0aGVuIHdlIHRocm93IGEgd2FybmluZ1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKE51bWJlcihyZXN1bHQpKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybmluZyhgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIHVzZWQgYXBwcm9wcmlhdGVseS5gLCBzZXR0aW5ncy5zaG93V2FybmluZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTmFOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0aG9kcyBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNcclxuICAgICAqL1xyXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhbGl6ZSBhdXRvTnVtZXJpYyBhbmQgYXR0YWNoIHRoZSBzZXR0aW5ncyAob3B0aW9ucyBjYW4gYmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyKVxyXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7ZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLCBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnLCB7b3B0aW9uc30pOyAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbnN9KTsgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8e3N0YXRlbWVudHMsIGJyYW5jaGVzLCBsaW5lcywgZnVuY3Rpb25zLCBleGNsdWRlcywgb3ZlcnJpZGVzfXx7c3RhdGVtZW50cywgYnJhbmNoZXMsIGxpbmVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzfXx7c3RhdGVtZW50cywgbGluZXMsIGJyYW5jaGVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzfX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9IGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBob2xkZXIgPSBnZXRBdXRvTnVtZXJpY0hvbGRlcigkdGhpcywgc2V0dGluZ3MsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnJ1bk9uY2UgJiYgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQoc2V0dGluZ3MsICRpbnB1dCwgJHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJ1bk9uY2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyB0byBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgKFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlKVxyXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCAmJiAkdGhpcy5kYXRhKCdpbml0aWFsaXplZCcpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRIYW5kbGVycyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Gb2N1c0luQW5kTW91c2VFbnRlcjogZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlOiBlID0+IHsgb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5ZG93bjogZSA9PiB7IG9uS2V5ZG93bihob2xkZXIsIGUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleXByZXNzOiBlID0+IHsgb25LZXlwcmVzcyhob2xkZXIsIGUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0OiBlID0+IHsgb25JbnB1dChob2xkZXIsIGUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleXVwOiBlID0+IHsgb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25CbHVyOiBlID0+IHsgb25CbHVyKGhvbGRlciwgZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUGFzdGU6IGUgPT4geyBvblBhc3RlKCR0aGlzLCBob2xkZXIsIGUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRDb25maWdzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmb2N1c2luJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbkZvY3VzSW5BbmRNb3VzZUVudGVyIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZW50ZXInLCBoYW5kbGVyOiBldmVudEhhbmRsZXJzLm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYmx1cicsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25Gb2N1c091dEFuZE1vdXNlTGVhdmUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VsZWF2ZScsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25Gb2N1c091dEFuZE1vdXNlTGVhdmUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAna2V5ZG93bicsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25LZXlkb3duIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2tleXByZXNzJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbktleXByZXNzIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2lucHV0JywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbklucHV0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2tleXVwJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbktleXVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2JsdXInLCBoYW5kbGVyOiBldmVudEhhbmRsZXJzLm9uQmx1ciB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwYXN0ZScsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25QYXN0ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnRDb25maWcgb2YgZXZlbnRDb25maWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudENvbmZpZy5uYW1lLCBldmVudENvbmZpZy5oYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKTsgLy9UT0RPIFN3aXRjaCB0byBgYWRkRXZlbnRMaXN0ZW5lcidcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc2M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbEV2ZW50czogZWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnRDb25maWcgb2YgZXZlbnRDb25maWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRDb25maWcubmFtZSwgZXZlbnRDb25maWcuaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbCkuY2xvc2VzdCgnZm9ybScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vZmYoJy5hdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIHN0b3AgYW5kIHJlbW92ZSBhdXRvTnVtZXJpYyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICAgICAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcImRlc3Ryb3lcIik7IC8vIERlc3Ryb3lzIGF1dG9OdW1lcmljIG9uIHRoaXMgc2VsZWN0ZWQgZWxlbWVudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjbGVhclZhbHVlIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBjbGVhcnMgdGhlIHRleHQgYm94IHVwb24gZGVzdHJ1Y3Rpb24uXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3koY2xlYXJWYWx1ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCBjbGVhclZhbHVlID09PSB0cnVlID8gJycgOiAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0JykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ21pc2MnKS5yZW1vdmVBbGxFdmVudHModGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnYXV0b051bWVyaWMnLCAnaW5pdGlhbGl6ZWQnLCAncmVtb3ZlQWxsRXZlbnRzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub2ZmKCcuYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIGNsZWFyIHRoZSB2YWx1ZSBmcm9tIHNlc3Npb25TdG9yYWdlIChvciBjb29raWUsIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcIndpcGVcIik7IC8vIFJlbW92ZXMgc2Vzc2lvbiBzdG9yYWdlIGFuZCBjb29raWVzIGZyb20gbWVtb3J5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2lwZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cclxuICAgICAgICAgKiBJdCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIG5lZWRlZC5cclxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwidXBkYXRlXCIsIHtvcHRpb25zfSk7IC8vIFVwZGF0ZXMgdGhlIHNldHRpbmdzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGUob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgaW5wdXQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpcCA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWUgd2l0aCB0aGUgbmV3IHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcykgIT09ICcnIHx8ICR0aGlzLnRleHQoKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGl0IGNhbiBiZSBhbiBpbnRlZ2VyICcxMjM0JyBvciBhIGRvdWJsZSAnMTIzNC41Njc4OSdcclxuICAgICAgICAgKiBhbmQgbXVzdCBjb250YWluIG9ubHkgbnVtYmVycyBhbmQgb25lIGRlY2ltYWwgKHBlcmlvZCkgY2hhcmFjdGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3NldCcsICcxMjM0NS42NycpOyAvLyBGb3JtYXRzIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbmV3VmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwgfHwgaXNVbmRlZmluZWQobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2QuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdHJhaWxpbmcgbmVnYXRpdmUgc2V0dGluZ3MsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBuZWdhdGl2ZSwgYnV0IG5vdCB0aGUgbmV3bHkgc2V0IG9uZVxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0b051bWVyaWNWYWx1ZShuZXdWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0ZXN0IGlzIG5lZWRlZCBieSB0aGUgc2hvd1Bvc2l0aXZlU2lnbiBvcHRpb25cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1plcm8gPSBpc1plcm9Pckhhc05vVmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgfHwgaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHJvdW5kaW5nIGRvZXMgbm90IGhhcHBlbiB0d2ljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0JlZW5Sb3VuZGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91bmRzIHRoZSB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wRGVjaW1hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcERlY2ltYWwgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0JlZW5Sb3VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSB0ZW1wRGVjaW1hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyksIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wRGVjaW1hbCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCZWVuUm91bmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kcyBpZiB0aGlzIGhhcyBub3QgYmVlbiBkb25lIGFscmVhZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzQmVlblJvdW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZXMgcmF3VmFsdWUgaW5jbHVkaW5nIHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyksIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhZGRHcm91cFNlcGFyYXRvcnModmFsdWUsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcyAmJiAhc2V0dGluZ3Mub25PZmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSB0ZW1wRGVjaW1hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgJiYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICdzZXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRlbXB0ZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2F0dGVtcHRlZFZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmhhc0ZvY3VzICYmIHNldHRpbmdzLnNjYWxlU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIHNldHRpbmdzLnNjYWxlU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnRleHQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMuXHJcbiAgICAgICAgICogVGhpcyBpcyBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5ncyAoaWUuIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiksIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzLlxyXG4gICAgICAgICAqIFBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIG1vcmUgZGV0YWlsc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCd1blNldCcpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVuU2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICR0aGlzLmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0byByZS1mb3JtYXQgaW5wdXRzLlxyXG4gICAgICAgICAqIFRoaXMgaXMgaGFuZHkgdG8gdXNlIHJpZ2h0IGFmdGVyIGZvcm0gc3VibWlzc2lvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSAndW5TZXQnIG1ldGhvZCB0byByZWZvcm1hdCB0aGUgaW5wdXRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZVNldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAvL1RPRE8gV2h5IHdvdWxkIHdlIG5lZWQgdG8gZ2V0IGEgbmV3IHJlZmVyZW5jZSB0byAkdGhpcyBzaW5jZSBpdCBoYXMgYmVlbiBkb25lIGluIGBpbml0KClgP1xyXG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xyXG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcImdldFwiIG1ldGhvZC5gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBlbGVtZW50IHR5cGUgdGhlbiB1c2UgLmVxKDApIHNlbGVjdG9yIHRvIGdyYWIgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHNlbGVjdG9yXHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMuZXEoMCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudGV4dCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbHVlTmVnYXRpdmUgPSBpc05lZ2F0aXZlKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoISgvXFxkLykudGVzdCh2YWx1ZSkgJiYgc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnZm9jdXMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwcyB0cmFpbGluZyBuZWdhdGl2ZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHplcm9zIHdoZW4gbGVhZGluZ1plcm8gZG9lcyBOT1QgZXF1YWwgXCJrZWVwXCIuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSwgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZXMgdGhlIG5lZ2F0aXZlIHN5bWJvbCBpbiBmcm9udCBvZiB0aGUgdHJhaWxpbmcgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiBpc1ZhbHVlTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUodmFsdWUpICYmIE51bWJlcih2YWx1ZSkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJyB8fCB2YWx1ZSA9PT0gJycgJiYgc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnemVybycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgbnVtZXJpYyBzdHJpbmdcclxuICAgICAgICAgICAgLy8gVGhpcyBnZXRzIHJpZCBvZiB0aGUgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGRlY2ltYWwgcGxhY2VzIHNpbmNlIGBnZXRgIGRvZXMgbm90IHBhZCBkZWNpbWFsc1xyXG4gICAgICAgICAgICByZXR1cm4gdHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXModmFsdWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHZhbHVlLCBidXQgZm9sbG93aW5nIHRoZSBgb3V0cHV0Rm9ybWF0YCBzZXR0aW5nLCB3aGljaCBtZWFucyB0aGUgb3V0cHV0IGNhbiBlaXRoZXIgYmUgOlxyXG4gICAgICAgICAqIC0gYSBzdHJpbmcgKHRoYXQgY291bGQgb3IgY291bGQgbm90IHJlcHJlc2VudCBhIG51bWJlciAoaWUuIFwiMTIzNDUsNjctXCIpKSwgb3JcclxuICAgICAgICAgKiAtIGEgcGxhaW4gbnVtYmVyIChpZiB0aGUgc2V0dGluZyAnbnVtYmVyJyBpcyB1c2VkKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdGhlIHJldHVybmVkIHZhbHVlcyBhcmUgYW4gSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXHJcbiAgICAgICAgICogQ2hlY2sgdGhlIFwib3V0cHV0Rm9ybWF0XCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TG9jYWxpemVkKCkge1xyXG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dEZvcm1hdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBpbnB1dCB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHJlYWwgSmF2YXNjcmlwdCBudW1iZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXROdW1iZXInKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TnVtYmVyKCkge1xyXG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0b0xvY2FsZSh2YWx1ZSwgJ251bWJlcicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGF1dG9OdW1lcmljIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHVzYWdlIGFOSW5wdXQuYXV0b051bWVyaWMoJ2dldEZvcm1hdHRlZCcpKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgdGhpc1swXWAgZXhpc3RzIGFzIHdlbGwgYXMgYC52YWx1ZWAgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhhdCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJzAnKSB8fCAhKCd2YWx1ZScgaW4gdGhpc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIGRldGFpbHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U3RyaW5nKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkoZmFsc2UsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIGRldGFpbHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt7fXxbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBcnJheSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KHRydWUsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBjdXJyZW50IGF1dG9OdW1lcmljIHNldHRpbmdzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJyk7XHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpLmRlY2ltYWxDaGFyYWN0ZXI7IC8vIFJldHVybiB0aGUgZGVjaW1hbENoYXJhY3RlciBzZXR0aW5nIGFzIGEgc3RyaW5nIC0gYW55IHZhbGlkIG9wdGlvbiBuYW1lIGNhbiBiZSB1c2VkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFNldHRpbmdzKCkge1xyXG4gICAgICAgICAgICAvL1RPRE8gQWRkIGFuIG9wdGlvbiBhcmd1bWVudCBgb3B0aW9uTmFtZWAgdG8gdGhpcyBmdW5jdGlvbiBzbyB0aGF0IGl0IHJldHVybiBvbmx5IHRoZSB2YWx1ZSBvZiB0aGF0IG9wdGlvbiwgbm90IHRoZSBlbnRpcmUgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXV0b051bWVyaWMgZnVuY3Rpb24gYWNjZXB0cyBtZXRob2RzIG5hbWVzIChpbiBzdHJpbmcgZm9ybWF0KSBhbmQgdGhvc2UgbWV0aG9kIHBhcmFtZXRlcnMgaWYgbmVlZGVkLlxyXG4gICAgICogSXQgaW5pdGlhbGl6ZSBhdXRvTnVtZXJpYyBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBtZXRob2QgbmFtZSAoaWUuICdzZXQnLCAnZ2V0JywgZXRjLilcclxuICAgICAqIEBwYXJhbSB7Kn0gYXJnc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgW21ldGhvZF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3dFcnJvcihgTWV0aG9kIFwiJHttZXRob2R9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZGVmYXVsdCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4gZGVmYXVsdFNldHRpbmdzO1xyXG5cclxuICAgICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMgPSBkZWZhdWx0U2V0dGluZ3M7IC8vIE1ha2UgdGhvc2Ugc2V0dGluZ3MgcHVibGljIHZpYSBqUXVlcnkgdG9vLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFsbCB0aGUgcHJlZGVmaW5lZCBsYW5ndWFnZSBvcHRpb25zIGluIG9uZSBvYmplY3QuXHJcbiAgICAgKiBZb3UgY2FuIGFsc28gYWNjZXNzIGEgc3BlY2lmaWMgbGFuZ3VhZ2Ugb2JqZWN0IGRpcmVjdGx5IGJ5IHVzaW5nIGBhbi5nZXRMYW5ndWFnZXMoKS5GcmVuY2hgIGZvciBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBnZXRMYW5ndWFnZXMgPSAoKSA9PiBsYW5ndWFnZU9wdGlvbjtcclxuXHJcbiAgICAkLmZuLmF1dG9OdW1lcmljLmxhbmcgPSBsYW5ndWFnZU9wdGlvbjsgLy8gTWFrZSB0aG9zZSBwcmVkZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMgcHVibGljIHZpYSBqUXVlcnkgdG9vLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50IHRyaWdnZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSBBIG51bWJlciwgb3IgYSBzdHJpbmcgdGhhdCByZXByZXNlbnQgYSBqYXZhc2NyaXB0IG51bWJlclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGF1dG9Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNTdHJpbmcodmFsdWUpICYmICFpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIHVzZWQgYXBwcm9wcmlhdGVseS5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYXRlIGEgdmVyeSBiYXNpYyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgbnVtZXJpYyBzdHJpbmcsIHN0cmlwcGluZyB1bm5lY2Vzc2FyeSBjaGFyYWN0ZXJzIGluIHRoZSBwcm9jZXNzXHJcbiAgICAgICAgbGV0IHZhbHVlU3RyaW5nID0gdG9OdW1lcmljVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWVTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZVN0cmluZ31dIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZm9ybWF0IGlzIG5vdCBhIHJlY29nbml6ZWQgbnVtYmVyLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQmFzaWMgdGVzdHMgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlU3RyaW5nIGlzIHZhbGlkXHJcbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcclxuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcclxuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdhdXRvRm9ybWF0LmF1dG9OdW1lcmljJywgZG9jdW1lbnQsIGBSYW5nZSB0ZXN0IGZhaWxlZGApO1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWVTdHJpbmd9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3NldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtVmFsdWUgWyR7c2V0dGluZ3MubWF4aW11bVZhbHVlfV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgb2ssIHByb2NlZWQgdG8gcm91bmRpbmcsIGZvcm1hdHRpbmcgYW5kIGdyb3VwaW5nXHJcbiAgICAgICAgdmFsdWVTdHJpbmcgPSByb3VuZFZhbHVlKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgdmFsdWVTdHJpbmcgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcclxuICAgICAgICB2YWx1ZVN0cmluZyA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmc7XHJcbiAgICB9O1xyXG5cclxuICAgICQuZm4uYXV0b0Zvcm1hdCA9IGF1dG9Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdW5mb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGF1dG9VbkZvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHaXZpbmcgYW4gdW5mb3JtYXR0ZWQgdmFsdWUgc2hvdWxkIHJldHVybiB0aGUgc2FtZSB1bmZvcm1hdHRlZCB2YWx1ZSwgd2hhdGV2ZXIgdGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHsgLy9UT0RPIENvbXBsZXRlIHRoZSB0ZXN0IHRvIHRocm93IHdoZW4gZ2l2ZW4gYSB3cm9uZ2x5IGZvcm1hdHRlZCBudW1iZXIgKGllLiAnZm9vYmFyJylcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBBIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gdW5mb3JtYXQgaXQsIFske3ZhbHVlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfWA7XHJcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBjaGVja3MgaXMgYSBuZWdhdGl2ZSBzaWduIGlzIGFueXdoZXJlIGluIHRoZSBgdmFsdWVgLCBub3QganVzdCBvbiB0aGUgdmVyeSBmaXJzdCBjaGFyYWN0ZXIgKGllLiAnMTIzNDUuNjctJylcclxuICAgICAgICBpZiAoaXNOZWdhdGl2ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgJiYgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKVswXSA9PT0gdmFsdWUuY2hhckF0KDApKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcclxuICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGF1dG9TdHJpcCwgJycpO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xyXG4gICAgICAgIHZhbHVlID0gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dEZvcm1hdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgJC5mbi5hdXRvVW5mb3JtYXQgPSBhdXRvVW5Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gb3B0aW9uIG9iamVjdC5cclxuICAgICAqIElmIHRoZSBvcHRpb25zIGFyZSB2YWxpZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIG5vdGhpbmcsIG90aGVyd2lzZSBpZiB0aGUgb3B0aW9ucyBhcmUgaW52YWxpZCwgdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB0ZXN0cyBpZiB0aGUgb3B0aW9ucyBhcmUgbm90IGNvbmZsaWN0aW5nIGFuZCBhcmUgd2VsbCBmb3JtYXR0ZWQuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxlbmllbnQgc2luY2UgaXQgb25seSB0ZXN0cyB0aGUgc2V0dGluZ3MgcHJvcGVydGllcyA7IGl0IGlnbm9yZXMgYW55IG90aGVyIHByb3BlcnRpZXMgdGhlIG9wdGlvbnMgb2JqZWN0IGNvdWxkIGhhdmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB1c2VyT3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyBJZiBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCBleHRlbmRzIHRoZSBgdXNlck9wdGlvbnNgIHBhc3NlZCBieSB0aGUgdXNlciwgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLlxyXG4gICAgICogQHRocm93cyBFcnJvclxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZSA9ICh1c2VyT3B0aW9ucywgc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSB0cnVlKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT3B0aW9ucykgfHwgIWlzT2JqZWN0KHVzZXJPcHRpb25zKSB8fCBpc0VtcHR5T2JqKHVzZXJPcHRpb25zKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdXNlck9wdGlvbnMgYXJlIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSB2YWxpZCBvYmplY3QsIFske3VzZXJPcHRpb25zfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgdXNlciB1c2VkIG9sZCBvcHRpb25zLCB3ZSBjb252ZXJ0IHRoZW0gdG8gbmV3IG9uZXNcclxuICAgICAgICBpZiAoIWlzTnVsbCh1c2VyT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgY29udmVydE9sZE9wdGlvbnNUb05ld09uZXModXNlck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIGNob29zZSBpZiB0aGUgYHVzZXJPcHRpb25zYCBoYXMgYWxyZWFkeSBiZWVuIGV4dGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgb3Igbm90XHJcbiAgICAgICAgbGV0IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB1c2VyT3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHVzZXJPcHRpb25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyc3QgdGhpbmdzIGZpcnN0LCB3ZSB0ZXN0IHRoYXQgdGhlIGBzaG93V2FybmluZ3NgIG9wdGlvbiBpcyB2YWxpZFxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNob3dXYXJuaW5ncykgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNob3dXYXJuaW5ncykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnc2hvd1dhcm5pbmdzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93V2FybmluZ3N9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmluZSB0aGUgcmVndWxhciBleHByZXNzaW9ucyBuZWVkZWQgZm9yIHRoZSBmb2xsb3dpbmcgdGVzdHNcclxuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcclxuICAgICAgICBjb25zdCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyA9IC9bMC05XSsvO1xyXG4gICAgICAgIC8vIGNvbnN0IHRlc3RGbG9hdEFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKSQvO1xyXG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcclxuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlciA9IC9eWzAtOV0rKFxcLj9bMC05XSspPyQvO1xyXG5cclxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvciwgW1xyXG4gICAgICAgICAgICAnLCcsICAgICAgLy8gQ29tbWFcclxuICAgICAgICAgICAgJy4nLCAgICAgIC8vIERvdFxyXG4gICAgICAgICAgICAnICcsICAgICAgLy8gTm9ybWFsIHNwYWNlXHJcbiAgICAgICAgICAgICdcXHUyMDA5JywgLy8gVGhpbi1zcGFjZVxyXG4gICAgICAgICAgICAnXFx1MjAyZicsIC8vIE5hcnJvdyBuby1icmVhayBzcGFjZVxyXG4gICAgICAgICAgICAnXFx1MDBhMCcsIC8vIE5vLWJyZWFrIHNwYWNlXHJcbiAgICAgICAgICAgICcnLCAgICAgICAvLyBObyBzZXBhcmF0b3JcclxuICAgICAgICAgICAgXCInXCIsICAgICAgLy8gQXBvc3Ryb3BoZVxyXG4gICAgICAgICAgICAn2awnLCAgICAgIC8vIEFyYWJpYyB0aG91c2FuZHMgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgICfLmScsICAgICAgLy8gRG90IGFib3ZlXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkaWdpdEdyb3VwU2VwYXJhdG9yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcsJywgJy4nLCAn2awnLCAny5knLCBcIidcIiwgJyAnLCAnXFx1MjAwOScsICdcXHUyMDJmJywgJ1xcdTAwYTAnIG9yIGVtcHR5ICgnJyksIFske29wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgJ25vU2VwYXJhdG9yT25Gb2N1cycgb3B0aW9uIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1c31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZGlnaXRhbEdyb3VwU3BhY2luZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZ31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLCBbXHJcbiAgICAgICAgICAgICcsJywgLy8gQ29tbWFcclxuICAgICAgICAgICAgJy4nLCAvLyBEb3RcclxuICAgICAgICAgICAgJ8K3JywgLy8gTWlkZGxlLWRvdFxyXG4gICAgICAgICAgICAn2asnLCAvLyBBcmFiaWMgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgJ+KOlicsIC8vIERlY2ltYWwgc2VwYXJhdG9yIGtleSBzeW1ib2xcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGVjaW1hbENoYXJhY3RlcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLicsICcsJywgJ8K3JywgJ+KOlicgb3IgJ9mrJywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kIGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciA9PT0gb3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdkZWNpbWFsQ2hhcmFjdGVyJyBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciAnZGlnaXRHcm91cFNlcGFyYXRvcicgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gYXJlIHRoZSBzYW1lIGNoYXJhY3Rlci5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhbHRlcm5hdGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFpc1N0cmluZyhvcHRpb25zLmN1cnJlbmN5U3ltYm9sKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VycmVuY3kgc3ltYm9sIG9wdGlvbiAnY3VycmVuY3lTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuY3VycmVuY3lTeW1ib2x9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQsIFsncCcsICdzJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIGN1cnJlbmN5IHNpZ24gb3B0aW9uICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpIG9yICdzJyAoc3VmZml4KSwgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCwgWydwJywgJ3MnLCAnbCcsICdyJywgbnVsbF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpLCAncycgKHN1ZmZpeCksICdsJyAobGVmdCksICdyJyAocmlnaHQpIG9yICdudWxsJywgWyR7b3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbikgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNob3dQb3NpdGl2ZVNpZ24pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzaG93IHBvc2l0aXZlIHNpZ24gb3B0aW9uICdzaG93UG9zaXRpdmVTaWduJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93UG9zaXRpdmVTaWdufV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuc3VmZml4VGV4dCkgfHwgKG9wdGlvbnMuc3VmZml4VGV4dCAhPT0gJycgJiYgKGlzTmVnYXRpdmUob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuc3VmZml4VGV4dCkpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWRkaXRpb25hbCBzdWZmaXggb3B0aW9uICdzdWZmaXhUZXh0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIG5vdCBjb250YWlucyB0aGUgbmVnYXRpdmUgc2lnbiAnLScgbm9yIGFueSBudW1lcmljYWwgY2hhcmFjdGVycywgWyR7b3B0aW9ucy5zdWZmaXhUZXh0fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMsIFsnY2VpbGluZycsICdmbG9vcicsICdpZ25vcmUnXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG92ZXJyaWRlIG1pbiAmIG1heCBsaW1pdHMgb3B0aW9uICdvdmVycmlkZU1pbk1heExpbWl0cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2NlaWxpbmcnLCAnZmxvb3InIG9yICdpZ25vcmUnLCBbJHtvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMubWF4aW11bVZhbHVlKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLm1heGltdW1WYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICdtYXhpbXVtVmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLm1pbmltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5taW5pbXVtVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAnbWluaW11bVZhbHVlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMubWluaW11bVZhbHVlKSA+IHBhcnNlRmxvYXQob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIDsgJ21pbmltdW1WYWx1ZScgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBzaG91bGQgYmUgc21hbGxlciB0aGFuICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIShpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHx8XHJcbiAgICAgICAgICAgIChpc0ludChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgb3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPj0gMCkgfHwgLy8gSWYgaW50ZWdlciBvcHRpb25cclxuICAgICAgICAgICAgKGlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiB0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSkgIC8vIElmIHN0cmluZyBvcHRpb25cclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlIGluIHRoZSBjb25zb2xlIGlmIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlIGlzIG92ZXJyaWRkZW4gYnkgZGVjaW1hbFBsYWNlc092ZXJyaWRlIChhbmQgbm90IGlmIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlKVxyXG4gICAgICAgIGNvbnN0IHZNaW5BbmRWTWF4TWF4aW11bURlY2ltYWxQbGFjZXMgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKG9wdGlvbnMubWluaW11bVZhbHVlLCBvcHRpb25zLm1heGltdW1WYWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIHZNaW5BbmRWTWF4TWF4aW11bURlY2ltYWxQbGFjZXMgIT09IE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcclxuICAgICAgICAgICAgd2FybmluZyhgU2V0dGluZyAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyB0byBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gYW5kICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgJiYgIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcclxuICAgICAgICAgICAgd2FybmluZyhgU2V0dGluZyAnYWxsb3dEZWNpbWFsUGFkZGluZycgdG8gW2ZhbHNlXSB3aWxsIG92ZXJyaWRlIHRoZSBjdXJyZW50ICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHNldHRpbmcgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XS5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmICghaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBudW1iZXIgb2YgZXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzIFwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c1wiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbm9ybWFsIGRlY2ltYWwgcGxhY2VzIFwiZGVjaW1hbFBsYWNlc092ZXJyaWRlXCJcclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmICFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkge1xyXG4gICAgICAgICAgICB3YXJuaW5nKGBUaGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c31dIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gdGhlICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gdmFsdWUuIEN1cnJlbnRseSwgdGhpcyB3aWxsIGxpbWl0IHRoZSBhYmlsaXR5IG9mIHlvdXIgY2xpZW50IHRvIG1hbnVhbGx5IGNoYW5nZSBzb21lIG9mIHRoZSBkZWNpbWFsIHBsYWNlcy4gRG8geW91IHJlYWxseSB3YW50IHRvIGRvIHRoYXQ/YCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURpdmlzb3IpICYmICF0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlci50ZXN0KG9wdGlvbnMuc2NhbGVEaXZpc29yKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgZGl2aXNvciBvcHRpb24gJ3NjYWxlRGl2aXNvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlciwgcHJlZmVyYWJseSBhbiBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGl2aXNvcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXMpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBudW1iZXIgb2YgZGVjaW1hbHMgb3B0aW9uICdzY2FsZURlY2ltYWxQbGFjZXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlc31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZVN5bWJvbCkgJiYgIWlzU3RyaW5nKG9wdGlvbnMuc2NhbGVTeW1ib2wpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBzeW1ib2wgb3B0aW9uICdzY2FsZVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5zY2FsZVN5bWJvbH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzYXZlIHRvIHNlc3Npb24gc3RvcmFnZSBvcHRpb24gJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2V9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMub25JbnZhbGlkUGFzdGUsIFtcclxuICAgICAgICAgICAgJ2Vycm9yJyxcclxuICAgICAgICAgICAgJ2lnbm9yZScsXHJcbiAgICAgICAgICAgICdjbGFtcCcsXHJcbiAgICAgICAgICAgICd0cnVuY2F0ZScsXHJcbiAgICAgICAgICAgICdyZXBsYWNlJyxcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGFzdGUgYmVoYXZpb3Igb3B0aW9uICdvbkludmFsaWRQYXN0ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2Vycm9yJywgJ2lnbm9yZScsICdjbGFtcCcsICd0cnVuY2F0ZScgb3IgJ3JlcGxhY2UnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMub25JbnZhbGlkUGFzdGV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucm91bmRpbmdNZXRob2QsIFtcclxuICAgICAgICAgICAgJ1MnLFxyXG4gICAgICAgICAgICAnQScsXHJcbiAgICAgICAgICAgICdzJyxcclxuICAgICAgICAgICAgJ2EnLFxyXG4gICAgICAgICAgICAnQicsXHJcbiAgICAgICAgICAgICdVJyxcclxuICAgICAgICAgICAgJ0QnLFxyXG4gICAgICAgICAgICAnQycsXHJcbiAgICAgICAgICAgICdGJyxcclxuICAgICAgICAgICAgJ04wNScsXHJcbiAgICAgICAgICAgICdDSEYnLFxyXG4gICAgICAgICAgICAnVTA1JyxcclxuICAgICAgICAgICAgJ0QwNScsXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJvdW5kaW5nIG1ldGhvZCBvcHRpb24gJ3JvdW5kaW5nTWV0aG9kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMucm91bmRpbmdNZXRob2R9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY29udHJvbCBkZWNpbWFsIHBhZGRpbmcgb3B0aW9uICdhbGxvd0RlY2ltYWxQYWRkaW5nJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIsIFsnKCwpJywgJ1ssXScsICc8LD4nLCAneyx9J10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBicmFja2V0cyBmb3IgbmVnYXRpdmUgdmFsdWVzIG9wdGlvbiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICcoLCknLCAnWyxdJywgJzwsPicgb3IgJ3ssfScsIFske29wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXJ9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2VtcHR5SW5wdXRCZWhhdmlvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycgb3IgJ3plcm8nLCBbJHtvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5sZWFkaW5nWmVybywgWydhbGxvdycsICdkZW55JywgJ2tlZXAnXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xlYWRpbmdaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxlYWRpbmdaZXJvfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGZvcm1hdCBvbiBpbml0aWFsaXphdGlvbiBvcHRpb24gJ2Zvcm1hdE9uUGFnZUxvYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5KSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc2VsZWN0TnVtYmVyT25seScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0TnVtYmVyT25seX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkgJiYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09ICcnICYmICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2RlZmF1bHRWYWx1ZU92ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByZW1vdmUgZm9ybWF0dGluZyBvbiBzdWJtaXQgb3B0aW9uICd1bmZvcm1hdE9uU3VibWl0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51bmZvcm1hdE9uU3VibWl0fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm91dHB1dEZvcm1hdCkgJiYgIWlzSW5BcnJheShvcHRpb25zLm91dHB1dEZvcm1hdCwgW1xyXG4gICAgICAgICAgICAnc3RyaW5nJyxcclxuICAgICAgICAgICAgJ251bWJlcicsXHJcbiAgICAgICAgICAgICcuJyxcclxuICAgICAgICAgICAgJy0uJyxcclxuICAgICAgICAgICAgJywnLFxyXG4gICAgICAgICAgICAnLSwnLFxyXG4gICAgICAgICAgICAnLi0nLFxyXG4gICAgICAgICAgICAnLC0nLFxyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dEZvcm1hdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgbnVsbCwgJ3N0cmluZycsICdudW1iZXInLCAnLicsICctLicsICcsJywgJy0sJywgJy4tJyBvciAnLC0nLCBbJHtvcHRpb25zLm91dHB1dEZvcm1hdH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ2ZhaWxPblVua25vd25PcHRpb24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmZhaWxPblVua25vd25PcHRpb259XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICQuZm4uYXV0b1ZhbGlkYXRlID0gdmFsaWRhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZSBhbiBhcmFiaWMgbnVtYmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gYSBqYXZhc2NyaXB0IG51bWJlci5cclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdHJ5IHRvIGNvbnZlcnQgdGhlIGFyYWJpYyBkZWNpbWFsIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVycy5cclxuICAgICAqIFRoaXMgcmV0dXJucyBgTmFOYCBpcyB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXHJcbiAgICAgKiBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzAyNTM5Mi8yODM0ODk4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyYWJpY051bWJlcnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuQU51bWJlciBJZiBgdHJ1ZWAsIHJldHVybiBhIE51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBhIFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZURlY2ltYWxDaGFyYWN0ZXJcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2VUaG91c2FuZFNlcGFyYXRvclxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ8TmFOfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcmFiaWNUb0xhdGluTnVtYmVycyhhcmFiaWNOdW1iZXJzLCByZXR1cm5BTnVtYmVyID0gdHJ1ZSwgcGFyc2VEZWNpbWFsQ2hhcmFjdGVyID0gZmFsc2UsIHBhcnNlVGhvdXNhbmRTZXBhcmF0b3IgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBhcmFiaWNOdW1iZXJzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gJycgfHwgcmVzdWx0Lm1hdGNoKC9b2aDZodmi2aPZpNml2abZp9mo2anbtNu127ZdL2cpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIEFyYWJpYy9QZXJzaWFuIG51bWJlcnMgYXJlIGZvdW5kLCByZXR1cm4gdGhlIG51bWVyaWMgc3RyaW5nIGRpcmVjdGx5XHJcbiAgICAgICAgICAgIHJldHVybiBhcmFiaWNOdW1iZXJzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlRGVjaW1hbENoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgv2asvLCAnLicpOyAvLyBEZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlVGhvdXNhbmRTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL9msL2csICcnKTsgLy8gVGhvdXNhbmQgc2VwYXJhdG9yXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBudW1iZXJzIG9ubHlcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW9mg2aHZotmj2aTZpdmm2afZqNmpXS9nLCBkID0+IGQuY2hhckNvZGVBdCgwKSAtIDE2MzIpIC8vIEFyYWJpYyBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1vbsNux27Lbs9u027Xbttu327jbuV0vZywgZCA9PiBkLmNoYXJDb2RlQXQoMCkgLSAxNzc2KTsgLy8gUGVyc2lhbiBudW1iZXJzXHJcblxyXG4gICAgICAgIC8vIGBOYU5gIGhhcyBwcmVjZWRlbmNlIG92ZXIgdGhlIHN0cmluZyBgJ05hTidgXHJcbiAgICAgICAgY29uc3QgcmVzdWx0QXNOdW1iZXIgPSBOdW1iZXIocmVzdWx0KTtcclxuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0QXNOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRBc051bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXR1cm5BTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdEFzTnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICogQnkgZGVmYXVsdCwgaWYgbm8gZWxlbWVudCBpcyBnaXZlbiwgdGhlIGV2ZW50IGlzIHRocm93biBmcm9tIGBkb2N1bWVudGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGVsZW1lbnQgPSBkb2N1bWVudCwgZGV0YWlsID0gbnVsbCkge1xyXG4gICAgICAgIGxldCBldmVudDtcclxuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIHsgZGV0YWlsIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXHJcbiAgICAgKi9cclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB2b2lkKDApIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcclxuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgJC5leHRlbmQodHJ1ZSwgZGVmYXVsdFNldHRpbmdzLCAkLmZuLmF1dG9OdW1lcmljLmxhbmcuVHVya2lzaCwgeyBjdXJyZW5jeVN5bWJvbDogJycgfSk7XHJcblxyXG4gICAgLy8gSGlqYWNrIHRoZSBvcmlnaW5hbCB2YWwgZm4gaW4gb3JkZXIgdG9cclxuICAgIC8vIHVzZSAkYXV0b051bWVyaWMudmFsKCkgYW5kIGJlIGFibGUgdG8gZ2V0L3NldFxyXG4gICAgLy8gdGhlIHVubWFza2VkIHZhbHVlLlxyXG4gICAgJC5mbi52YWwgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICBjb25zdCAkbWUgPSAkKG1lKTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhbiBpbnN0YW5jZSBvZiBhdXRvTnVtZXJpYyxcclxuICAgICAgICAvLyBzaW1wbHkgY2FsbCB0aGUgb3JpZ2luYWwgalF1ZXJ5LmZuLnZhbFxyXG4gICAgICAgIGlmICgkbWUuZGF0YSgnYXV0b051bWVyaWMnKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlPcmlnaW5hbFZhbC5hcHBseShtZSwgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBXZSdyZSB0cnlpbmcgdG8gcmVhZCB0aGUgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICAgICAgICByZXR1cm4gJG1lLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIFdlJ3JlIHRyeWluZyB0byBzZXQgYSB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFZhbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBsZXQgbnVtZXJpY1ZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLCcsICcuJyk7XHJcbiAgICAgICAgICAgICAgICBudW1lcmljVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWVyaWNWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgXCIke29yaWdpbmFsVmFsfVwiIGlzIG5vdCBhIG51bWJlci5gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGBUaGUgdHlwZSBcIiR7dHlwZW9mIHZhbHVlfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG51bWVyaWNWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gJG1lLmF1dG9OdW1lcmljKCdzZXQnLCBudW1lcmljVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGV4cG9ydHMgdGhlIGludGVyZmFjZSBmb3IgdGhlIGF1dG9OdW1lcmljIG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZm9ybWF0ICA6IGF1dG9Gb3JtYXQsXHJcbiAgICB1bkZvcm1hdDogYXV0b1VuRm9ybWF0LFxyXG4gICAgZ2V0RGVmYXVsdENvbmZpZyxcclxuICAgIGdldExhbmd1YWdlcyxcclxuICAgIHZhbGlkYXRlLCAvLyBhbi52YWxpZGF0ZShvcHRpb25zKSA6IHRocm93cyBpZiBuZWNlc3NhcnlcclxuICAgIGFyZVNldHRpbmdzVmFsaWQsIC8vIGFuLmFyZVNldHRpbmdzVmFsaWQob3B0aW9ucykgOiByZXR1cm4gdHJ1ZSBvciBmYWxzZSAvL1RPRE8gSXMgdGhpcyByZWR1bmRhbnQ/IFNob3VsZCB3ZSBsZXQgdGhlIGRldmVsb3BlcnMgd3JhcCBlYWNoIGF1dG9OdW1lcmljLnZhbGlkYXRlKCkgY2FsbHMgaW4gdHJ5L2NhdGNoIGJsb2NrPyBPciBzaG91bGQgd2UganVzdCBmYWNpbGl0YXRlIHRoZWlyIGxpZmUgYnkgZG9pbmcgaXQgYWxyZWFkeT9cclxuXHJcbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcclxuICAgIC8vaW5pdCAgICAgICAgIDogYW4uaW5pdChvcHRpb25zLCBpbnB1dClcclxuICAgIC8vZ2V0ICAgICAgICAgIDogYW4uZ2V0KGlucHV0KVxyXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxyXG4gICAgLy9mb3JtU3RyaW5nICAgOiBhbi5mb3JtU3RyaW5nKGZvcm0pXHJcbiAgICAvL2Zvcm1BcnJheSAgICA6IGFuLmZvcm1BcnJheShmb3JtKVxyXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXHJcbiAgICAvL3Vuc2V0ICAgICAgICA6IGFuLnVuc2V0KGlucHV0KSAvL3RvIHJlbmFtZSB0byAndW5mb3JtYXQnPyAoYW5kIG1lcmdlIHdpdGggYXV0b1VuRm9ybWF0L3VuRm9ybWF0PylcclxuICAgIC8vcmVmb3JtYXQgICAgIDogYW4ucmVmb3JtYXQoaW5wdXQpIC8vICdyZVNldCcgaXMgdmVyeSB0byBjbG9zZSB0byAncmVzZXQnIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHJlbmFtZWQuIFdlIGNvdWxkIHN0aWxsIGV4cG9zZSAncmVTZXQnLCBidXQgYWRkIGEgQGRlcHJlY2F0ZWQgdGFnIG9uIGl0cyBkZWNsYXJhdGlvbi5cclxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXHJcbiAgICAvL3VwZGF0ZSAgICAgICA6IGFuLnVwZGF0ZShvcHRpb25zLCBpbnB1dClcclxuICAgIC8vd2lwZSAgICAgICAgIDogYW4ud2lwZShpbnB1dClcclxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcclxuXHJcbiAgICAvL3JhdyAgICAgICAgICA6IGFuLnJhdyhpbnB1dCkgLy8gUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZ1xyXG4gICAgLy9udW1iZXIgICAgICAgOiBhbi5udW1iZXIoaW5wdXQpIC8vIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBudW1iZXIgKFdhcm5pbmc6IFRoaXMgY2FuIGxlYWQgdG8gcHJlY2lzaW9uIHByb2JsZW1zIHdpdGggYmlnIG51bWJlcnMpXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hdXRvTnVtZXJpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;