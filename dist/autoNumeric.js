(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n *               autoNumeric.js\r\n *\r\n * @version      2.0.12\r\n * @date         2017-04-07 UTC 07:00\r\n *\r\n * @author       Bob Knothe\r\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n *               cf. AUTHORS.md.\r\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n * @since        2009-08-09\r\n *\r\n * @summary      autoNumeric is a library that provides live as-you-type\r\n *               formatting for international numbers and currencies.\r\n *\r\n *               Note : Some functions are borrowed from big.js\r\n * @link         https://github.com/MikeMcl/big.js/\r\n *\r\n * Please report any bugs to https://github.com/autoNumeric/autoNumeric\r\n *\r\n * @license      Released under the MIT License\r\n * @link         http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar getLanguages = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\r\n * List of allowed tag on which autoNumeric can be used.\r\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\r\n * Defaults options are public - these can be overridden by the following method:\r\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" €\">`)\r\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' €' });`)\r\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n */\nvar defaultSettings = {\n    /* Allowed thousand grouping separator characters :\r\n     * ','      // Comma\r\n     * '.'      // Dot\r\n     * ' '      // Normal space\r\n     * '\\u2009' // Thin-space\r\n     * '\\u202f' // Narrow no-break space\r\n     * '\\u00a0' // No-break space\r\n     * ''       // No separator\r\n     * \"'\"      // Apostrophe\r\n     * '٬'      // Arabic thousands separator\r\n     * '˙'      // Dot above\r\n     * Deprecated older option name : aSep\r\n     */\n    digitGroupSeparator: ',',\n\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n     * example if the input value \"$ 1,999.88 suffix\"\r\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n     * Deprecated older option name : nSep\r\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\r\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n     * Deprecated older option name : dGroup\r\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters :\r\n     * ',' : Comma\r\n     * '.' : Dot\r\n     * '·' : Middle-dot\r\n     * '٫' : Arabic decimal separator\r\n     * '⎖' : Decimal separator key symbol\r\n     * Deprecated older option name : aDec\r\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n     * Deprecated older option name : altDec\r\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\r\n     * Must be in quotes currencySymbol: \"$\"\r\n     * space to the right of the currency symbol currencySymbol: '$ '\r\n     * space to the left of the currency symbol currencySymbol: ' $'\r\n     * Deprecated older option name : aSign\r\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n     * for prefix currencySymbolPlacement: \"p\" (default)\r\n     * for suffix currencySymbolPlacement: \"s\"\r\n     * Deprecated older option name : pSign\r\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n     * -1,234.56  => default no options required\r\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n     * Deprecated older option name : pNeg\r\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    negativePositiveSignPlacement: null,\n\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n     * By default, this positive sign is not shown.\r\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n     */\n    showPositiveSign: false,\n\n    /* Additional suffix\r\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n     * Numeric characters and negative sign not allowed'\r\n     * Deprecated older option name : aSuffix\r\n     */\n    suffixText: '',\n\n    /* Override min max limits\r\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n     * Deprecated older option name : oLimits\r\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be larger than minimumValue\r\n     * Deprecated older option name : vMax\r\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be smaller than maximumValue\r\n     * Deprecated older option name : vMin\r\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n     * Deprecated older option name : mDec\r\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\r\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n     * the \"get\" method returns the extended decimal places\r\n     * Deprecated older option name : eDec\r\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n     */\n    scaleDivisor: null,\n\n    /*\r\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n     * Deprecated older option name : scaleDecimal\r\n     */\n    scaleDecimalPlaces: null,\n\n    /*\r\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n     * This is optional too.\r\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n     * if ie 6 or 7 the value will be saved as a session cookie\r\n     * Deprecated older option name : aStor\r\n     */\n    saveValueToSessionStorage: false,\n\n    /*\r\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n     *                The non-pasted numbers are dropped and therefore not used at all.\r\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n     *\r\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n     *          Only the first number will be used (here '123').\r\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\r\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n     * roundingMethod: \"U05\" Rounds up to next .05\r\n     * roundingMethod: \"D05\" Rounds down to next .05\r\n     * Deprecated older option name : mRound\r\n     */\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\n    roundingMethod: 'S',\n\n    /* Allow padding the decimal places with zeros\r\n     * allowDecimalPadding: true - always Pad decimals with zeros\r\n     * allowDecimalPadding: false - does not pad with zeros.\r\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n     *\r\n     * thanks to Jonas Johansson for the suggestion\r\n     * Deprecated older option name : aPad\r\n     */\n    allowDecimalPadding: true,\n\n    /*\r\n     * If true, all text within the input will automatically be\r\n     * selected when input gets focus and the value is equal to zero.\r\n     */\n    selectAllOnFocusIfZero: false,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n     * Those brackets are visible only when the field does NOT have the focus.\r\n     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n     * This option can be of the following values :\r\n     * null, // This is the default value, which deactivate this feature\r\n     * '(,)',\r\n     * '[,]',\r\n     * '<,>' or\r\n     * '{,}'\r\n     * Deprecated older option name : nBracket\r\n     */\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\r\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n     * Deprecated older option name : wEmpty\r\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\r\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n     * Deprecated older option name : lZero\r\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\r\n     * true = automatically formats the default value on initialization\r\n     * false = will not format the default value on initialization\r\n     * Deprecated older option name : aForm\r\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n     * Deprecated older option name : sNumber\r\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\r\n     * should be the value of the unformatted default value\r\n     * examples:\r\n     * no default value=\"\" {defaultValueOverride: \"\"}\r\n     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n     * Deprecated older option name : anDefault\r\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\r\n     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n     * review the 'unSet' method for other formats\r\n     * Deprecated older option name : unSetOnSubmit\r\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n     * Deprecated older option name : outputType\r\n     */\n    outputFormat: null,\n\n    /* Defines if warnings should be shown\r\n     * Error handling function\r\n     * true => all warning are shown\r\n     * false => no warnings are shown, only the thrown errors\r\n     * Deprecated older option name : debug\r\n     */\n    showWarnings: true,\n\n    /*\r\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n     */\n    failOnUnknownOption: false\n};\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n * //TODO Replace every call to this object with a call to `keyName`\r\n * @deprecated\r\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224,\n    AndroidDefault: 229 };\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n * Those names are listed here :\r\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n */\nvar keyName = {\n    // Special values\n    Unidentified: 'Unidentified',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta', // The Windows, Command or ⌘ key // 'OS' under Firefox and IE9\n    Windows: 'Meta', // This is a non-official key name\n    Command: 'Meta', // This is a non-official key name\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageDown: 'PageDown',\n    PageUp: 'PageUp',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    MultiplyNumpad: '*',\n    PlusNumpad: '+',\n    MinusNumpad: '-',\n    DotNumpad: '.',\n    SlashNumpad: '/',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\",\n    NumpadDot: '.',\n    NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n    NumpadMultiply: '*',\n    NumpadPlus: '+',\n    NumpadMinus: '-',\n    NumpadSlash: '/',\n    NumpadDotObsoleteBrowsers: 'Decimal',\n    NumpadMultiplyObsoleteBrowsers: 'Multiply',\n    NumpadPlusObsoleteBrowsers: 'Add',\n    NumpadMinusObsoleteBrowsers: 'Subtract',\n    NumpadSlashObsoleteBrowsers: 'Divide'\n};\n\nvar defaultMinimumValue = '-999999999999.99';\nvar defaultMaximumValue = '999999999999.99';\nvar defaultRoundingMethod = 'U';\nvar defaultLeadingZero = 'deny';\nvar defaultSelectNumberOnly = true;\n\n/**\r\n * Predefined options for the most common languages\r\n */\nvar languageOption = {\n    French: { // Français\n        digitGroupSeparator: '.', // or '\\u202f'\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: '\\u202F\\u20AC',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    NorthAmerican: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '$',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    British: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '£',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Swiss: { // Suisse\n        digitGroupSeparator: '\\'',\n        decimalCharacter: '.',\n        currencySymbol: '\\u202FCHF',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Japanese: { // 日本語\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '¥',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Turkish: {\n        digitGroupSeparator: '.',\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: ' ₺',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue,\n        negativePositiveSignPlacement: 'p'\n    }\n};\nlanguageOption.Spanish = languageOption.French; // Español (idem French)\nlanguageOption.Chinese = languageOption.Japanese; // 中国語 (Chinese)\n\n/**\r\n * UMD structure\r\n */\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    var jQueryOriginalVal = $.fn.val;\n\n    // Helper functions\n\n    /**\r\n     * Return TRUE if the `value` is null\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\r\n     * Return TRUE if the given parameter is a String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a boolean\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string 'true' or 'false'\r\n     *\r\n     * This function accepts any cases for those strings.\r\n     * @param {string} value\r\n     * @returns {boolean}\r\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an object\r\n     *\r\n     * @param {*} reference\r\n     * @returns {boolean}\r\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\r\n     * Return TRUE if the given object is empty\r\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n     *\r\n     * @param {object} obj\r\n     * @returns {boolean}\r\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a number (or a number written as a string).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an integer (and not a float).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\r\n     * Return the pasted text that will be used.\r\n     *\r\n     * @param {string} text\r\n     * @param {AutoNumericHolder} holder\r\n     * @returns {string|void|XML|*}\r\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {*} needle\r\n     * @param {Array} array\r\n     * @returns {boolean}\r\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n     *\r\n     * @param {string} str\r\n     * @returns {boolean}\r\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\r\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n     *\r\n     * @param {string} str\r\n     * @returns {int}\r\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\r\n     * Return the code for the key used to generate the given event.\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string|Number}\r\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\r\n     * Return the character from the event key code.\r\n     * @example character(50) => '2'\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string}\r\n     */\n    function character(event) {\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n            return String.fromCharCode(keyCodeNumber(event));\n        } else {\n            // Special case for obsolete browsers like IE that return the old names\n            var result = void 0;\n            switch (event.key) {\n                case 'Decimal':\n                    result = keyName.NumpadDot;\n                    break;\n                case 'Multiply':\n                    result = keyName.NumpadMultiply;\n                    break;\n                case 'Add':\n                    result = keyName.NumpadPlus;\n                    break;\n                case 'Subtract':\n                    result = keyName.NumpadMinus;\n                    break;\n                case 'Divide':\n                    result = keyName.NumpadSlash;\n                    break;\n                case 'Del':\n                    // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401 //FIXME à terminer\n                    result = keyName.Dot; // as of version 2.0.8 the character() function is only called on keypress event. The 'Del' does not throw the keypress event.\n                    break;\n                default:\n                    result = event.key;\n            }\n\n            return result;\n        }\n    }\n\n    /**\r\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n     * @returns {boolean}\r\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\r\n     * Return TRUE if the given string contains a negative sign :\r\n     * - everywhere in the string (by default), or\r\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n     *\r\n     * @param {string} numericString A number represented by a string\r\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n     * @returns {boolean}\r\n     */\n    function isNegative(numericString) {\n        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        //TODO Use the `negativeSignCharacter` from the settings here\n        if (checkEverywhere) {\n            return contains(numericString, '-');\n        }\n\n        return isNegativeStrict(numericString);\n    }\n\n    /**\r\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n     *\r\n     * @example isNegativeStrict('1234.56')     => false\r\n     * @example isNegativeStrict('1234.56-')    => false\r\n     * @example isNegativeStrict('-1234.56')    => true\r\n     * @example isNegativeStrict('-1,234.56 €') => true\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\n    function isNegativeStrict(numericString) {\n        //TODO Using the `negativeSignCharacter` from the settings here\n        return numericString.charAt(0) === '-';\n    }\n\n    /**\r\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 €'), or is empty (' €').\r\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\n    function isZeroOrHasNoValue(numericString) {\n        return !/[1-9]/g.test(numericString);\n    }\n\n    /**\r\n     * Return the negative version of the value (represented as a string) given as a parameter.\r\n     *\r\n     * @param {string} value\r\n     * @returns {*}\r\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegativeStrict(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\r\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n     *\r\n     * @param {string} string\r\n     * @param {int} index\r\n     * @param {string} newCharacter\r\n     * @returns {string}\r\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\r\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} settings\r\n     * @returns {number}\r\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\r\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n     *\r\n     * @param {string} formattedNumberString\r\n     * @param {int} caretPosition This must be a positive integer\r\n     * @param {string} decimalCharacter\r\n     * @returns {number}\r\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\r\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n     *\r\n     * @example\r\n     * 1234567|89.01   : position 7 (rawNumberString)\r\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n     *\r\n     * @param {string} rawNumberString\r\n     * @param {int} caretPositionInRawValue\r\n     * @param {string} formattedNumberString\r\n     * @param {string} decimalCharacter\r\n     * @returns {*}\r\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\r\n     * Count the number of occurrence of the given character, in the given text.\r\n     *\r\n     * @param {string} character\r\n     * @param {string} text\r\n     * @returns {number}\r\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\r\n     * Return the index that can be used to set the caret position.\r\n     * This takes into account that the position is starting at '0', not 1.\r\n     *\r\n     * @param {int} characterCount\r\n     * @returns {number}\r\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @returns {{}}\r\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @param {int} start\r\n     * @param {int|null} end\r\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\r\n     * Function that throw error messages\r\n     *\r\n     * @param {string} message\r\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\r\n     * Function that display a warning messages, according to the debug level.\r\n     *\r\n     * @param {string} message\r\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\r\n     * Run any callbacks found in the settings object.\r\n     * Any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\r\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n     *\r\n     * @param {string} minimumValue\r\n     * @param {string} maximumValue\r\n     * @returns {number}\r\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\r\n     * Strip all unwanted non-number characters.\r\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} leftOrAll\r\n     * @returns {string|*}\r\n     */\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n        //TODO Refactor this with `convertToNumericString()` if possible?\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Sets or removes brackets on negative values, depending on the focus state.\r\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n     * //TODO Use another object to keep track of internal data that are not settings\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            //TODO Split the first and last bracket only once during the settings initialization\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.hasFocus) {\n                // Add brackets\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n                // Remove brackets\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n     *\r\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n     * Lastly, it also put the negative sign back to its normal position if needed.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string|void|XML|*}\r\n     */\n    function convertToNumericString(s, settings) {\n        // Remove the currency symbol\n        s = s.replace(settings.currencySymbol, '');\n\n        // Remove the grouping separators (thousands separators usually)\n        s = s.replace(settings.digitGroupSeparator, '');\n\n        // Replace the decimal character by a dot\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n\n        // Move the trailing negative sign to the right position, if any\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        // Convert any arabic numbers to latin ones\n        var temp = arabicToLatinNumbers(s, true, false, false);\n        if (!isNaN(temp)) {\n            s = temp.toString();\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n     * See the \"outputFormat\" option definition for more details.\r\n     *\r\n     * @param {string|null} value\r\n     * @param {string} locale\r\n     * @returns {*}\r\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is not formatted with decimals\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Private function to check for empty value\r\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @param {boolean} signOnEmpty\r\n     * @returns {*}\r\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Modify the input value by adding the group separators, as defined in the settings.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n        if (settings.trailingNegative && !isNegative(inputValue)) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isValueNegative = isNegative(inputValue);\n        var isZero = isZeroOrHasNoValue(inputValue);\n        if (isValueNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        settings.trailingNegative = false;\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\r\n     * Truncate not needed zeros\r\n     *\r\n     * @param {string} roundedInputValue\r\n     * @param {int} temporaryDecimalPlacesOverride\r\n     * @returns {void|XML|string|*}\r\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\r\n     * Round the input value using the rounding method defined in the settings.\r\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n     *\r\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (isNegativeStrict(inputValue)) {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\r\n     * Truncates the decimal part of a number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} isPaste\r\n     * @returns {*}\r\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {number|string} n A numeric value.\r\n     * @returns {{}}\r\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (isNegativeStrict(n)) {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings.\r\n     * This uses the parsed strings for the above parseStr function.\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {object} y Big number instance\r\n     * @param {object} x Big number instance\r\n     * @returns {*}\r\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Check that the number satisfy the format conditions\r\n     * and lays between settings.minimumValue and settings.maximumValue\r\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Thanks to Anthony & Evan C\r\n     *\r\n     * @param {Element|string} element\r\n     * @returns {*|jQuery|HTMLElement}\r\n     */\n    function getCurrentElement(element) {\n        /*\r\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n         * for jQuery to be able to parse the selector correctly.\r\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\r\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     * @param {boolean} update\r\n     * @returns {*}\r\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\r\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\r\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n     * This is taken from Quirksmode.\r\n     *\r\n     * @param {string} name\r\n     * @returns {*}\r\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Test if sessionStorage is supported.\r\n     * This is taken from Modernizr.\r\n     *\r\n     * @returns {boolean}\r\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\r\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function cleanLeadingTrailingZeros(value, settings) {\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n        if (value === '') {\n            return '';\n        }\n\n        // Return '0' if the value is zero\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n            return '0';\n        }\n\n        if (settings.leadingZero !== 'keep') {\n            // Trim leading zero's - leaves one zero to the left of the decimal point\n            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n            if (contains(value, '.')) {\n                // Trims trailing zeros after the decimal point\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n        }\n        // Strips trailing decimal point\n        value = value.replace(/\\.$/, '');\n\n        return value;\n    }\n\n    /**\r\n     * Remove the trailing zeros in the decimal part of a number.\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {*}\r\n     */\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\n        var _numericString$split = numericString.split('.'),\n            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n            integerPart = _numericString$split2[0],\n            decimalPart = _numericString$split2[1];\n\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n            return integerPart;\n        }\n\n        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n        var result = void 0;\n        if (trimmedDecimalPart === '') {\n            result = integerPart;\n        } else {\n            result = integerPart + '.' + trimmedDecimalPart;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n     *\r\n     * @param {Element|EventTarget} element\r\n     * @param {object} settings\r\n     * @param {string} action\r\n     * @returns {*}\r\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Holder object for field properties\r\n     */\n\n    var AutoNumericHolder = function () {\n        /**\r\n         * Class constructor\r\n         *\r\n         * @param {HTMLElement} that - A reference to the current DOM element\r\n         * @param {object} settings\r\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\r\n         * Update the value and the selection values inside the AutoNumericHolder object.\r\n         * This keeps tracks of the input value, as well as the current selection.\r\n         * This also resets the 'processed' and 'formatted' state.\r\n         *\r\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n         *        this function is called on each event handler.\r\n         *\r\n         * @private\r\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateAutoNumericHolderProperties',\n            value: function _updateAutoNumericHolderProperties() {\n                this.value = this.that.value;\n                this.selection = getElementSelection(this.that);\n                this.processed = false;\n                this.formatted = false;\n            }\n\n            /**\r\n             * Update the keycode of the key that triggered the given event.\r\n             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n             *\r\n             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n             * e.key describe the key name used to trigger the event.\r\n             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n             * The key list is described here\r\n             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n             *\r\n             * @param {Event} e\r\n             * @private\r\n             */\n\n        }, {\n            key: '_updateAutoNumericHolderEventKeycode',\n            value: function _updateAutoNumericHolderEventKeycode(e) {\n                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n                this.eventKeyCode = keyCodeNumber(e);\n            }\n\n            /**\r\n             * Set the text selection inside the input with the given start and end position.\r\n             *\r\n             * @param {int} start\r\n             * @param {int} end\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\r\n             * Set the caret position inside the input at the given position.\r\n             *\r\n             * @param {int} pos\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\r\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n             *\r\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\r\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n             * Those parts are unformatted (stripped) of any non-numbers characters.\r\n             *\r\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                if (left === '' && right === '') {\n                    settingsClone.trailingNegative = false;\n                }\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                    settingsClone.trailingNegative = false;\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Strip parts from excess characters and leading zeros.\r\n             *\r\n             * @param {string} left\r\n             * @param {string} right\r\n             * @returns {[*,*]}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n             *\r\n             * @param {string} left\r\n             * @param {string} right\r\n             * @param {boolean} isPaste\r\n             * @returns {boolean}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n                    } else {\n                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\r\n             * Helper function for `_expandSelectionOnSign()`.\r\n             *\r\n             * @returns {*} Sign position of a formatted value\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\r\n             * Expands selection to cover whole sign\r\n             * Prevents partial deletion/copying/overwriting of a sign\r\n             *\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\r\n             * Try to strip pasted value to digits\r\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // Try to strip the pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\r\n             * Process pasting, cursor moving and skipping of not interesting keys.\r\n             * If this function returns TRUE, then further processing is not performed.\r\n             *\r\n             * @param {Event} e\r\n             * @returns {boolean}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n                    //TODO Move this test inside the `onKeyup` handler\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !isNegative(this.that.value) ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // Try to prevent wrong paste\n                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n                }\n\n                if (e.ctrlKey || e.metaKey) {\n                    return true;\n                }\n\n                // Jump over thousand separator\n                //TODO Move this test inside the `onKeydown` handler\n                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                    if (e.type === 'keydown' && !e.shiftKey) {\n                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start - 1);\n                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n            }\n\n            /**\r\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n             *\r\n             * @param {string} left The part on the left of the caret or selection\r\n             * @param {string} right The part on the right of the caret or selection\r\n             * @returns {[string, string]}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Process the deletion of characters.\r\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.eventKeyCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\r\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n             * Returns TRUE if the keycode is allowed.\r\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n             *\r\n             * @param {Event|string} eventOrChar The event object, or the character entered (from an android device)\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion(eventOrChar) {\n                var settingsClone = this.settingsClone;\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                var eventCharacter = void 0;\n                if (isString(eventOrChar)) {\n                    // Android browsers\n                    eventCharacter = eventOrChar;\n                } else {\n                    // Normal browsers\n                    settingsClone.throwInput = true;\n\n                    // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n                    eventCharacter = character(eventOrChar);\n                }\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If the user tries to insert digit before minus sign\n                var eventNumber = Number(eventCharacter);\n                if (eventNumber >= 0 && eventNumber <= 9) {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + eventCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\r\n             * Formatting of just processed value while keeping the cursor position\r\n             *\r\n             * @param {Event} e\r\n             * @private\r\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (isNegative(subParts)) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (_this.eventKeyCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If the positive sign is shown, calculate the caret position accordingly\n                        if (settingsClone.showPositiveSign) {\n                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n                            }\n\n                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n                                position = settingsClone.currencySymbol.length + 1;\n                            }\n                        }\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                if (settingsClone.androidSelectionStart !== null) {\n                    // If an Android browser is detected, fix the caret position\n                    // Unfortunately this does not fix all android browsers, only Android Chrome currently.\n                    // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\n                    this._setCaretPosition(settingsClone.androidSelectionStart);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @param {HTMLElement} that - A reference to the current DOM element\r\n     * @returns {*}\r\n     * @private\r\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = scIndex.indexOf(i);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\r\n     * Handler for 'focusin' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.hasFocus = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                jQueryOriginalVal.call($this, toggleNegativeBracket(e.target.value, settings));\n            }\n\n            // clean the value to compare to rawValue\n            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n            result = convertToNumericString(result, settings);\n            result = cleanLeadingTrailingZeros(result, settings);\n            if (settings.trailingNegative) {\n                result = '-' + result;\n            }\n\n            var roundedValue = void 0;\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = Number(settings.oDec);\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (result !== settings.rawValue) {\n                // updates the rawValue\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                jQueryOriginalVal.call($this, onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'keydown' events.\r\n     * The user just started pushing any key, hence one event is sent.\r\n     *\r\n     * Note :\r\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n     * - keydown\r\n     * - keypress\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * ...when inputting a modifier key (ie. 'ctrl') :\r\n     * - keydown\r\n     * - keyup\r\n     *\r\n     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - change\r\n     * - keyup\r\n     *\r\n     * When a paste is done, the following events are sent :\r\n     * - input (if paste is done with the mouse)\r\n     *\r\n     * - keydown (if paste is done with ctrl+v)\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     * - keyup\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\r\n     * Handler for 'keypress' events.\r\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onKeypress(holder, e) {\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n        var eventCharacter = character(e);\n\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (eventCharacter === keyName.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n                    var position = getElementSelection(e.target).start + 1;\n                    setElementSelection(e.target, position, position);\n                }\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\r\n     * Handler for 'input' events.\r\n     * added to support android devices with mobile chrome browsers and others\r\n     * Has the potential to replace the keypress event.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onInput(holder, e) {\n        var value = e.target.value;\n\n        // Fix the caret position on keyup in the `_formatValue()` function\n        holder.settings.androidSelectionStart = null;\n\n        if (holder.eventKeyCode === keyCode.AndroidDefault) {\n            // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\n            if (value.length > holder.lastVal.length || value.length >= holder.lastVal.length - holder.selection.length) {\n                // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\n                holder.eventKeyCode = value.charCodeAt(holder.selection.start);\n\n                // Capture the actual character entered\n                var androidCharEntered = value.charAt(holder.selection.start);\n\n                // Check if the given character should be inserted, and if so, do insert it into the current element value\n                var isCharacterInsertionAllowed = holder._processCharacterInsertion(androidCharEntered);\n\n                if (isCharacterInsertionAllowed) {\n                    // Allowed character entered (number, decimal or plus/minus sign)\n                    holder._formatValue(e);\n\n                    // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\n                    //TODO Check if this is an Android bug or an autoNumeric one\n                    holder.settings.androidSelectionStart = holder.selection.start;\n\n                    var decimalCharacterPosition = e.target.value.indexOf(holder.settings.decimalCharacter);\n                    var hasDecimalCharacter = decimalCharacterPosition === -1;\n\n                    // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\n                    if (androidCharEntered === holder.settings.decimalCharacter || !hasDecimalCharacter && decimalCharacterPosition < holder.settings.androidSelectionStart) {\n                        holder.settings.androidSelectionStart = holder.selection.start + 1;\n                    }\n\n                    if (e.target.value.length > value.length) {\n                        // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\n                        setElementSelection(e.target, holder.settings.androidSelectionStart, holder.settings.androidSelectionStart);\n                    }\n\n                    holder.lastVal = e.target.value;\n\n                    return;\n                } else {\n                    // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\n                    e.target.value = holder.lastVal;\n                    setElementSelection(e.target, holder.selection.start, holder.selection.end);\n                    holder.settings.androidSelectionStart = holder.selection.start;\n                }\n\n                e.preventDefault(); //FIXME How does that affects the normal trigger of the input event?\n\n                holder.formatted = false;\n            } else {\n                // Character deleted\n                //TODO What about the `Delete` key?\n                holder.eventKeyCode = keyCode.Backspace;\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'keyup' events.\r\n     * The user just released any key, hence one event is sent.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {object} settings\r\n     * @param {Event} e\r\n     */\n    function _onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        var isOnAndroid = holder.settingsClone.androidSelectionStart !== null;\n        if (skip && !isOnAndroid || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\r\n     * Handler for 'focusout' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.hasFocus = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative && !isNegative(value)) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? Number(settings.scaleDecimalPlaces) : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                jQueryOriginalVal.call($this, groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'paste' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function _onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegativeStrict(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\n        var pastedText = void 0;\n        if (untranslatedPastedText === '.') {\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n            pastedText = '.';\n        } else {\n            // Normal case\n            // Allow pasting arabic numbers\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n        }\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = void 0;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        var leftPartContainedADot = false;\n        var leftPart = void 0;\n        var rightPart = void 0;\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\r\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n             * Otherwise paste all the numbers in the clipboard.\r\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n             *\r\n             * 4b. Replace paste behavior:\r\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                if (leftPartContainedADot) {\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                    caretPositionOnInitialTextAfterPasting--;\n                }\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\r\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // 1. Generate the unformatted result\n                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // Generate the unformatted result\n                result = '' + leftPart + pastedText + rightPart;\n\n                // 2. Calculate the caret position in the unformatted value, for later use\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, then the caret position is set after the pasted text\n                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else if (rightPart === '') {\n                        // If the user selected from the caret position to the end of the input (on the far right)\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                    }\n                }\n\n                // Modify the caret position for special cases, only if the whole input has not been selected\n                if (!isAllInputTextSelected) {\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        caretPositionOnInitialTextAfterPasting++;\n                    }\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\r\n         * If 'error' (this is the default) :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'ignore' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, do nothing more.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'clamp' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n         *        paste result.\r\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n         * If 'truncate' :\r\n         *      - Truncate paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         * If 'replace' :\r\n         *      - Replace paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\r\n     * Handler for 'submit' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    jQueryOriginalVal.call($this, $settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\r\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @returns {boolean|*}\r\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\r\n     * Formats the default value on page load.\r\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n     *\r\n     * @param {object} settings\r\n     * @param {object} $input jQuery-selected <input> element\r\n     * @param {object} $this jQuery-selected DOM element\r\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = jQueryOriginalVal.call($this);\n            /*\r\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n             *\r\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n             * we should ignore `defaultValueOverride` altogether.\r\n             */\n            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup oDec\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\r\n                 * - page reload from back button, and\r\n                 * - ASP.net form post back\r\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                 */\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.hasFocus = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n                        } else {\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n                        }\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        jQueryOriginalVal.call($this, settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\r\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n     *\r\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n     *\r\n     * @param {object} settings\r\n     */\n    function correctNegativePositiveSignPlacementOption(settings) {\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\n        if (!isNull(settings.negativePositiveSignPlacement)) {\n            return;\n        }\n\n        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 €\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n                    break;\n                default:\n                //\n            }\n        } else {\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\n            settings.negativePositiveSignPlacement = 'l';\n        }\n    }\n\n    /**\r\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n     *\r\n     * @param {object} settings\r\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\r\n     * Modify `decimalPlacesOverride` as needed\r\n     *\r\n     * @param {object} settings\r\n     */\n    function correctDecimalPlacesOverrideOption(settings) {\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\r\n     * Sets the alternative decimal separator key.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\r\n     * Caches regular expressions for stripAllNonNumberCharacters\r\n     *\r\n     * @param {object} settings\r\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var allNumbersReg = '[0-9]';\n        var noAllNumbersReg = '[^0-9]';\n\n        // Test if there is a negative character in the string\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n\n        var negativeSignRegPart = void 0;\n        if (settings.negativeSignCharacter) {\n            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n        } else {\n            negativeSignRegPart = '';\n        }\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n    }\n\n    /**\r\n     * Modify the user settings to make them 'exploitable' later.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\r\n     * Convert the old settings options name to new ones.\r\n     *\r\n     * @param {object} options\r\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            showPositiveSign: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            selectAllOnFocusIfZero: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            hasFocus: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            positiveSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n     *\r\n     * @param {object} options\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n     * @returns {object|null}\r\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    hasFocus: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    androidSelectionStart: null,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctNegativePositiveSignPlacementOption(settings);\n\n            // Set the negative and positive signs, as needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctDecimalPlacesOverrideOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\r\n     * Convert the `value` parameter that can either be :\r\n     * - a real number,\r\n     * - a string representing a real number, or\r\n     * - a string representing a localized number (with specific group separators and decimal character),\r\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n     *\r\n     * This function returns `NaN` if such conversion fails.\r\n     *\r\n     * @param {int|float|string} value\r\n     * @param {object} settings\r\n     * @returns {string|NaN}\r\n     */\n    function toNumericValue(value, settings) {\n        var result = void 0;\n        if (isNumber(Number(value))) {\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n            result = value;\n        } else {\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\n            result = convertToNumericString(value.toString(), settings);\n\n            // If the result is still not a numeric string, then we throw a warning\n            if (!isNumber(Number(result))) {\n                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                result = NaN;\n            }\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\n    var methods = {\n        /**\r\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var _this2 = this;\n\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input && $this.data('initialized') !== true) {\n                    (function () {\n                        var eventHandlers = {\n                            onFocusInAndMouseEnter: function onFocusInAndMouseEnter(e) {\n                                _onFocusInAndMouseEnter($this, holder, e);\n                            },\n                            onFocusOutAndMouseLeave: function onFocusOutAndMouseLeave(e) {\n                                _onFocusOutAndMouseLeave($this, holder, e);\n                            },\n                            onKeydown: function onKeydown(e) {\n                                _onKeydown(holder, e);\n                            },\n                            onKeypress: function onKeypress(e) {\n                                _onKeypress(holder, e);\n                            },\n                            onInput: function onInput(e) {\n                                _onInput(holder, e);\n                            },\n                            onKeyup: function onKeyup(e) {\n                                _onKeyup(holder, settings, e);\n                            },\n                            onPaste: function onPaste(e) {\n                                _onPaste($this, holder, e);\n                            },\n                            onJqFocus: function onJqFocus() {\n                                if (settings.selectAllOnFocusIfZero && $this.autoNumeric('getNumber') === 0) {\n                                    setTimeout(function () {\n                                        return $this.select();\n                                    }, 0);\n                                }\n                            }\n                        };\n                        var eventConfigs = [{ name: 'focusin', handler: eventHandlers.onFocusInAndMouseEnter }, { name: 'mouseenter', handler: eventHandlers.onFocusInAndMouseEnter }, { name: 'blur', handler: eventHandlers.onFocusOutAndMouseLeave }, { name: 'mouseleave', handler: eventHandlers.onFocusOutAndMouseLeave }, { name: 'keydown', handler: eventHandlers.onKeydown }, { name: 'keypress', handler: eventHandlers.onKeypress }, { name: 'input', handler: eventHandlers.onInput }, { name: 'keyup', handler: eventHandlers.onKeyup }, { name: 'paste', handler: eventHandlers.onPaste }];\n\n                        eventConfigs.forEach(function (eventConfig) {\n                            return _this2.addEventListener(eventConfig.name, eventConfig.handler, false);\n                        });\n\n                        onSubmit($this, holder); //TODO Switch to `addEventListener'\n\n                        $this.on('focus', eventHandlers.onJqFocus);\n\n                        $this.data({\n                            initialized: true,\n                            misc: {\n                                removeAllEvents: function removeAllEvents(el) {\n                                    eventConfigs.forEach(function (eventConfig) {\n                                        return el.removeEventListener(eventConfig.name, eventConfig.handler, false);\n                                    });\n\n                                    $(el).off('focus', eventHandlers.onJqFocus);\n\n                                    $(el).closest('form').off('.autoNumeric');\n                                }\n                            }\n                        });\n                    })();\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to stop and remove autoNumeric for the current element.\r\n         * Note: this does not remove the formatting.\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n         *\r\n         * @param {Boolean} clearValue If TRUE, then this function clears the text box upon destruction.\r\n         * @returns {*|jQuery}\r\n         */\n        destroy: function destroy() {\n            var clearValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    jQueryOriginalVal.call($this, clearValue === true ? '' : $this.autoNumeric('get'));\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.data('misc').removeAllEvents(this);\n                    $this.removeData('autoNumeric', 'initialized', 'removeAllEvents');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    jQueryOriginalVal.call($this, '');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method that updates the autoNumeric settings.\r\n         * It can be called multiple times if needed.\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '}).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|jQuery}\r\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                // Retrieve the current unformatted input value\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n\n                // Update the settings\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                // Reformat the input value with the new settings\n                if (jQueryOriginalVal.call($this) !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         *\r\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n         *\r\n         * @param {*} newValue\r\n         * @returns {*|jQuery}\r\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n                }\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n                settings.trailingNegative = false;\n\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                var value = toNumericValue(newValue, settings);\n                if (isNaN(value)) {\n                    return jQueryOriginalVal.call($this, '');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n                    // This test is needed by the showPositiveSign option\n\n\n                    var isZero = isZeroOrHasNoValue(value);\n                    if (isZero) {\n                        value = '0';\n                    }\n\n                    if (minTest && maxTest) {\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            // to ensure rounding does not happen twice\n                            var hasBeenRounded = false;\n\n                            // rounds the the extended decimal places\n                            var tempDecimal = void 0;\n                            if (settings.decimalPlacesShownOnFocus) {\n                                tempDecimal = settings.decimalPlacesOverride;\n                                settings.decimalPlacesOverride = Number(settings.decimalPlacesShownOnFocus);\n                                value = roundValue(value, settings);\n                                hasBeenRounded = true;\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = roundValue(value, settings);\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                                value = toNumericValue(value, settings);\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                if (settings.scaleDecimalPlaces) {\n                                    tempDecimal = settings.decimalPlacesOverride;\n                                    settings.decimalPlacesOverride = Number(settings.scaleDecimalPlaces);\n                                    value = roundValue(value, settings);\n                                    hasBeenRounded = true;\n                                }\n                            }\n\n                            // Rounds if this has not been done already\n                            if (!hasBeenRounded) {\n                                value = roundValue(value, settings);\n                            }\n\n                            // Stores rawValue including the decimalPlacesShownOnFocus\n                            if (!settings.scaleDivisor) {\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n\n                            if (settings.scaleDivisor && settings.scaleDecimalPlaces && !settings.onOff) {\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return jQueryOriginalVal.call($this, '');\n                    }\n                } else {\n                    return jQueryOriginalVal.call($this, '');\n                }\n\n                if (!settings.hasFocus && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return jQueryOriginalVal.call($this, value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\r\n         * Method to un-format inputs.\r\n         * This is handy to use right before form submission.\r\n         *\r\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n         * Please see option \"outputFormat\" for more details\r\n         *\r\n         * @example $(someSelector).autoNumeric('unSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.hasFocus = true;\n                    jQueryOriginalVal.call($this, $this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to re-format inputs.\r\n         * This is handy to use right after form submission.\r\n         *\r\n         * This is called after the 'unSet' method to reformat the input\r\n         *\r\n         * @example $(someSelector).autoNumeric('reSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', jQueryOriginalVal.call($this));\n                }\n            });\n        },\n\n\n        /**\r\n         * Return the unformatted value as a string.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('get');\r\n         *\r\n         * @returns {string}\r\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = jQueryOriginalVal.call($this.eq(0));\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                // Test if the value is negative\n                var isValueNegative = isNegative(value);\n\n                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.hasFocus = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    // Strips trailing negative symbol\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\n                    // Places the negative symbol in front of the trailing negative\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n                        value = '-' + value;\n                    }\n                }\n\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                }\n            }\n\n            // Always return a numeric string\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n            return trimPaddedZerosFromDecimalPlaces(value);\n        },\n\n\n        /**\r\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n         * - a plain number (if the setting 'number' is used).\r\n         *\r\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n         * Check the \"outputFormat\" option definition for more details.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getLocalized');\r\n         *\r\n         * @returns {*}\r\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\r\n         * Return the input unformatted value as a real Javascript number.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getNumber');\r\n         *\r\n         * @returns {number}\r\n         */\n        getNumber: function getNumber() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {string}\r\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {{}|[]}\r\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\r\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('getSettings');\r\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n         *\r\n         * @returns {object}\r\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\r\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n     * It initialize autoNumeric on the given element.\r\n     *\r\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n     * @param {*} args\r\n     * @returns {*}\r\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\r\n     * Return the default autoNumeric settings.\r\n     *\r\n     * @returns {object}\r\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\r\n     * Return all the predefined language options in one object.\r\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n     *\r\n     * @returns {object}\r\n     */\n    getLanguages = function getLanguages() {\n        return languageOption;\n    };\n\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\n    /**\r\n     * Public function that allows formatting without an element trigger.\r\n     *\r\n     * @param {number|string} value A number, or a string that represent a javascript number\r\n     * @param {object|null} options\r\n     * @returns {*}\r\n     */\n    autoFormat = function autoFormat(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        if (!isString(value) && !isNumber(value)) {\n            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Check the validity of the `value` parameter\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\n        var valueString = toNumericValue(value, settings);\n        if (isNaN(valueString)) {\n            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\r\n     * Public function that allows unformatting without an element.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} options\r\n     * @returns {*}\r\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n        if (isNegative(value)) {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.hasFocus = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(settings.decimalCharacter, '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\r\n     * Validate the given option object.\r\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n     *\r\n     * This tests if the options are not conflicting and are well formatted.\r\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n     *\r\n     * @param {*} userOptions\r\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n     * @throws Error\r\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n        '.', // Dot\n        ' ', // Normal space\n        '\\u2009', // Thin-space\n        '\\u202F', // Narrow no-break space\n        '\\xA0', // No-break space\n        '', // No separator\n        \"'\", // Apostrophe\n        '٬', // Arabic thousands separator\n        '˙'])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', // Comma\n        '.', // Dot\n        '·', // Middle-dot\n        '٫', // Arabic decimal separator\n        '⎖'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectAllOnFocusIfZero) && !isBoolean(options.selectAllOnFocusIfZero)) {\n            throwError('The option \\'selectAllOnFocusIfZero\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectAllOnFocusIfZero + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\r\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n     *\r\n     * @param {object} options\r\n     * @returns {boolean}\r\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\r\n     * Take an arabic number as a string and return a javascript number.\r\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n     * This returns `NaN` is the conversion is not possible.\r\n     * Based on http://stackoverflow.com/a/17025392/2834898\r\n     *\r\n     * @param {string} arabicNumbers\r\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n     * @param {boolean} parseDecimalCharacter\r\n     * @param {boolean} parseThousandSeparator\r\n     * @returns {string|number|NaN}\r\n     */\n    function arabicToLatinNumbers(arabicNumbers) {\n        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var result = arabicNumbers.toString();\n        if (result === '' || result.match(/[٠١٢٣٤٥٦٧٨٩۴۵۶]/g) === null) {\n            // If no Arabic/Persian numbers are found, return the numeric string directly\n            return arabicNumbers;\n        }\n\n        if (parseDecimalCharacter) {\n            result = result.replace(/٫/, '.'); // Decimal character\n        }\n\n        if (parseThousandSeparator) {\n            result = result.replace(/٬/g, ''); // Thousand separator\n        }\n\n        // Replace the numbers only\n        result = result.replace(/[٠١٢٣٤٥٦٧٨٩]/g, function (d) {\n            return d.charCodeAt(0) - 1632;\n        }) // Arabic numbers\n        .replace(/[۰۱۲۳۴۵۶۷۸۹]/g, function (d) {\n            return d.charCodeAt(0) - 1776;\n        }); // Persian numbers\n\n        // `NaN` has precedence over the string `'NaN'`\n        var resultAsNumber = Number(result);\n        if (isNaN(resultAsNumber)) {\n            return resultAsNumber;\n        }\n\n        if (returnANumber) {\n            result = resultAsNumber;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Create a custom event and immediately sent it from the given element.\r\n     * By default, if no element is given, the event is thrown from `document`.\r\n     *\r\n     * @param {string} eventName\r\n     * @param {Element} element\r\n     * @param {object} detail\r\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n\n    $.extend(true, defaultSettings, $.fn.autoNumeric.lang.Turkish, { currencySymbol: '' });\n\n    // Hijack the original val fn in order to\n    // use $autoNumeric.val() and be able to get/set\n    // the unmasked value.\n    $.fn.val = function (value) {\n        var me = this;\n        var $me = $(me);\n\n        // If we're not dealing with an instance of autoNumeric,\n        // simply call the original jQuery.fn.val\n        if ($me.data('autoNumeric') == null) {\n            return jQueryOriginalVal.apply(me, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        if (!arguments.length) {\n            // We're trying to read the numeric value\n            return $me.autoNumeric('get');\n        } else {\n            // We're trying to set a value\n            var originalVal = value;\n            var numericValue = void 0;\n\n            if (typeof value === 'string') {\n                value = value.trim().replace(',', '.');\n\n                if (value === '') {\n                    return $me;\n                }\n\n                numericValue = parseFloat(value, 10);\n\n                if (isNaN(numericValue)) {\n                    throw '\"' + originalVal + '\" is not a number.';\n                }\n            } else if (typeof value !== 'number') {\n                throw 'The type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is not supported.';\n            } else {\n                numericValue = value;\n            }\n\n            return $me.autoNumeric('set', numericValue);\n        }\n    };\n});\n\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    getLanguages: getLanguages,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsImdldExhbmd1YWdlcyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiZGlnaXRHcm91cFNlcGFyYXRvciIsIm5vU2VwYXJhdG9yT25Gb2N1cyIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJkZWNpbWFsQ2hhcmFjdGVyIiwiZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlIiwiY3VycmVuY3lTeW1ib2wiLCJjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwic2hvd1Bvc2l0aXZlU2lnbiIsInN1ZmZpeFRleHQiLCJvdmVycmlkZU1pbk1heExpbWl0cyIsIm1heGltdW1WYWx1ZSIsIm1pbmltdW1WYWx1ZSIsImRlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWxQbGFjZXMiLCJzY2FsZVN5bWJvbCIsInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UiLCJvbkludmFsaWRQYXN0ZSIsInJvdW5kaW5nTWV0aG9kIiwiYWxsb3dEZWNpbWFsUGFkZGluZyIsInNlbGVjdEFsbE9uRm9jdXNJZlplcm8iLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsImVtcHR5SW5wdXRCZWhhdmlvciIsImxlYWRpbmdaZXJvIiwiZm9ybWF0T25QYWdlTG9hZCIsInNlbGVjdE51bWJlck9ubHkiLCJkZWZhdWx0VmFsdWVPdmVycmlkZSIsInVuZm9ybWF0T25TdWJtaXQiLCJvdXRwdXRGb3JtYXQiLCJzaG93V2FybmluZ3MiLCJmYWlsT25Vbmtub3duT3B0aW9uIiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsIkFuZHJvaWREZWZhdWx0Iiwia2V5TmFtZSIsIlVuaWRlbnRpZmllZCIsIkFsdEdyIiwiRm4iLCJGbkxvY2siLCJIeXBlciIsIk1ldGEiLCJTdXBlciIsIlN5bWJvbCIsIlN5bWJvbExvY2siLCJDbGVhciIsIkNvcHkiLCJDclNlbCIsIkN1dCIsIkVyYXNlRW9mIiwiRXhTZWwiLCJQYXN0ZSIsIlJlZG8iLCJVbmRvIiwiQWNjZXB0IiwiQWdhaW4iLCJBdHRuIiwiQ2FuY2VsIiwiQ29udGV4dE1lbnUiLCJFeGVjdXRlIiwiRmluZCIsIkZpbmlzaCIsIkhlbHAiLCJQYXVzZSIsIlBsYXkiLCJQcm9wcyIsIlNlbGVjdCIsIlpvb21JbiIsIlpvb21PdXQiLCJCcmlnaHRuZXNzRG93biIsIkJyaWdodG5lc3NVcCIsIkVqZWN0IiwiTG9nT2ZmIiwiUG93ZXIiLCJQb3dlck9mZiIsIlByaW50U2NyZWVuIiwiSGliZXJuYXRlIiwiU3RhbmRieSIsIldha2VVcCIsIkNvbXBvc2UiLCJEZWFkIiwiUHJpbnQiLCJNaW51cyIsIlBsdXMiLCJOdW1wYWREb3QiLCJOdW1wYWREb3RBbHQiLCJOdW1wYWRNdWx0aXBseSIsIk51bXBhZFBsdXMiLCJOdW1wYWRNaW51cyIsIk51bXBhZFNsYXNoIiwiTnVtcGFkRG90T2Jzb2xldGVCcm93c2VycyIsIk51bXBhZE11bHRpcGx5T2Jzb2xldGVCcm93c2VycyIsIk51bXBhZFBsdXNPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkTWludXNPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkU2xhc2hPYnNvbGV0ZUJyb3dzZXJzIiwiZGVmYXVsdE1pbmltdW1WYWx1ZSIsImRlZmF1bHRNYXhpbXVtVmFsdWUiLCJkZWZhdWx0Um91bmRpbmdNZXRob2QiLCJkZWZhdWx0TGVhZGluZ1plcm8iLCJkZWZhdWx0U2VsZWN0TnVtYmVyT25seSIsImxhbmd1YWdlT3B0aW9uIiwiRnJlbmNoIiwiTm9ydGhBbWVyaWNhbiIsIkJyaXRpc2giLCJTd2lzcyIsIkphcGFuZXNlIiwiVHVya2lzaCIsIlNwYW5pc2giLCJDaGluZXNlIiwiZmFjdG9yeSIsImRlZmluZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwid2luZG93IiwialF1ZXJ5IiwialF1ZXJ5T3JpZ2luYWxWYWwiLCIkIiwiZm4iLCJ2YWwiLCJpc051bGwiLCJ2YWx1ZSIsImlzVW5kZWZpbmVkIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc1RydWVPckZhbHNlU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImlzT2JqZWN0IiwicmVmZXJlbmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNFbXB0eU9iaiIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImlzTnVtYmVyIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiaXNGaW5pdGUiLCJpc0ludCIsInBhcnNlSW50IiwicHJlcGFyZVBhc3RlZFRleHQiLCJ0ZXh0IiwiaG9sZGVyIiwic3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzIiwic2V0dGluZ3NDbG9uZSIsInJlcGxhY2UiLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkVycm9yIiwiZGVjaW1hbFBsYWNlcyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJsZW5ndGgiLCJrZXlDb2RlTnVtYmVyIiwiZXZlbnQiLCJ3aGljaCIsImNoYXJhY3RlciIsImtleSIsImZyb21DaGFyQ29kZSIsInJlc3VsdCIsImNoZWNrSWZJblJhbmdlIiwicGFyc2VkTWluVmFsdWUiLCJwYXJzZWRNYXhWYWx1ZSIsInBhcnNlZFZhbHVlIiwicGFyc2VTdHIiLCJ0ZXN0TWluTWF4IiwiaXNOZWdhdGl2ZSIsIm51bWVyaWNTdHJpbmciLCJjaGVja0V2ZXJ5d2hlcmUiLCJpc05lZ2F0aXZlU3RyaWN0IiwiY2hhckF0IiwiaXNaZXJvT3JIYXNOb1ZhbHVlIiwidGVzdCIsInNldFJhd05lZ2F0aXZlU2lnbiIsInJlcGxhY2VDaGFyQXQiLCJzdHJpbmciLCJpbmRleCIsIm5ld0NoYXJhY3RlciIsInN1YnN0ciIsImNsYW1wVG9SYW5nZUxpbWl0cyIsInNldHRpbmdzIiwiTWF0aCIsIm1heCIsIm1pbiIsImNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZSIsImZvcm1hdHRlZE51bWJlclN0cmluZyIsImNhcmV0UG9zaXRpb24iLCJudW1iZXJEb3RPck5lZ2F0aXZlU2lnbiIsIlJlZ0V4cCIsIm51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50IiwiZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlciIsInJhd051bWJlclN0cmluZyIsImNhcmV0UG9zaXRpb25JblJhd1ZhbHVlIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSIsInJhd051bWJlclN0cmluZ1NpemUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCIsInJhd051bWJlclN0cmluZ0luZGV4IiwiY291bnRDaGFySW5UZXh0IiwiY2hhckNvdW50ZXIiLCJjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24iLCJjaGFyYWN0ZXJDb3VudCIsImdldEVsZW1lbnRTZWxlY3Rpb24iLCJ0aGF0IiwicG9zaXRpb24iLCJzZWxlY3Rpb25TdGFydCIsImZvY3VzIiwic2VsZWN0IiwiZG9jdW1lbnQiLCJzZWxlY3Rpb24iLCJjcmVhdGVSYW5nZSIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3YXJuaW5nIiwic2hvd1dhcm5pbmciLCJjb25zb2xlIiwid2FybiIsInJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCIsIiR0aGlzIiwiZWFjaCIsImF1dG9OdW1lcmljIiwibWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCIsImxlZnRPckFsbCIsInNraXBGaXJzdEF1dG9TdHJpcCIsInRyYWlsaW5nTmVnYXRpdmUiLCJza2lwTGFzdEF1dG9TdHJpcCIsImFsbG93ZWRBdXRvU3RyaXAiLCJtYXRjaCIsIm51bVJlZ0F1dG9TdHJpcCIsImpvaW4iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsIm5lZ2F0aXZlU2lnbkNoYXJhY3RlciIsIm1JbnRQb3MiLCJzbGljZSIsIm1JbnROZWciLCJoYXNGb2N1cyIsInN0cmlwUmVnIiwidG9nZ2xlTmVnYXRpdmVCcmFja2V0IiwiZmlyc3RCcmFja2V0IiwibGFzdEJyYWNrZXQiLCJjb252ZXJ0VG9OdW1lcmljU3RyaW5nIiwibGFzdEluZGV4T2YiLCJ0ZW1wIiwiYXJhYmljVG9MYXRpbk51bWJlcnMiLCJ0b0xvY2FsZSIsImxvY2FsZSIsIk51bWJlciIsIm1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSIsIm1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSIsImNoZWNrRW1wdHkiLCJpbnB1dFZhbHVlIiwic2lnbk9uRW1wdHkiLCJhZGRHcm91cFNlcGFyYXRvcnMiLCJzdHJpcCIsImVtcHR5IiwiaXNWYWx1ZU5lZ2F0aXZlIiwiaXNaZXJvIiwiZGlnaXRhbEdyb3VwIiwic3Vic3RyaW5nIiwicG9zaXRpdmVTaWduQ2hhcmFjdGVyIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwicm91bmRlZElucHV0VmFsdWUiLCJ0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJyZWdleCIsInJvdW5kVmFsdWUiLCJyb3VuZCIsImNlaWwiLCJmbG9vciIsIml2Um91bmRlZCIsImRQb3MiLCJpbnB1dFZhbHVlSGFzQURvdCIsInZkUG9zIiwiY0RlYyIsInplcm9zIiwickxlbmd0aCIsInRSb3VuZCIsIm9kZCIsIml2QXJyYXkiLCJ0cnVuY2F0ZURlY2ltYWwiLCJpc1Bhc3RlIiwibW9kaWZpZWREZWNpbWFsUGFydCIsIm5MIiwic2VhcmNoIiwieGMiLCJ5YyIsInhOZWciLCJjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbiIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsImdldEN1cnJlbnRFbGVtZW50IiwiZWxlbWVudCIsImdldEF1dG9OdW1lcmljSG9sZGVyIiwidXBkYXRlIiwiZGF0YSIsIkF1dG9OdW1lcmljSG9sZGVyIiwiZ2V0Iiwia2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkiLCJvRGVjIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwib1N1ZmZpeCIsInJlYWRDb29raWUiLCJuYW1lIiwibmFtZUVRIiwiY2EiLCJjb29raWUiLCJzdG9yYWdlVGVzdCIsIm1vZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zIiwidHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMiLCJ0cmltbWVkRGVjaW1hbFBhcnQiLCJzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlIiwiYWN0aW9uIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCIkdGhhdCIsImZvcm1hdHRlZCIsInByb2Nlc3NlZCIsImV2ZW50S2V5Q29kZSIsInNldFJlYWwiLCJwb3MiLCJfc2V0U2VsZWN0aW9uIiwibGVmdCIsInJpZ2h0IiwiX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24iLCJzdHJpcFplcm9zIiwibmV3VmFsdWUiLCJhTmVnUmVnQXV0b1N0cmlwIiwicGFydHMiLCJfbm9ybWFsaXplUGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsIl9zZXRDYXJldFBvc2l0aW9uIiwidHJpZ2dlciIsImN1cnJlbmN5U3ltYm9sTGVuIiwiaGFzTmVnIiwidmFsdWVMZW4iLCJzaWduUG9zaXRpb24iLCJfZ2V0U2lnblBvc2l0aW9uIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwib2xkUGFydHMiLCJtb2RpZmllZExlZnRQYXJ0IiwiX3NldFZhbHVlUGFydHMiLCJjdHJsS2V5IiwibWV0YUtleSIsInR5cGUiLCJzaGlmdEtleSIsIl9jaGVja1Bhc3RlIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJzdWZmaXhUZXh0TGVuIiwiX2V4cGFuZFNlbGVjdGlvbk9uU2lnbiIsImNhcmV0Rml4IiwiX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInRocm93SW5wdXQiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbiIsImV2ZW50T3JDaGFyIiwiZXZlbnRDaGFyYWN0ZXIiLCJldmVudE51bWJlciIsImxlZnRMZW5ndGgiLCJzdWJQYXJ0cyIsImxlZnRBciIsInNoaWZ0IiwicHVzaCIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiaW5wdXQiLCJhbmRyb2lkU2VsZWN0aW9uU3RhcnQiLCJfZ2V0U3RyaW5nT3JBcnJheSIsImdldEFycmF5QmVoYXZpb3IiLCJmb3JtSW5kZXgiLCJhbGxGb3JtRWxlbWVudHMiLCJhaUluZGV4Iiwic2NJbmRleCIsInJTdWJtaXR0ZXJUeXBlcyIsInJTdWJtaXR0YWJsZSIsInJDaGVja2FibGVUeXBlIiwick5vbkF1dG9OdW1lcmljVHlwZXMiLCJjb3VudCIsImZpZWxkIiwibG9jYWxOYW1lIiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiZm9ybUZpZWxkcyIsInNlcmlhbGl6ZUFycmF5Iiwic2NFbGVtZW50IiwidGVzdElucHV0Iiwic2VyaWFsaXplIiwiZm9ybVBhcnRzIiwiaW5wdXROYW1lIiwibW9kaWZpZWRJbnB1dFZhbHVlIiwib25Gb2N1c0luQW5kTW91c2VFbnRlciIsImlzIiwidGFyZ2V0Iiwicm91bmRlZFZhbHVlIiwidmFsdWVPbkZvY3VzIiwibGFzdFZhbCIsIm9uRW1wdHkiLCJvbktleWRvd24iLCJfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUiLCJpbml0aWFsVmFsdWVPbktleWRvd24iLCJyZWFkT25seSIsInRyaWdnZXJFdmVudCIsIl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMiLCJfc2tpcEFsd2F5cyIsIl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24iLCJfZm9ybWF0VmFsdWUiLCJvbktleXByZXNzIiwiaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkIiwiX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24iLCJvbklucHV0IiwiY2hhckNvZGVBdCIsImFuZHJvaWRDaGFyRW50ZXJlZCIsImRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiIsImhhc0RlY2ltYWxDaGFyYWN0ZXIiLCJvbktleXVwIiwic2tpcCIsImlzT25BbmRyb2lkIiwib25Gb2N1c091dEFuZE1vdXNlTGVhdmUiLCJvcmlnVmFsdWUiLCJncm91cGVkVmFsdWUiLCJjaGFuZ2UiLCJvblBhc3RlIiwicmF3UGFzdGVkVGV4dCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwiaW5pdGlhbEZvcm1hdHRlZFZhbHVlIiwic2VsZWN0aW9uU2l6ZSIsImlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQiLCJpc1Bhc3RlTmVnYXRpdmUiLCJ1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0IiwicGFzdGVkVGV4dCIsImNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nIiwiaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyIiwiaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSIsImlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUiLCJsZWZ0UGFydENvbnRhaW5lZEFEb3QiLCJsZWZ0UGFydCIsInJpZ2h0UGFydCIsImxlZnRGb3JtYXR0ZWRQYXJ0IiwicmlnaHRGb3JtYXR0ZWRQYXJ0IiwibGFzdEdvb2RLbm93blJlc3VsdCIsInBhc3RlZFRleHRJbmRleCIsImxhc3RHb29kS25vd25SZXN1bHRJbmRleCIsImxhc3RHb29kS25vd25SZXN1bHRTaXplIiwibGVmdEZvcm1hdHRlZFBhcnQyIiwicmlnaHRGb3JtYXR0ZWRQYXJ0MiIsImluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkIiwiaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlIiwic2VsZWN0ZWRUZXh0IiwidmFsdWVIYXNCZWVuU2V0IiwidmFsdWVIYXNCZWVuQ2xhbXBlZCIsImVycm9yIiwiY2xhbXBlZFZhbHVlIiwiY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwib25TdWJtaXQiLCJjbG9zZXN0Iiwib24iLCIkc2V0dGluZ3MiLCJnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSIsIiRpbnB1dCIsImN1cnJlbnRFbGVtZW50VGFnIiwiZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZCIsInNldFZhbHVlIiwiY3VycmVudFZhbHVlIiwidW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUiLCJ0b051bWVyaWNWYWx1ZSIsImF0dHIiLCJJbmZpbml0eSIsInRvU3RyaXAiLCJ0YWdMaXN0IiwiY29ycmVjdE5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50T3B0aW9uIiwiY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMiLCJtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydCIsIm1pbmltdW1WYWx1ZUludGVnZXJQYXJ0IiwiY29ycmVjdERlY2ltYWxQbGFjZXNPdmVycmlkZU9wdGlvbiIsInNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIiLCJjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyIsImFsbE51bWJlcnNSZWciLCJub0FsbE51bWJlcnNSZWciLCJhTmVnUmVnIiwibmVnYXRpdmVTaWduUmVnUGFydCIsImFsbG93ZWQiLCJ0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMiLCJjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyIsIm9wdGlvbnMiLCJvbGRPcHRpb25zQ29udmVydGVyIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURlY2ltYWwiLCJhU3RvciIsIm1Sb3VuZCIsImFQYWQiLCJuQnJhY2tldCIsIndFbXB0eSIsImxaZXJvIiwiYUZvcm0iLCJzTnVtYmVyIiwiYW5EZWZhdWx0IiwidW5TZXRPblN1Ym1pdCIsIm91dHB1dFR5cGUiLCJkZWJ1ZyIsInJ1bk9uY2UiLCJvcHRpb24iLCJnZXRJbml0aWFsU2V0dGluZ3MiLCJleHRlbmQiLCJ0YWdEYXRhIiwiTmFOIiwibWV0aG9kcyIsImluaXQiLCJldmVudEhhbmRsZXJzIiwib25KcUZvY3VzIiwic2V0VGltZW91dCIsImV2ZW50Q29uZmlncyIsImhhbmRsZXIiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50Q29uZmlnIiwiaW5pdGlhbGl6ZWQiLCJtaXNjIiwicmVtb3ZlQWxsRXZlbnRzIiwiZWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmIiwiZGVzdHJveSIsImNsZWFyVmFsdWUiLCJyZW1vdmVEYXRhIiwid2lwZSIsInNldCIsImhhc0JlZW5Sb3VuZGVkIiwidGVtcERlY2ltYWwiLCJvbk9mZiIsImF0dGVtcHRlZFZhbHVlIiwidW5TZXQiLCJyZVNldCIsImVxIiwiZ2V0TG9jYWxpemVkIiwiZ2V0TnVtYmVyIiwiZ2V0Rm9ybWF0dGVkIiwiZ2V0U3RyaW5nIiwiZ2V0QXJyYXkiLCJnZXRTZXR0aW5ncyIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwibGFuZyIsInZhbHVlU3RyaW5nIiwiYXV0b1N0cmlwIiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJ2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzIiwiYXV0b1ZhbGlkYXRlIiwiaXNWYWxpZCIsImFyYWJpY051bWJlcnMiLCJyZXR1cm5BTnVtYmVyIiwicGFyc2VEZWNpbWFsQ2hhcmFjdGVyIiwicGFyc2VUaG91c2FuZFNlcGFyYXRvciIsInJlc3VsdEFzTnVtYmVyIiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInBhcmFtcyIsImV2dCIsIkV2ZW50IiwibWUiLCIkbWUiLCJhcmd1bWVudHMiLCJvcmlnaW5hbFZhbCIsIm51bWVyaWNWYWx1ZSIsInRyaW0iLCJmb3JtYXQiLCJ1bkZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7O0FBRUE7QUFDQSxJQUFJQSxtQkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMseUJBQUo7QUFDQSxJQUFJQyxxQkFBSjtBQUNBLElBQUlDLGlCQUFKO0FBQ0EsSUFBSUMseUJBQUo7O0FBRUE7QUFDQTs7O0FBR0EsSUFBTUMsaUJBQWlCLENBQ25CLEdBRG1CLEVBRW5CLFNBRm1CLEVBR25CLE1BSG1CLEVBSW5CLE1BSm1CLEVBS25CLE9BTG1CLEVBTW5CLElBTm1CLEVBT25CLEtBUG1CLEVBUW5CLEtBUm1CLEVBU25CLEtBVG1CLEVBVW5CLElBVm1CLEVBV25CLElBWG1CLEVBWW5CLElBWm1CLEVBYW5CLElBYm1CLEVBY25CLElBZG1CLEVBZW5CLElBZm1CLEVBZ0JuQixJQWhCbUIsRUFpQm5C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RUFBa0I7QUFDZCwyQkFBTzhmLEdBQVA7QUFDSDs7QUFFREcsK0JBQWU3ZSxXQUFXcEIsS0FBWCxFQUFrQixFQUFsQixDQUFmOztBQUVBLG9CQUFJbUIsTUFBTThlLFlBQU4sQ0FBSixFQUF5QjtBQUNyQixnQ0FBVUQsV0FBVjtBQUNIO0FBQ0osYUFaRCxNQWFLLElBQUksT0FBT2hnQixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2hDLDZDQUEwQkEsS0FBMUIseUNBQTBCQSxLQUExQjtBQUNILGFBRkksTUFHQTtBQUNEaWdCLCtCQUFlamdCLEtBQWY7QUFDSDs7QUFFRCxtQkFBTzhmLElBQUl0WSxXQUFKLENBQWdCLEtBQWhCLEVBQXVCeVksWUFBdkIsQ0FBUDtBQUNIO0FBQ0osS0F2Q0Q7QUF3Q0gsQ0FscEpBLENBQUQ7O0FBb3BKQTs7O2tCQUdlO0FBQ1hFLFlBQVV6dUIsVUFEQztBQUVYMHVCLGNBQVV6dUIsWUFGQztBQUdYQyxzQ0FIVztBQUlYQyw4QkFKVztBQUtYQyxzQkFMVyxFQUtEO0FBQ1ZDLHNDQU5XLEUiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiAgICAgICAgICAgICAgIGF1dG9OdW1lcmljLmpzXHJcbiAqXHJcbiAqIEB2ZXJzaW9uICAgICAgMi4wLjEyXHJcbiAqIEBkYXRlICAgICAgICAgMjAxNy0wNC0wNyBVVEMgMDc6MDBcclxuICpcclxuICogQGF1dGhvciAgICAgICBCb2IgS25vdGhlXHJcbiAqIEBjb250cmlidXRvcnMgQWxleGFuZHJlIEJvbm5lYXUsIFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzLFxyXG4gKiAgICAgICAgICAgICAgIGNmLiBBVVRIT1JTLm1kLlxyXG4gKiBAY29weXJpZ2h0ICAgIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXHJcbiAqIEBzaW5jZSAgICAgICAgMjAwOS0wOC0wOVxyXG4gKlxyXG4gKiBAc3VtbWFyeSAgICAgIGF1dG9OdW1lcmljIGlzIGEgbGlicmFyeSB0aGF0IHByb3ZpZGVzIGxpdmUgYXMteW91LXR5cGVcclxuICogICAgICAgICAgICAgICBmb3JtYXR0aW5nIGZvciBpbnRlcm5hdGlvbmFsIG51bWJlcnMgYW5kIGN1cnJlbmNpZXMuXHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgTm90ZSA6IFNvbWUgZnVuY3Rpb25zIGFyZSBib3Jyb3dlZCBmcm9tIGJpZy5qc1xyXG4gKiBAbGluayAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cclxuICpcclxuICogUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vYXV0b051bWVyaWMvYXV0b051bWVyaWNcclxuICpcclxuICogQGxpY2Vuc2UgICAgICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICogQGxpbmsgICAgICAgICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuICogY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG4vKiBnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBkZWZpbmUgKi9cclxuXHJcbi8vIEZ1bmN0aW9ucyBuYW1lcyBmb3IgRVM2IGV4cG9ydHNcclxubGV0IGF1dG9Gb3JtYXQ7XHJcbmxldCBhdXRvVW5Gb3JtYXQ7XHJcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xyXG5sZXQgZ2V0TGFuZ3VhZ2VzO1xyXG5sZXQgdmFsaWRhdGU7XHJcbmxldCBhcmVTZXR0aW5nc1ZhbGlkO1xyXG5cclxuLy8gQXV0b051bWVyaWMgZGVmYXVsdCBzZXR0aW5nc1xyXG4vKipcclxuICogTGlzdCBvZiBhbGxvd2VkIHRhZyBvbiB3aGljaCBhdXRvTnVtZXJpYyBjYW4gYmUgdXNlZC5cclxuICovXHJcbmNvbnN0IGFsbG93ZWRUYWdMaXN0ID0gW1xyXG4gICAgJ2InLFxyXG4gICAgJ2NhcHRpb24nLFxyXG4gICAgJ2NpdGUnLFxyXG4gICAgJ2NvZGUnLFxyXG4gICAgJ2NvbnN0JyxcclxuICAgICdkZCcsXHJcbiAgICAnZGVsJyxcclxuICAgICdkaXYnLFxyXG4gICAgJ2RmbicsXHJcbiAgICAnZHQnLFxyXG4gICAgJ2VtJyxcclxuICAgICdoMScsXHJcbiAgICAnaDInLFxyXG4gICAgJ2gzJyxcclxuICAgICdoNCcsXHJcbiAgICAnaDUnLFxyXG4gICAgJ2g2JyxcclxuICAgICdpbnMnLFxyXG4gICAgJ2tkYicsXHJcbiAgICAnbGFiZWwnLFxyXG4gICAgJ2xpJyxcclxuICAgICdvcHRpb24nLFxyXG4gICAgJ291dHB1dCcsXHJcbiAgICAncCcsXHJcbiAgICAncScsXHJcbiAgICAncycsXHJcbiAgICAnc2FtcGxlJyxcclxuICAgICdzcGFuJyxcclxuICAgICdzdHJvbmcnLFxyXG4gICAgJ3RkJyxcclxuICAgICd0aCcsXHJcbiAgICAndScsXHJcbl07XHJcblxyXG4vKipcclxuICogRGVmYXVsdHMgb3B0aW9ucyBhcmUgcHVibGljIC0gdGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZvbGxvd2luZyBtZXRob2Q6XHJcbiAqIC0gSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIChpZS4gYDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtY3VycmVuY3ktc3ltYm9sPVwiIOKCrFwiPmApXHJcbiAqIC0gT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzIChpZS4gYGFOSW5wdXQuYXV0b051bWVyaWMoJ3VwZGF0ZScsIHsgY3VycmVuY3lTeW1ib2w6ICcg4oKsJyB9KTtgKVxyXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcclxuICovXHJcbmNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHtcclxuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgZ3JvdXBpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgOlxyXG4gICAgICogJywnICAgICAgLy8gQ29tbWFcclxuICAgICAqICcuJyAgICAgIC8vIERvdFxyXG4gICAgICogJyAnICAgICAgLy8gTm9ybWFsIHNwYWNlXHJcbiAgICAgKiAnXFx1MjAwOScgLy8gVGhpbi1zcGFjZVxyXG4gICAgICogJ1xcdTIwMmYnIC8vIE5hcnJvdyBuby1icmVhayBzcGFjZVxyXG4gICAgICogJ1xcdTAwYTAnIC8vIE5vLWJyZWFrIHNwYWNlXHJcbiAgICAgKiAnJyAgICAgICAvLyBObyBzZXBhcmF0b3JcclxuICAgICAqIFwiJ1wiICAgICAgLy8gQXBvc3Ryb3BoZVxyXG4gICAgICogJ9msJyAgICAgIC8vIEFyYWJpYyB0aG91c2FuZHMgc2VwYXJhdG9yXHJcbiAgICAgKiAny5knICAgICAgLy8gRG90IGFib3ZlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNlcFxyXG4gICAgICovXHJcbiAgICBkaWdpdEdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcblxyXG4gICAgLyogUmVtb3ZlIHRoZSB0aG91c2FuZCBzZXBhcmF0b3Igb24gZm9jdXMsIGN1cnJlbmN5IHN5bWJvbCBhbmQgc3VmZml4IG9uIGZvY3VzXHJcbiAgICAgKiBleGFtcGxlIGlmIHRoZSBpbnB1dCB2YWx1ZSBcIiQgMSw5OTkuODggc3VmZml4XCJcclxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBuU2VwXHJcbiAgICAgKi9cclxuICAgIG5vU2VwYXJhdG9yT25Gb2N1czogZmFsc2UsXHJcblxyXG4gICAgLyogRGlnaXRhbCBncm91cGluZyBmb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB1c2VkIGluIEZvcm1hdFxyXG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcclxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiMnNcIiwgcmVzdWx0cyBpbiA5OSw5OTksOTksOTksOTk5IEluZGlhJ3MgbGFraHMgc2NhbGVkXHJcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjNcIiwgcmVzdWx0cyBpbiA5OTksOTk5LDk5OSBkZWZhdWx0XHJcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZEdyb3VwXHJcbiAgICAgKi9cclxuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6ICczJyxcclxuXHJcbiAgICAvKiBBbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlcnMgOlxyXG4gICAgICogJywnIDogQ29tbWFcclxuICAgICAqICcuJyA6IERvdFxyXG4gICAgICogJ8K3JyA6IE1pZGRsZS1kb3RcclxuICAgICAqICfZqycgOiBBcmFiaWMgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgICAqICfijpYnIDogRGVjaW1hbCBzZXBhcmF0b3Iga2V5IHN5bWJvbFxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFEZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbENoYXJhY3RlcjogJy4nLFxyXG5cclxuICAgIC8qIEFsbG93IHRvIGRlY2xhcmUgYW4gYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Igd2hpY2ggaXMgYXV0b21hdGljYWxseSByZXBsYWNlZCBieSBgZGVjaW1hbENoYXJhY3RlcmAgd2hlbiB0eXBlZC5cclxuICAgICAqIFRoaXMgaXMgdXNlZCBieSBjb3VudHJpZXMgdGhhdCB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlXHJcbiAgICAgKiBhIHBlcmlvZCAnZnVsbCBzdG9wJyBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJzIChGcmFuY2Ugb3IgU3BhaW4gZm9yIGluc3RhbmNlKS5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhbHREZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiBudWxsLFxyXG5cclxuICAgIC8qIGN1cnJlbmN5U3ltYm9sID0gYWxsb3dlZCBjdXJyZW5jeSBzeW1ib2xcclxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGN1cnJlbmN5U3ltYm9sOiBcIiRcIlxyXG4gICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgY3VycmVuY3lTeW1ib2w6ICckICdcclxuICAgICAqIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgY3VycmVuY3lTeW1ib2w6ICcgJCdcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2lnblxyXG4gICAgICovXHJcbiAgICBjdXJyZW5jeVN5bWJvbDogJycsXHJcblxyXG4gICAgLyogY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XHJcbiAgICAgKiBmb3IgcHJlZml4IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInBcIiAoZGVmYXVsdClcclxuICAgICAqIGZvciBzdWZmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcFNpZ25cclxuICAgICAqL1xyXG4gICAgLy9UT0RPIFJlbmFtZSB0aGUgb3B0aW9ucyB0byBtb3JlIGV4cGxpY2l0IG5hbWVzICgncCcgPT4gJ3ByZWZpeCcsIGV0Yy4pXHJcbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxyXG5cclxuICAgIC8qIFBsYWNlbWVudCBvZiBuZWdhdGl2ZS9wb3NpdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW5jeVN5bWJvbCBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XHJcbiAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxyXG4gICAgICogLSQxLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwifSBvciB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJsXCJ9XHJcbiAgICAgKiAkLTEsMjM0LjU2ID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn0gLy8gRGVmYXVsdCBpZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyAnbnVsbCcgYW5kIGN1cnJlbmN5U3ltYm9sIGlzIG5vdCBlbXB0eVxyXG4gICAgICogLTEsMjM0LjU2JCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0gLy8gRGVmYXVsdCBpZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyAnbnVsbCcgYW5kIGN1cnJlbmN5U3ltYm9sIGlzIG5vdCBlbXB0eVxyXG4gICAgICogMSwyMzQuNTYtICA9PiB7bmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxyXG4gICAgICogJDEsMjM0LjU2LSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XHJcbiAgICAgKiAxLDIzNC41Ni0kID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIn1cclxuICAgICAqIDEsMjM0LjU2JC0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcE5lZ1xyXG4gICAgICovXHJcbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdwJyA9PiAncHJlZml4JywgZXRjLilcclxuICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBudWxsLFxyXG5cclxuXHJcbiAgICAvKiBBbGxvdyB0aGUgcG9zaXRpdmUgc2lnbiBzeW1ib2wgYCtgIHRvIGJlIGRpc3BsYXllZCBmb3IgcG9zaXRpdmUgbnVtYmVycy5cclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcG9zaXRpdmUgc2lnbiBpcyBub3Qgc2hvd24uXHJcbiAgICAgKiBUaGUgc2lnbiBwbGFjZW1lbnQgaXMgY29udHJvbGxlZCBieSB0aGUgJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBvcHRpb24sIG1pbWlja2luZyB0aGUgbmVnYXRpdmUgc2lnbiBwbGFjZW1lbnQgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIHNob3dQb3NpdGl2ZVNpZ246IGZhbHNlLFxyXG5cclxuICAgIC8qIEFkZGl0aW9uYWwgc3VmZml4XHJcbiAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBzdWZmaXhUZXh0OiAnZ3Jvc3MnLCBhIHNwYWNlIGlzIGFsbG93ZWQgc3VmZml4VGV4dDogJyBkb2xsYXJzJ1xyXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFTdWZmaXhcclxuICAgICAqL1xyXG4gICAgc3VmZml4VGV4dDogJycsXHJcblxyXG4gICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcclxuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcclxuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImZsb29yXCIgYWRoZXJlcyB0byBtaW5pbXVtVmFsdWUgYW5kIGlnbm9yZXMgbWF4aW11bVZhbHVlIHNldHRpbmdzXHJcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJpZ25vcmVcIiBpZ25vcmVzIGJvdGggbWluaW11bVZhbHVlICYgbWF4aW11bVZhbHVlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogb0xpbWl0c1xyXG4gICAgICovXHJcbiAgICBvdmVycmlkZU1pbk1heExpbWl0czogbnVsbCxcclxuXHJcbiAgICAvKiBNYXhpbXVtIHBvc3NpYmxlIHZhbHVlXHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIG1pbmltdW1WYWx1ZVxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHZNYXhcclxuICAgICAqL1xyXG4gICAgbWF4aW11bVZhbHVlOiAnOTk5OTk5OTk5OTk5OS45OScsIC8vIDkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXHJcblxyXG4gICAgLyogTWluaW11bSBwb3NzaWJsZSB2YWx1ZVxyXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxyXG4gICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4aW11bVZhbHVlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdk1pblxyXG4gICAgICovXHJcbiAgICBtaW5pbXVtVmFsdWU6ICctOTk5OTk5OTk5OTk5OS45OScsIC8vIC05Ljk5OS45OTkuOTk5Ljk5OSw5OSB+PSAxMDAwMCBiaWxsaW9uc1xyXG5cclxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIG1pbmltdW1WYWx1ZSAmIG1heGltdW1WYWx1ZSB2YWx1ZXNcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBtRGVjXHJcbiAgICAgKi9cclxuICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZTogbnVsbCxcclxuXHJcbiAgICAvKiBFeHBhbmRlZCBkZWNpbWFsIHBsYWNlcyB2aXNpYmxlIHdoZW4gaW5wdXQgaGFzIGZvY3VzIC0gZXhhbXBsZTpcclxuICAgICAqIHtkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcclxuICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGVEZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1czogbnVsbCxcclxuXHJcbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbFBsYWNlcyAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xyXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgbm9uLXNjYWxlZCB2YWx1ZSBpcyBoZWxkIGluIGRhdGEgYW5kIGl0IGlzIGFkdmlzZWQgdGhhdCB5b3UgdXNlIHRoZSBcInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2VcIiBvcHRpb24gdG8gZW5zdXJlIHJldGFpbmluZyB0aGUgdmFsdWVcclxuICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxyXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsUGxhY2VzOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxyXG4gICAgICogRXhhbXBsZTogZm9jdXNpbiB2YWx1ZSBcIjEsMTExLjExXCIgZm9jdXNvdXQgdmFsdWUgXCIxLjEgS1wiXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiBUaGUgYHNjYWxlRGl2aXNvcmAgZGVjaWRlcyB0aGUgb24gZm9jdXMgdmFsdWUgYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBvbiBmb2N1c291dFxyXG4gICAgICogRXhhbXBsZSB7c2NhbGVEaXZpc29yOiAnMTAwMCd9IG9yIDxpbnB1dCBkYXRhLXNjYWxlLWRpdmlzb3I9XCIxMDAwXCI+XHJcbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxyXG4gICAgICogVGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgJ2hpZGRlbicgZGVjaW1hbHMuXHJcbiAgICAgKi9cclxuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxQbGFjZXNgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxyXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCA7IGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIHRoZSBmb2N1cy5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBzY2FsZURlY2ltYWxcclxuICAgICAqL1xyXG4gICAgc2NhbGVEZWNpbWFsUGxhY2VzOiBudWxsLFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgYHNjYWxlU3ltYm9sYCBvcHRpb24gaXMgYSBzeW1ib2wgcGxhY2VkIGFzIGEgc3VmZml4IHdoZW4gbm90IGluIGZvY3VzLlxyXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCB0b28uXHJcbiAgICAgKi9cclxuICAgIHNjYWxlU3ltYm9sOiBudWxsLFxyXG5cclxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcclxuICAgICAqIGlmIGllIDYgb3IgNyB0aGUgdmFsdWUgd2lsbCBiZSBzYXZlZCBhcyBhIHNlc3Npb24gY29va2llXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVN0b3JcclxuICAgICAqL1xyXG4gICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZTogZmFsc2UsXHJcblxyXG4gICAgLypcclxuICAgICAqIE1hbmFnZSBob3cgYXV0b051bWVyaWMgcmVhY3Qgd2hlbiB0aGUgdXNlciB0cmllcyB0byBwYXN0ZSBhbiBpbnZhbGlkIG51bWJlci5cclxuICAgICAqIC0gJ2Vycm9yJyAgICA6IChUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yKSBUaGUgaW5wdXQgdmFsdWUgaXMgbm90IGNoYW5nZWQgYW5kIGFuIGVycm9yIGlzIG91dHB1dCBpbiB0aGUgY29uc29sZS5cclxuICAgICAqIC0gJ2lnbm9yZScgICA6IGlkZW0gdGhhbiAnZXJyb3InLCBidXQgZmFpbCBzaWxlbnRseSB3aXRob3V0IG91dHB1dHRpbmcgYW55IGVycm9yL3dhcm5pbmcgaW4gdGhlIGNvbnNvbGUuXHJcbiAgICAgKiAtICdjbGFtcCcgICAgOiBpZiB0aGUgcGFzdGVkIHZhbHVlIGlzIGVpdGhlciB0b28gc21hbGwgb3IgdG9vIGJpZyByZWdhcmRpbmcgdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIHJhbmdlLCB0aGVuIHRoZSByZXN1bHQgaXMgY2xhbXBlZCB0byB0aG9zZSBsaW1pdHMuXHJcbiAgICAgKiAtICd0cnVuY2F0ZScgOiBhdXRvTnVtZXJpYyB3aWxsIGluc2VydCBhcyBtYW55IHBhc3RlZCBudW1iZXJzIGl0IGNhbiBhdCB0aGUgaW5pdGlhbCBjYXJldC9zZWxlY3Rpb24sIHVudGlsIGV2ZXJ5dGhpbmcgaXMgcGFzdGVkLCBvciB0aGUgcmFuZ2UgbGltaXQgaXMgaGl0LlxyXG4gICAgICogICAgICAgICAgICAgICAgVGhlIG5vbi1wYXN0ZWQgbnVtYmVycyBhcmUgZHJvcHBlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkIGF0IGFsbC5cclxuICAgICAqIC0gJ3JlcGxhY2UnICA6IGF1dG9OdW1lcmljIHdpbGwgZmlyc3QgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdGhlbiBpZiB0aGUgcmFuZ2UgbGltaXQgaXMgaGl0LCBpdCB3aWxsIHRyeVxyXG4gICAgICogICAgICAgICAgICAgICAgdG8gcmVwbGFjZSBvbmUgYnkgb25lIHRoZSByZW1haW5pbmcgaW5pdGlhbCBudW1iZXJzIChvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQpIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHBhc3RlZCBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgMSA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbmVnYXRpdmUgc2lnbiAnLScgd2lsbCBiZSBhY2NlcHRlZCBhbnl3aGVyZSBpbiB0aGUgaW5wdXQsIGFuZCB3aWxsIHNldCB0aGUgcmVzdWx0aW5nIHZhbHVlIGFzIGEgbmVnYXRpdmUgbnVtYmVyXHJcbiAgICAgKiBOb3RlIDIgOiBBIHBhc3RlIGNvbnRlbnQgc3RhcnRpbmcgd2l0aCBhIG51bWJlciB3aWxsIGJlIGFjY2VwdGVkLCBldmVuIGlmIHRoZSByZXN0IGlzIGdpYmJlcmlzaCAoaWUuICcxMjNmb29iYXI0NTYnKS5cclxuICAgICAqICAgICAgICAgIE9ubHkgdGhlIGZpcnN0IG51bWJlciB3aWxsIGJlIHVzZWQgKGhlcmUgJzEyMycpLlxyXG4gICAgICogTm90ZSAzIDogVGhlIHBhc3RlIGV2ZW50IHdvcmtzIHdpdGggdGhlIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBvcHRpb24gdG9vLlxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gU2hvdWxkbid0IHdlIHVzZSBgdHJ1bmNhdGVgIGFzIHRoZSBkZWZhdWx0IHZhbHVlP1xyXG4gICAgb25JbnZhbGlkUGFzdGU6ICdlcnJvcicsXHJcblxyXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJTXCIsIFJvdW5kLUhhbGYtVXAgU3ltbWV0cmljIChkZWZhdWx0KVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiYVwiLCBSb3VuZC1IYWxmLURvd24gQXN5bW1ldHJpYyAobG93ZXIgY2FzZSBhKVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEXCIsIFJvdW5kIERvd24gXCJSb3VuZC1Ub3dhcmQtWmVyb1wiIC0gc2FtZSBhcyB0cnVuY2F0ZVxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiTjA1XCIgUm91bmRzIHRvIHRoZSBuZWFyZXN0IC4wNSA9PiBzYW1lIGFzIFwiQ0hGXCIgdXNlZCBpbiAxLjlYIGFuZCBzdGlsbCB2YWxpZFxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG1Sb3VuZFxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdTJyA9PiAnUm91bmRIYWxmVXBTeW1tZXRyaWMnLCBldGMuKVxyXG4gICAgLy9UT0RPIEFkZCBhbiBgYW4ucm91bmRpbmdNZXRob2RgIG9iamVjdCB0aGF0IGVudW0gdGhvc2Ugb3B0aW9ucyBjbGVhcmx5XHJcbiAgICByb3VuZGluZ01ldGhvZDogJ1MnLFxyXG5cclxuICAgIC8qIEFsbG93IHBhZGRpbmcgdGhlIGRlY2ltYWwgcGxhY2VzIHdpdGggemVyb3NcclxuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IHRydWUgLSBhbHdheXMgUGFkIGRlY2ltYWxzIHdpdGggemVyb3NcclxuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXHJcbiAgICAgKiBOb3RlOiBzZXR0aW5nIGFsbG93RGVjaW1hbFBhZGRpbmcgdG8gJ2ZhbHNlJyB3aWxsIG92ZXJyaWRlIHRoZSAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVBhZFxyXG4gICAgICovXHJcbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB0cnVlLFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiB0cnVlLCBhbGwgdGV4dCB3aXRoaW4gdGhlIGlucHV0IHdpbGwgYXV0b21hdGljYWxseSBiZVxyXG4gICAgICogc2VsZWN0ZWQgd2hlbiBpbnB1dCBnZXRzIGZvY3VzIGFuZCB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0QWxsT25Gb2N1c0lmWmVybzogZmFsc2UsXHJcblxyXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXHJcbiAgICAgKiBUaG9zZSBicmFja2V0cyBhcmUgdmlzaWJsZSBvbmx5IHdoZW4gdGhlIGZpZWxkIGRvZXMgTk9UIGhhdmUgdGhlIGZvY3VzLlxyXG4gICAgICogVGhlIGxlZnQgYW5kIHJpZ2h0IHN5bWJvbHMgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgc2VwYXJhdGVkIGJ5IGEgY29tbWFcclxuICAgICAqIFRoaXMgb3B0aW9uIGNhbiBiZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlcyA6XHJcbiAgICAgKiBudWxsLCAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlLCB3aGljaCBkZWFjdGl2YXRlIHRoaXMgZmVhdHVyZVxyXG4gICAgICogJygsKScsXHJcbiAgICAgKiAnWyxdJyxcclxuICAgICAqICc8LD4nIG9yXHJcbiAgICAgKiAneyx9J1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG5CcmFja2V0XHJcbiAgICAgKi9cclxuICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9wdGlvbnMgdG8gbW9yZSBleHBsaWNpdCBuYW1lcyAoJygsKScgPT4gJ3BhcmVudGhlc2VzJywgZXRjLilcclxuICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiBudWxsLFxyXG5cclxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxyXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xyXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcInByZXNzXCIgLSBjdXJyZW5jeSBzaWduIGRpc3BsYXlzIG9uIGFueSBrZXkgYmVpbmcgcHJlc3NlZFxyXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcclxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRob3V0IGEgY3VycmVuY3kgc2lnblxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHdFbXB0eVxyXG4gICAgICovXHJcbiAgICBlbXB0eUlucHV0QmVoYXZpb3I6ICdmb2N1cycsXHJcblxyXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXHJcbiAgICAgKiBsZWFkaW5nWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAqIGxlYWRpbmdaZXJvOiBcImRlbnlcIiwgLSBhbGxvd3Mgb25seSBvbmUgbGVhZGluZyB6ZXJvIG9uIHZhbHVlcyBsZXNzIHRoYW4gb25lXHJcbiAgICAgKiBsZWFkaW5nWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBsWmVyb1xyXG4gICAgICovXHJcbiAgICBsZWFkaW5nWmVybzogJ2RlbnknLFxyXG5cclxuICAgIC8qIERldGVybWluZSBpZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIGZvcm1hdHRlZCBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cclxuICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYUZvcm1cclxuICAgICAqL1xyXG4gICAgZm9ybWF0T25QYWdlTG9hZDogdHJ1ZSxcclxuXHJcbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdCB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCwgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICogTm90ZSA6IElmIHRoZSBjdXJyZW5jeSBzeW1ib2wgaXMgYmV0d2VlbiB0aGUgbnVtZXJpYyB2YWx1ZSBhbmQgdGhlIG5lZ2F0aXZlIHNpZ24sIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNOdW1iZXJcclxuICAgICAqL1xyXG4gICAgc2VsZWN0TnVtYmVyT25seTogZmFsc2UsXHJcblxyXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xyXG4gICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICogZXhhbXBsZXM6XHJcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiBcIlwifVxyXG4gICAgICogdmFsdWU9MTIzNC41NiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6ICcxMjM0LjU2J31cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhbkRlZmF1bHRcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IG51bGwsXHJcblxyXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxyXG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxyXG4gICAgICogcmV2aWV3IHRoZSAndW5TZXQnIG1ldGhvZCBmb3Igb3RoZXIgZm9ybWF0c1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHVuU2V0T25TdWJtaXRcclxuICAgICAqL1xyXG4gICAgdW5mb3JtYXRPblN1Ym1pdDogZmFsc2UsXHJcblxyXG4gICAgLyogQWxsb3dzIHRoZSBvdXRwdXQgdG8gYmUgaW4gdGhlIGxvY2FsZSBmb3JtYXQgdmlhIHRoZSBcImdldFwiLCBcImdldFN0cmluZ1wiICYgXCJnZXRBcnJheVwiIG1ldGhvZHNcclxuICAgICAqIG51bGwgb3IgJ3N0cmluZycgPT4gJ25ubm4ubm4nIG9yICctbm5ubi5ubicgYXMgdGV4dCB0eXBlLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxyXG4gICAgICogJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxyXG4gICAgICogJywnIG9yICctLCcgICAgICA9PiAnbm5ubixubicgb3IgJy1ubm5uLG5uJ1xyXG4gICAgICogJy4tJyAgICAgICAgICAgICA9PiAnbm5ubi5ubicgb3IgJ25ubm4ubm4tJ1xyXG4gICAgICogJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG91dHB1dFR5cGVcclxuICAgICAqL1xyXG4gICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxyXG5cclxuICAgIC8qIERlZmluZXMgaWYgd2FybmluZ3Mgc2hvdWxkIGJlIHNob3duXHJcbiAgICAgKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxyXG4gICAgICogdHJ1ZSA9PiBhbGwgd2FybmluZyBhcmUgc2hvd25cclxuICAgICAqIGZhbHNlID0+IG5vIHdhcm5pbmdzIGFyZSBzaG93biwgb25seSB0aGUgdGhyb3duIGVycm9yc1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRlYnVnXHJcbiAgICAgKi9cclxuICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBvcHRpb24gaXMgdGhlICdzdHJpY3QgbW9kZScgKGFrYSAnZGVidWcnIG1vZGUpLCB3aGljaCBhbGxvd3MgYXV0b051bWVyaWMgdG8gc3RyaWN0bHkgYW5hbHlzZSB0aGUgb3B0aW9ucyBwYXNzZWQsIGFuZCBmYWlscyBpZiBhbiB1bmtub3duIG9wdGlvbnMgaXMgdXNlZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxyXG4gICAgICogWW91IHNob3VsZCBzZXQgdGhhdCB0byAnVFJVRScgaWYgeW91IHdhbnQgdG8gbWFrZSBzdXJlIHlvdSBhcmUgb25seSB1c2luZyAncHVyZScgYXV0b051bWVyaWMgc2V0dGluZ3Mgb2JqZWN0cyBpbiB5b3VyIGNvZGUuXHJcbiAgICAgKiBJZiB5b3Ugc2VlIHVuY2F1Z2h0IGVycm9ycyBpbiB0aGUgY29uc29sZSBhbmQgeW91ciBjb2RlIHN0YXJ0cyB0byBmYWlsLCB0aGlzIG1lYW5zIHNvbWVob3cgdGhvc2Ugb3B0aW9ucyBnZXRzIGNvcnJ1cHRlZCBieSBhbm90aGVyIHByb2dyYW0uXHJcbiAgICAgKi9cclxuICAgIGZhaWxPblVua25vd25PcHRpb246IGZhbHNlLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxyXG4gKiAvL1RPRE8gUmVwbGFjZSBldmVyeSBjYWxsIHRvIHRoaXMgb2JqZWN0IHdpdGggYSBjYWxsIHRvIGBrZXlOYW1lYFxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxuY29uc3Qga2V5Q29kZSA9IHtcclxuICAgIEJhY2tzcGFjZTogICAgICA4LFxyXG4gICAgVGFiOiAgICAgICAgICAgIDksXHJcbiAgICBFbnRlcjogICAgICAgICAgMTMsXHJcbiAgICBTaGlmdDogICAgICAgICAgMTYsXHJcbiAgICBDdHJsOiAgICAgICAgICAgMTcsXHJcbiAgICBBbHQ6ICAgICAgICAgICAgMTgsXHJcbiAgICBQYXVzZUJyZWFrOiAgICAgMTksXHJcbiAgICBDYXBzTG9jazogICAgICAgMjAsXHJcbiAgICBFc2M6ICAgICAgICAgICAgMjcsXHJcbiAgICBTcGFjZTogICAgICAgICAgMzIsXHJcbiAgICBQYWdlVXA6ICAgICAgICAgMzMsXHJcbiAgICBQYWdlRG93bjogICAgICAgMzQsXHJcbiAgICBFbmQ6ICAgICAgICAgICAgMzUsXHJcbiAgICBIb21lOiAgICAgICAgICAgMzYsXHJcbiAgICBMZWZ0QXJyb3c6ICAgICAgMzcsXHJcbiAgICBVcEFycm93OiAgICAgICAgMzgsXHJcbiAgICBSaWdodEFycm93OiAgICAgMzksXHJcbiAgICBEb3duQXJyb3c6ICAgICAgNDAsXHJcbiAgICBJbnNlcnQ6ICAgICAgICAgNDUsXHJcbiAgICBEZWxldGU6ICAgICAgICAgNDYsXHJcbiAgICBudW0wOiAgICAgICAgICAgNDgsXHJcbiAgICBudW0xOiAgICAgICAgICAgNDksXHJcbiAgICBudW0yOiAgICAgICAgICAgNTAsXHJcbiAgICBudW0zOiAgICAgICAgICAgNTEsXHJcbiAgICBudW00OiAgICAgICAgICAgNTIsXHJcbiAgICBudW01OiAgICAgICAgICAgNTMsXHJcbiAgICBudW02OiAgICAgICAgICAgNTQsXHJcbiAgICBudW03OiAgICAgICAgICAgNTUsXHJcbiAgICBudW04OiAgICAgICAgICAgNTYsXHJcbiAgICBudW05OiAgICAgICAgICAgNTcsXHJcbiAgICBhOiAgICAgICAgICAgICAgNjUsXHJcbiAgICBiOiAgICAgICAgICAgICAgNjYsXHJcbiAgICBjOiAgICAgICAgICAgICAgNjcsXHJcbiAgICBkOiAgICAgICAgICAgICAgNjgsXHJcbiAgICBlOiAgICAgICAgICAgICAgNjksXHJcbiAgICBmOiAgICAgICAgICAgICAgNzAsXHJcbiAgICBnOiAgICAgICAgICAgICAgNzEsXHJcbiAgICBoOiAgICAgICAgICAgICAgNzIsXHJcbiAgICBpOiAgICAgICAgICAgICAgNzMsXHJcbiAgICBqOiAgICAgICAgICAgICAgNzQsXHJcbiAgICBrOiAgICAgICAgICAgICAgNzUsXHJcbiAgICBsOiAgICAgICAgICAgICAgNzYsXHJcbiAgICBtOiAgICAgICAgICAgICAgNzcsXHJcbiAgICBuOiAgICAgICAgICAgICAgNzgsXHJcbiAgICBvOiAgICAgICAgICAgICAgNzksXHJcbiAgICBwOiAgICAgICAgICAgICAgODAsXHJcbiAgICBxOiAgICAgICAgICAgICAgODEsXHJcbiAgICByOiAgICAgICAgICAgICAgODIsXHJcbiAgICBzOiAgICAgICAgICAgICAgODMsXHJcbiAgICB0OiAgICAgICAgICAgICAgODQsXHJcbiAgICB1OiAgICAgICAgICAgICAgODUsXHJcbiAgICB2OiAgICAgICAgICAgICAgODYsXHJcbiAgICB3OiAgICAgICAgICAgICAgODcsXHJcbiAgICB4OiAgICAgICAgICAgICAgODgsXHJcbiAgICB5OiAgICAgICAgICAgICAgODksXHJcbiAgICB6OiAgICAgICAgICAgICAgOTAsXHJcbiAgICBXaW5kb3dzOiAgICAgICAgOTEsXHJcbiAgICBSaWdodENsaWNrOiAgICAgOTMsXHJcbiAgICBudW1wYWQwOiAgICAgICAgOTYsXHJcbiAgICBudW1wYWQxOiAgICAgICAgOTcsXHJcbiAgICBudW1wYWQyOiAgICAgICAgOTgsXHJcbiAgICBudW1wYWQzOiAgICAgICAgOTksXHJcbiAgICBudW1wYWQ0OiAgICAgICAgMTAwLFxyXG4gICAgbnVtcGFkNTogICAgICAgIDEwMSxcclxuICAgIG51bXBhZDY6ICAgICAgICAxMDIsXHJcbiAgICBudW1wYWQ3OiAgICAgICAgMTAzLFxyXG4gICAgbnVtcGFkODogICAgICAgIDEwNCxcclxuICAgIG51bXBhZDk6ICAgICAgICAxMDUsXHJcbiAgICBNdWx0aXBseU51bXBhZDogMTA2LFxyXG4gICAgUGx1c051bXBhZDogICAgIDEwNyxcclxuICAgIE1pbnVzTnVtcGFkOiAgICAxMDksXHJcbiAgICBEb3ROdW1wYWQ6ICAgICAgMTEwLFxyXG4gICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcclxuICAgIEYxOiAgICAgICAgICAgICAxMTIsXHJcbiAgICBGMjogICAgICAgICAgICAgMTEzLFxyXG4gICAgRjM6ICAgICAgICAgICAgIDExNCxcclxuICAgIEY0OiAgICAgICAgICAgICAxMTUsXHJcbiAgICBGNTogICAgICAgICAgICAgMTE2LFxyXG4gICAgRjY6ICAgICAgICAgICAgIDExNyxcclxuICAgIEY3OiAgICAgICAgICAgICAxMTgsXHJcbiAgICBGODogICAgICAgICAgICAgMTE5LFxyXG4gICAgRjk6ICAgICAgICAgICAgIDEyMCxcclxuICAgIEYxMDogICAgICAgICAgICAxMjEsXHJcbiAgICBGMTE6ICAgICAgICAgICAgMTIyLFxyXG4gICAgRjEyOiAgICAgICAgICAgIDEyMyxcclxuICAgIE51bUxvY2s6ICAgICAgICAxNDQsXHJcbiAgICBTY3JvbGxMb2NrOiAgICAgMTQ1LFxyXG4gICAgTXlDb21wdXRlcjogICAgIDE4MixcclxuICAgIE15Q2FsY3VsYXRvcjogICAxODMsXHJcbiAgICBTZW1pY29sb246ICAgICAgMTg2LFxyXG4gICAgRXF1YWw6ICAgICAgICAgIDE4NyxcclxuICAgIENvbW1hOiAgICAgICAgICAxODgsXHJcbiAgICBIeXBoZW46ICAgICAgICAgMTg5LFxyXG4gICAgRG90OiAgICAgICAgICAgIDE5MCxcclxuICAgIFNsYXNoOiAgICAgICAgICAxOTEsXHJcbiAgICBCYWNrcXVvdGU6ICAgICAgMTkyLFxyXG4gICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcclxuICAgIEJhY2tzbGFzaDogICAgICAyMjAsXHJcbiAgICBSaWdodEJyYWNrZXQ6ICAgMjIxLFxyXG4gICAgUXVvdGU6ICAgICAgICAgIDIyMixcclxuICAgIENvbW1hbmQ6ICAgICAgICAyMjQsXHJcbiAgICBBbmRyb2lkRGVmYXVsdDogMjI5LCAvLyBBbmRyb2lkIENocm9tZSByZXR1cm5zIHRoZSBzYW1lIGtleWNvZGUgbnVtYmVyIDIyOSBmb3IgYWxsIGtleXMgcHJlc3NlZFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleSBuYW1lIChhcyBzZXQgaW4gS2V5Ym9hcmRFdmVudC5rZXkpLlxyXG4gKiBUaG9zZSBuYW1lcyBhcmUgbGlzdGVkIGhlcmUgOlxyXG4gKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xyXG4gKi9cclxuY29uc3Qga2V5TmFtZSA9IHtcclxuICAgIC8vIFNwZWNpYWwgdmFsdWVzXHJcbiAgICBVbmlkZW50aWZpZWQ6ICAgJ1VuaWRlbnRpZmllZCcsXHJcblxyXG4gICAgLy8gTW9kaWZpZXIga2V5c1xyXG4gICAgQWx0OiAgICAgICAgICAgICdBbHQnLFxyXG4gICAgQWx0R3I6ICAgICAgICAgICdBbHRHcmFwaCcsXHJcbiAgICBDYXBzTG9jazogICAgICAgJ0NhcHNMb2NrJywgLy8gVW5kZXIgQ2hyb21lLCBlLmtleSBpcyBlbXB0eSBmb3IgQ2Fwc0xvY2tcclxuICAgIEN0cmw6ICAgICAgICAgICAnQ29udHJvbCcsXHJcbiAgICBGbjogICAgICAgICAgICAgJ0ZuJyxcclxuICAgIEZuTG9jazogICAgICAgICAnRm5Mb2NrJyxcclxuICAgIEh5cGVyOiAgICAgICAgICAnSHlwZXInLCAvLyAnT1MnIHVuZGVyIEZpcmVmb3hcclxuICAgIE1ldGE6ICAgICAgICAgICAnTWV0YScsIC8vIFRoZSBXaW5kb3dzLCBDb21tYW5kIG9yIOKMmCBrZXkgLy8gJ09TJyB1bmRlciBGaXJlZm94IGFuZCBJRTlcclxuICAgIFdpbmRvd3M6ICAgICAgICAnTWV0YScsIC8vIFRoaXMgaXMgYSBub24tb2ZmaWNpYWwga2V5IG5hbWVcclxuICAgIENvbW1hbmQ6ICAgICAgICAnTWV0YScsIC8vIFRoaXMgaXMgYSBub24tb2ZmaWNpYWwga2V5IG5hbWVcclxuICAgIE51bUxvY2s6ICAgICAgICAnTnVtTG9jaycsXHJcbiAgICBTY3JvbGxMb2NrOiAgICAgJ1Njcm9sbExvY2snLFxyXG4gICAgU2hpZnQ6ICAgICAgICAgICdTaGlmdCcsXHJcbiAgICBTdXBlcjogICAgICAgICAgJ1N1cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XHJcbiAgICBTeW1ib2w6ICAgICAgICAgJ1N5bWJvbCcsXHJcbiAgICBTeW1ib2xMb2NrOiAgICAgJ1N5bWJvbExvY2snLFxyXG5cclxuICAgIC8vIFdoaXRlc3BhY2Uga2V5c1xyXG4gICAgRW50ZXI6ICAgICAgICAgICdFbnRlcicsXHJcbiAgICBUYWI6ICAgICAgICAgICAgJ1RhYicsXHJcbiAgICBTcGFjZTogICAgICAgICAgJyAnLCAvLyAnU3BhY2ViYXInIGZvciBGaXJlZm94IDwzNywgYW5kIElFOVxyXG5cclxuICAgIC8vIE5hdmlnYXRpb24ga2V5c1xyXG4gICAgRG93bkFycm93OiAgICAgICdBcnJvd0Rvd24nLCAvLyAnRG93bicgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgTGVmdEFycm93OiAgICAgICdBcnJvd0xlZnQnLCAvLyAnTGVmdCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgUmlnaHRBcnJvdzogICAgICdBcnJvd1JpZ2h0JywgLy8gJ1JpZ2h0JyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBVcEFycm93OiAgICAgICAgJ0Fycm93VXAnLCAvLyAnVXAnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEVuZDogICAgICAgICAgICAnRW5kJyxcclxuICAgIEhvbWU6ICAgICAgICAgICAnSG9tZScsXHJcbiAgICBQYWdlRG93bjogICAgICAgJ1BhZ2VEb3duJyxcclxuICAgIFBhZ2VVcDogICAgICAgICAnUGFnZVVwJyxcclxuXHJcbiAgICAvLyBFZGl0aW5nIGtleXNcclxuICAgIEJhY2tzcGFjZTogICAgICAnQmFja3NwYWNlJyxcclxuICAgIENsZWFyOiAgICAgICAgICAnQ2xlYXInLFxyXG4gICAgQ29weTogICAgICAgICAgICdDb3B5JyxcclxuICAgIENyU2VsOiAgICAgICAgICAnQ3JTZWwnLCAvLyAnQ3JzZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEN1dDogICAgICAgICAgICAnQ3V0JyxcclxuICAgIERlbGV0ZTogICAgICAgICAnRGVsZXRlJywgLy8gJ0RlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgRXJhc2VFb2Y6ICAgICAgICdFcmFzZUVvZicsXHJcbiAgICBFeFNlbDogICAgICAgICAgJ0V4U2VsJywgLy8gJ0V4c2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBJbnNlcnQ6ICAgICAgICAgJ0luc2VydCcsXHJcbiAgICBQYXN0ZTogICAgICAgICAgJ1Bhc3RlJyxcclxuICAgIFJlZG86ICAgICAgICAgICAnUmVkbycsXHJcbiAgICBVbmRvOiAgICAgICAgICAgJ1VuZG8nLFxyXG5cclxuICAgIC8vIFVJIGtleXNcclxuICAgIEFjY2VwdDogICAgICAgICAnQWNjZXB0JyxcclxuICAgIEFnYWluOiAgICAgICAgICAnQWdhaW4nLFxyXG4gICAgQXR0bjogICAgICAgICAgICdBdHRuJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3gsIENocm9tZSwgYW5kIElFOSAoJ0thbmFNb2RlJyB3aGVuIHVzaW5nIHRoZSBKYXBhbmVzZSBrZXlib2FyZCBsYXlvdXQpXHJcbiAgICBDYW5jZWw6ICAgICAgICAgJ0NhbmNlbCcsXHJcbiAgICBDb250ZXh0TWVudTogICAgJ0NvbnRleHRNZW51JywgLy8gJ0FwcHMnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEVzYzogICAgICAgICAgICAnRXNjYXBlJywgLy8gJ0VzYycgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgRXhlY3V0ZTogICAgICAgICdFeGVjdXRlJyxcclxuICAgIEZpbmQ6ICAgICAgICAgICAnRmluZCcsXHJcbiAgICBGaW5pc2g6ICAgICAgICAgJ0ZpbmlzaCcsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94LCBDaHJvbWUsIGFuZCBJRTkgKCdLYXRha2FuYScgd2hlbiB1c2luZyB0aGUgSmFwYW5lc2Uga2V5Ym9hcmQgbGF5b3V0KVxyXG4gICAgSGVscDogICAgICAgICAgICdIZWxwJyxcclxuICAgIFBhdXNlOiAgICAgICAgICAnUGF1c2UnLFxyXG4gICAgUGxheTogICAgICAgICAgICdQbGF5JyxcclxuICAgIFByb3BzOiAgICAgICAgICAnUHJvcHMnLFxyXG4gICAgU2VsZWN0OiAgICAgICAgICdTZWxlY3QnLFxyXG4gICAgWm9vbUluOiAgICAgICAgICdab29tSW4nLFxyXG4gICAgWm9vbU91dDogICAgICAgICdab29tT3V0JyxcclxuXHJcbiAgICAvLyBEZXZpY2Uga2V5c1xyXG4gICAgQnJpZ2h0bmVzc0Rvd246ICdCcmlnaHRuZXNzRG93bicsXHJcbiAgICBCcmlnaHRuZXNzVXA6ICAgJ0JyaWdodG5lc3NVcCcsXHJcbiAgICBFamVjdDogICAgICAgICAgJ0VqZWN0JyxcclxuICAgIExvZ09mZjogICAgICAgICAnTG9nT2ZmJyxcclxuICAgIFBvd2VyOiAgICAgICAgICAnUG93ZXInLFxyXG4gICAgUG93ZXJPZmY6ICAgICAgICdQb3dlck9mZicsXHJcbiAgICBQcmludFNjcmVlbjogICAgJ1ByaW50U2NyZWVuJyxcclxuICAgIEhpYmVybmF0ZTogICAgICAnSGliZXJuYXRlJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zN1xyXG4gICAgU3RhbmRieTogICAgICAgICdTdGFuZGJ5JywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgV2FrZVVwOiAgICAgICAgICdXYWtlVXAnLFxyXG5cclxuICAgIC8vIElNRSBhbmQgY29tcG9zaXRpb24ga2V5c1xyXG4gICAgQ29tcG9zZTogICAgICAgICdDb21wb3NlJyxcclxuICAgIERlYWQ6ICAgICAgICAgICAnRGVhZCcsXHJcblxyXG4gICAgLy8gRnVuY3Rpb24ga2V5c1xyXG4gICAgRjE6ICAgICAgICAgICAgICdGMScsXHJcbiAgICBGMjogICAgICAgICAgICAgJ0YyJyxcclxuICAgIEYzOiAgICAgICAgICAgICAnRjMnLFxyXG4gICAgRjQ6ICAgICAgICAgICAgICdGNCcsXHJcbiAgICBGNTogICAgICAgICAgICAgJ0Y1JyxcclxuICAgIEY2OiAgICAgICAgICAgICAnRjYnLFxyXG4gICAgRjc6ICAgICAgICAgICAgICdGNycsXHJcbiAgICBGODogICAgICAgICAgICAgJ0Y4JyxcclxuICAgIEY5OiAgICAgICAgICAgICAnRjknLFxyXG4gICAgRjEwOiAgICAgICAgICAgICdGMTAnLFxyXG4gICAgRjExOiAgICAgICAgICAgICdGMTEnLFxyXG4gICAgRjEyOiAgICAgICAgICAgICdGMTInLFxyXG5cclxuICAgIC8vIERvY3VtZW50IGtleXNcclxuICAgIFByaW50OiAgICAgICAgICAnUHJpbnQnLFxyXG5cclxuICAgIC8vICdOb3JtYWwnIGtleXNcclxuICAgIG51bTA6ICAgICAgICAgICAnMCcsXHJcbiAgICBudW0xOiAgICAgICAgICAgJzEnLFxyXG4gICAgbnVtMjogICAgICAgICAgICcyJyxcclxuICAgIG51bTM6ICAgICAgICAgICAnMycsXHJcbiAgICBudW00OiAgICAgICAgICAgJzQnLFxyXG4gICAgbnVtNTogICAgICAgICAgICc1JyxcclxuICAgIG51bTY6ICAgICAgICAgICAnNicsXHJcbiAgICBudW03OiAgICAgICAgICAgJzcnLFxyXG4gICAgbnVtODogICAgICAgICAgICc4JyxcclxuICAgIG51bTk6ICAgICAgICAgICAnOScsXHJcbiAgICBudW1wYWQwOiAgICAgICAgJzAnLFxyXG4gICAgbnVtcGFkMTogICAgICAgICcxJyxcclxuICAgIG51bXBhZDI6ICAgICAgICAnMicsXHJcbiAgICBudW1wYWQzOiAgICAgICAgJzMnLFxyXG4gICAgbnVtcGFkNDogICAgICAgICc0JyxcclxuICAgIG51bXBhZDU6ICAgICAgICAnNScsXHJcbiAgICBudW1wYWQ2OiAgICAgICAgJzYnLFxyXG4gICAgbnVtcGFkNzogICAgICAgICc3JyxcclxuICAgIG51bXBhZDg6ICAgICAgICAnOCcsXHJcbiAgICBudW1wYWQ5OiAgICAgICAgJzknLFxyXG4gICAgYTogICAgICAgICAgICAgICdhJyxcclxuICAgIGI6ICAgICAgICAgICAgICAnYicsXHJcbiAgICBjOiAgICAgICAgICAgICAgJ2MnLFxyXG4gICAgZDogICAgICAgICAgICAgICdkJyxcclxuICAgIGU6ICAgICAgICAgICAgICAnZScsXHJcbiAgICBmOiAgICAgICAgICAgICAgJ2YnLFxyXG4gICAgZzogICAgICAgICAgICAgICdnJyxcclxuICAgIGg6ICAgICAgICAgICAgICAnaCcsXHJcbiAgICBpOiAgICAgICAgICAgICAgJ2knLFxyXG4gICAgajogICAgICAgICAgICAgICdqJyxcclxuICAgIGs6ICAgICAgICAgICAgICAnaycsXHJcbiAgICBsOiAgICAgICAgICAgICAgJ2wnLFxyXG4gICAgbTogICAgICAgICAgICAgICdtJyxcclxuICAgIG46ICAgICAgICAgICAgICAnbicsXHJcbiAgICBvOiAgICAgICAgICAgICAgJ28nLFxyXG4gICAgcDogICAgICAgICAgICAgICdwJyxcclxuICAgIHE6ICAgICAgICAgICAgICAncScsXHJcbiAgICByOiAgICAgICAgICAgICAgJ3InLFxyXG4gICAgczogICAgICAgICAgICAgICdzJyxcclxuICAgIHQ6ICAgICAgICAgICAgICAndCcsXHJcbiAgICB1OiAgICAgICAgICAgICAgJ3UnLFxyXG4gICAgdjogICAgICAgICAgICAgICd2JyxcclxuICAgIHc6ICAgICAgICAgICAgICAndycsXHJcbiAgICB4OiAgICAgICAgICAgICAgJ3gnLFxyXG4gICAgeTogICAgICAgICAgICAgICd5JyxcclxuICAgIHo6ICAgICAgICAgICAgICAneicsXHJcbiAgICBNdWx0aXBseU51bXBhZDogJyonLFxyXG4gICAgUGx1c051bXBhZDogICAgICcrJyxcclxuICAgIE1pbnVzTnVtcGFkOiAgICAnLScsXHJcbiAgICBEb3ROdW1wYWQ6ICAgICAgJy4nLFxyXG4gICAgU2xhc2hOdW1wYWQ6ICAgICcvJyxcclxuICAgIFNlbWljb2xvbjogICAgICAnOycsXHJcbiAgICBFcXVhbDogICAgICAgICAgJz0nLFxyXG4gICAgQ29tbWE6ICAgICAgICAgICcsJyxcclxuICAgIEh5cGhlbjogICAgICAgICAnLScsXHJcbiAgICBNaW51czogICAgICAgICAgJy0nLFxyXG4gICAgUGx1czogICAgICAgICAgICcrJyxcclxuICAgIERvdDogICAgICAgICAgICAnLicsXHJcbiAgICBTbGFzaDogICAgICAgICAgJy8nLFxyXG4gICAgQmFja3F1b3RlOiAgICAgICdgJyxcclxuICAgIExlZnRCcmFja2V0OiAgICAnWycsXHJcbiAgICBSaWdodEJyYWNrZXQ6ICAgJ10nLFxyXG4gICAgQmFja3NsYXNoOiAgICAgICdcXFxcJyxcclxuICAgIFF1b3RlOiAgICAgICAgICBcIidcIixcclxuICAgIE51bXBhZERvdDogICAgICAnLicsXHJcbiAgICBOdW1wYWREb3RBbHQ6ICAgJywnLCAvLyBNb2Rlcm4gYnJvd3NlcnMgYXV0b21hdGljYWxseSBhZGFwdCB0aGUgY2hhcmFjdGVyIHNlbnQgYnkgdGhpcyBrZXkgdG8gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IGxhbmd1YWdlXHJcbiAgICBOdW1wYWRNdWx0aXBseTogJyonLFxyXG4gICAgTnVtcGFkUGx1czogICAgICcrJyxcclxuICAgIE51bXBhZE1pbnVzOiAgICAnLScsXHJcbiAgICBOdW1wYWRTbGFzaDogICAgJy8nLFxyXG4gICAgTnVtcGFkRG90T2Jzb2xldGVCcm93c2VyczogICAgICAnRGVjaW1hbCcsXHJcbiAgICBOdW1wYWRNdWx0aXBseU9ic29sZXRlQnJvd3NlcnM6ICdNdWx0aXBseScsXHJcbiAgICBOdW1wYWRQbHVzT2Jzb2xldGVCcm93c2VyczogICAgICdBZGQnLFxyXG4gICAgTnVtcGFkTWludXNPYnNvbGV0ZUJyb3dzZXJzOiAgICAnU3VidHJhY3QnLFxyXG4gICAgTnVtcGFkU2xhc2hPYnNvbGV0ZUJyb3dzZXJzOiAgICAnRGl2aWRlJyxcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRNaW5pbXVtVmFsdWUgICAgID0gJy05OTk5OTk5OTk5OTkuOTknO1xyXG5jb25zdCBkZWZhdWx0TWF4aW11bVZhbHVlICAgICA9ICc5OTk5OTk5OTk5OTkuOTknO1xyXG5jb25zdCBkZWZhdWx0Um91bmRpbmdNZXRob2QgICA9ICdVJztcclxuY29uc3QgZGVmYXVsdExlYWRpbmdaZXJvICAgICAgPSAnZGVueSc7XHJcbmNvbnN0IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5ID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBQcmVkZWZpbmVkIG9wdGlvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBsYW5ndWFnZXNcclxuICovXHJcbmNvbnN0IGxhbmd1YWdlT3B0aW9uID0ge1xyXG4gICAgRnJlbmNoOiB7IC8vIEZyYW7Dp2Fpc1xyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgIDogJy4nLCAvLyBvciAnXFx1MjAyZidcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICA6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICA6ICdcXHUyMDJm4oKsJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICA6ICdzJyxcclxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgIDogZGVmYXVsdExlYWRpbmdaZXJvLFxyXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgTm9ydGhBbWVyaWNhbjoge1xyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICA6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgIDogJyQnLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXHJcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgIH0sXHJcbiAgICBCcml0aXNoOiB7XHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnwqMnLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXHJcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgIH0sXHJcbiAgICBTd2lzczogeyAvLyBTdWlzc2VcclxuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgIDogYCdgLFxyXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICA6ICdcXHUyMDJmQ0hGJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3MnLFxyXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXHJcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgSmFwYW5lc2U6IHsgLy8g5pel5pys6KqeXHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnwqUnLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXHJcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgIH0sXHJcbiAgICBUdXJraXNoOiB7XHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXI6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbDogJ+KAr+KCuicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6ICdzJyxcclxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5OiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlOiBkZWZhdWx0TWluaW11bVZhbHVlLFxyXG4gICAgICAgIG1heGltdW1WYWx1ZTogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogJ3AnLFxyXG4gICAgfSxcclxufTtcclxubGFuZ3VhZ2VPcHRpb24uU3BhbmlzaCA9IGxhbmd1YWdlT3B0aW9uLkZyZW5jaDsgLy8gRXNwYcOxb2wgKGlkZW0gRnJlbmNoKVxyXG5sYW5ndWFnZU9wdGlvbi5DaGluZXNlID0gbGFuZ3VhZ2VPcHRpb24uSmFwYW5lc2U7IC8vIOS4reWbveiqniAoQ2hpbmVzZSlcclxuXHJcbi8qKlxyXG4gKiBVTUQgc3RydWN0dXJlXHJcbiAqL1xyXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxyXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xyXG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgLy8gTm9kZS9Db21tb25KU1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcclxufSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XHJcbn1cclxufSgkID0+IHtcclxuICAgIGNvbnN0IGpRdWVyeU9yaWdpbmFsVmFsID0gJC5mbi52YWw7XHJcblxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyBudWxsLCBGQUxTRSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgRkFMU0Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgU3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcclxuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgYm9vbGVhblxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAndHJ1ZScgb3IgJ2ZhbHNlJ1xyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1RydWVPckZhbHNlU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVmFsdWUgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZlcmVuY2UgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyZWZlcmVuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eVxyXG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG51bWJlciAob3IgYSBudW1iZXIgd3JpdHRlbiBhcyBhIHN0cmluZykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIobikge1xyXG4gICAgICAgIHJldHVybiAhaXNBcnJheShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgKGFuZCBub3QgYSBmbG9hdCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNJbnQobikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgcGFyc2VGbG9hdChuKSA9PT0gcGFyc2VJbnQobiwgMTApICYmICFpc05hTihuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgcGFzdGVkIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcmVwYXJlUGFzdGVkVGV4dCh0ZXh0LCBob2xkZXIpIHtcclxuICAgICAgICByZXR1cm4gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRleHQsIGhvbGRlci5zZXR0aW5nc0Nsb25lLCB0cnVlKS5yZXBsYWNlKGhvbGRlci5zZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcclxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcclxuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cclxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgLy8gZnVuY3Rpb24gaGFzRGVjaW1hbHMoc3RyKSB7XHJcbiAgICAvLyAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XHJcbiAgICAvLyAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7aW50fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xyXG4gICAgICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY29kZSBmb3IgdGhlIGtleSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3xOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGtleUNvZGVOdW1iZXIoZXZlbnQpIHtcclxuICAgICAgICAvLyBgZXZlbnQua2V5Q29kZWAgYW5kIGBldmVudC53aGljaGAgYXJlIGRlcHJlY2F0ZWQsIGBLZXlib2FyZEV2ZW50LmtleWAgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleSkgbXVzdCBiZSB1c2VkIG5vd1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIGV2ZW50LndoaWNoID09PSAndW5kZWZpbmVkJyk/ZXZlbnQua2V5Q29kZTpldmVudC53aGljaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY2hhcmFjdGVyIGZyb20gdGhlIGV2ZW50IGtleSBjb2RlLlxyXG4gICAgICogQGV4YW1wbGUgY2hhcmFjdGVyKDUwKSA9PiAnMidcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hhcmFjdGVyKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC5rZXkgPT09ICd1bmRlZmluZWQnIHx8IGV2ZW50LmtleSA9PT0gJ1VuaWRlbnRpZmllZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5Q29kZU51bWJlcihldmVudCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgbGlrZSBJRSB0aGF0IHJldHVybiB0aGUgb2xkIG5hbWVzXHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdEZWNpbWFsJzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlOYW1lLk51bXBhZERvdDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ011bHRpcGx5JzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlOYW1lLk51bXBhZE11bHRpcGx5O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQWRkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlOYW1lLk51bXBhZFBsdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdTdWJ0cmFjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWRNaW51cztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0RpdmlkZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWRTbGFzaDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0RlbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCB3b3JrYXJvdW5kIGZvciB0aGUgb2Jzb2xldGUgYnJvd3NlciBJRTExIHdoaWNoIG91dHB1dCBhICdEZWxldGUnIGtleSB3aGVuIHVzaW5nIHRoZSBudW1wYWQgJ2RvdCcgb25lISBUaGlzIGZpeGVzIGlzc3VlICM0MDEgLy9GSVhNRSDDoCB0ZXJtaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuRG90OyAvLyBhcyBvZiB2ZXJzaW9uIDIuMC44IHRoZSBjaGFyYWN0ZXIoKSBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBvbiBrZXlwcmVzcyBldmVudC4gVGhlICdEZWwnIGRvZXMgbm90IHRocm93IHRoZSBrZXlwcmVzcyBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZlbnQua2V5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiB2YWx1ZSAoYSBudW1iZXIgYXMgYSBzdHJpbmcpIGlzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGluIHRoZSBzZXR0aW5ncyBgbWluaW11bVZhbHVlYCBhbmQgYG1heGltdW1WYWx1ZWAsIEZBTFNFIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNaW5WYWx1ZSBQYXJzZWQgdmlhIHRoZSBgcGFyc2VTdHIoKWAgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNYXhWYWx1ZSBQYXJzZWQgdmlhIHRoZSBgcGFyc2VTdHIoKWAgZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGVja0lmSW5SYW5nZSh2YWx1ZSwgcGFyc2VkTWluVmFsdWUsIHBhcnNlZE1heFZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZVN0cih2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRlc3RNaW5NYXgocGFyc2VkTWluVmFsdWUsIHBhcnNlZFZhbHVlKSA+IC0xICYmIHRlc3RNaW5NYXgocGFyc2VkTWF4VmFsdWUsIHBhcnNlZFZhbHVlKSA8IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgbmVnYXRpdmUgc2lnbiA6XHJcbiAgICAgKiAtIGV2ZXJ5d2hlcmUgaW4gdGhlIHN0cmluZyAoYnkgZGVmYXVsdCksIG9yXHJcbiAgICAgKiAtIG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb25seSBpZiB0aGUgYGNoZWNrRXZlcnl3aGVyZWAgcGFyYW1ldGVyIGlzIHNldCB0byBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nIEEgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrRXZlcnl3aGVyZSBJZiBUUlVFLCB0aGVuIHRoZSBuZWdhdGl2ZSBzaWduIGlzIHNlYXJjaCBldmVyeXdoZXJlIGluIHRoZSBudW1lcmljIHN0cmluZyAodGhpcyBpcyBuZWVkZWQgZm9yIGluc3RhbmNlIGlmIHRoZSBzdHJpbmcgaXMgJzEyMzQuNTYtJylcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc05lZ2F0aXZlKG51bWVyaWNTdHJpbmcsIGNoZWNrRXZlcnl3aGVyZSA9IHRydWUpIHtcclxuICAgICAgICAvL1RPRE8gVXNlIHRoZSBgbmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBmcm9tIHRoZSBzZXR0aW5ncyBoZXJlXHJcbiAgICAgICAgaWYgKGNoZWNrRXZlcnl3aGVyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnMobnVtZXJpY1N0cmluZywgJy0nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlU3RyaWN0KG51bWVyaWNTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBhIG5lZ2F0aXZlIHNpZ24gb24gdGhlIGZpcnN0IGNoYXJhY3RlciAob24gdGhlIGZhciBsZWZ0KS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCcxMjM0LjU2JykgICAgID0+IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCcxMjM0LjU2LScpICAgID0+IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCctMTIzNC41NicpICAgID0+IHRydWVcclxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJy0xLDIzNC41NiDigqwnKSA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc05lZ2F0aXZlU3RyaWN0KG51bWVyaWNTdHJpbmcpIHtcclxuICAgICAgICAvL1RPRE8gVXNpbmcgdGhlIGBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXJgIGZyb20gdGhlIHNldHRpbmdzIGhlcmVcclxuICAgICAgICByZXR1cm4gbnVtZXJpY1N0cmluZy5jaGFyQXQoMCkgPT09ICctJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBmb3JtYXR0ZWQgb3IgdW5mb3JtYXR0ZWQgbnVtZXJpYyBzdHJpbmcgcmVwcmVzZW50IHRoZSB2YWx1ZSAwIChpZS4gJzAsMDAg4oKsJyksIG9yIGlzIGVtcHR5ICgnIOKCrCcpLlxyXG4gICAgICogVGhpcyB3b3JrcyBzaW5jZSB3ZSB0ZXN0IGlmIHRoZXJlIGFyZSBhbnkgbnVtYmVycyBmcm9tIDEgdG8gOSBpbiB0aGUgc3RyaW5nLiBJZiB0aGVyZSBpcyBub25lLCB0aGVuIHRoZSBudW1iZXIgaXMgemVybyAob3IgdGhlIHN0cmluZyBpcyBlbXB0eSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1plcm9Pckhhc05vVmFsdWUobnVtZXJpY1N0cmluZykge1xyXG4gICAgICAgIHJldHVybiAhKC9bMS05XS9nKS50ZXN0KG51bWVyaWNTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSAocmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcpIGdpdmVuIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldFJhd05lZ2F0aXZlU2lnbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICghaXNOZWdhdGl2ZVN0cmljdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAtJHt2YWx1ZX1gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSB0aGUgY2hhcmFjdGVyIGF0IHRoZSBwb3NpdGlvbiBgaW5kZXhgIGluIHRoZSBzdHJpbmcgYHN0cmluZ2AgYnkgdGhlIGNoYXJhY3RlcihzKSBgbmV3Q2hhcmFjdGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gaW5kZXhcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdDaGFyYWN0ZXJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VDaGFyQXQoc3RyaW5nLCBpbmRleCwgbmV3Q2hhcmFjdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3N0cmluZy5zdWJzdHIoMCwgaW5kZXgpfSR7bmV3Q2hhcmFjdGVyfSR7c3RyaW5nLnN1YnN0cihpbmRleCArIG5ld0NoYXJhY3Rlci5sZW5ndGgpfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIGNsYW1wZWQgdG8gdGhlIG5lYXJlc3QgbWluaW11bS9tYXhpbXVtIHZhbHVlLCBhcyBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsYW1wVG9SYW5nZUxpbWl0cyh2YWx1ZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICAvL1hYWCBUaGlzIGZ1bmN0aW9uIGFsd2F5cyBhc3N1bWUgYHNldHRpbmdzLm1pbmltdW1WYWx1ZWAgaXMgbG93ZXIgdGhhbiBgc2V0dGluZ3MubWF4aW11bVZhbHVlYFxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIE1hdGgubWluKHNldHRpbmdzLm1heGltdW1WYWx1ZSwgdmFsdWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIG51bWJlciBvciBkb3QgY2hhcmFjdGVycyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBjYXJldCwgaW4gYSBmb3JtYXR0ZWQgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7aW50fSBjYXJldFBvc2l0aW9uIFRoaXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgLy8gSGVyZSB3ZSBjb3VudCB0aGUgZG90IGFuZCByZXBvcnQgaXQgYXMgYSBudW1iZXIgY2hhcmFjdGVyIHRvbywgc2luY2UgaXQgd2lsbCAnc3RheScgaW4gdGhlIEphdmFzY3JpcHQgbnVtYmVyIHdoZW4gdW5mb3JtYXR0ZWRcclxuICAgICAgICBjb25zdCBudW1iZXJEb3RPck5lZ2F0aXZlU2lnbiA9IG5ldyBSZWdFeHAoYFswLTkke2RlY2ltYWxDaGFyYWN0ZXJ9LV1gKTsgLy8gTm8gbmVlZCB0byBlc2NhcGUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGhlcmUsIHNpbmNlIGl0J3MgaW4gYFtdYFxyXG5cclxuICAgICAgICBsZXQgbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZXRQb3NpdGlvbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIGNoYXJhY3RlciBpcyBhIG51bWJlciwgYSBkb3Qgb3IgYW4gaHlwaGVuLiBJZiBpdCBpcywgY291bnQgaXQsIG90aGVyd2lzZSBpZ25vcmUgaXRcclxuICAgICAgICAgICAgaWYgKG51bWJlckRvdE9yTmVnYXRpdmVTaWduLnRlc3QoZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2FsayB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ2AgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBvbmUgY2hhciBieSBvbmUsIGNvdW50aW5nIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhgLlxyXG4gICAgICogSWYgdGhlIGNoYXIgaXMgaW4gdGhlIGByYXdOdW1iZXJTdHJpbmdgIChzdGFydGluZyBhdCBpbmRleCAwKSwgdGhlbiBgcmF3TnVtYmVyU3RyaW5nSW5kZXgrK2AsIGFuZCBjb250aW51ZSB1bnRpbFxyXG4gICAgICogdGhlcmUgaXMgbm8gbW9yZSBjaGFyYWN0ZXJzIGluIGByYXdOdW1iZXJTdHJpbmdgKSBvciB0aGF0IGByYXdOdW1iZXJTdHJpbmdJbmRleCA9PT0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVgLlxyXG4gICAgICogV2hlbiB5b3Ugc3RvcCwgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleGAgaXMgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBjYXJldCBzaG91bGQgYmUgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAxMjM0NTY3fDg5LjAxICAgOiBwb3NpdGlvbiA3IChyYXdOdW1iZXJTdHJpbmcpXHJcbiAgICAgKiAxMjMuNDU2Ljd8ODksMDEgOiBwb3NpdGlvbiA5IChmb3JtYXR0ZWROdW1iZXJTdHJpbmcpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJhd051bWJlclN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjaW1hbENoYXJhY3RlclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIocmF3TnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZSwgZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSA9IGZvcm1hdHRlZE51bWJlclN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgcmF3TnVtYmVyU3RyaW5nU2l6ZSA9IHJhd051bWJlclN0cmluZy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGxldCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleDtcclxuICAgICAgICBsZXQgcmF3TnVtYmVyU3RyaW5nSW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplICYmXHJcbiAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IHJhd051bWJlclN0cmluZ1NpemUgJiZcclxuICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4IDwgY2FyZXRQb3NpdGlvbkluUmF3VmFsdWU7XHJcbiAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdbZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhdIHx8XHJcbiAgICAgICAgICAgICAgICAocmF3TnVtYmVyU3RyaW5nW3Jhd051bWJlclN0cmluZ0luZGV4XSA9PT0gJy4nICYmIGZvcm1hdHRlZE51bWJlclN0cmluZ1tmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleF0gPT09IGRlY2ltYWxDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3VudCB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGNoYXJhY3RlciwgaW4gdGhlIGdpdmVuIHRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvdW50Q2hhckluVGV4dChjaGFyYWN0ZXIsIHRleHQpIHtcclxuICAgICAgICBsZXQgY2hhckNvdW50ZXIgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGV4dFtpXSA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRlcisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hhckNvdW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IHRoZSBjYXJldCBwb3NpdGlvbi5cclxuICAgICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoYXQgdGhlIHBvc2l0aW9uIGlzIHN0YXJ0aW5nIGF0ICcwJywgbm90IDEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbnR9IGNoYXJhY3RlckNvdW50XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY2hhcmFjdGVyQ291bnQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY2hhcmFjdGVyQ291bnQsIGNoYXJhY3RlckNvdW50IC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gdGhhdFxyXG4gICAgICogQHJldHVybnMge3t9fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xyXG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBzZWxlY3QudGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSB0aGF0LnNlbGVjdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSB0aGF0LnNlbGVjdGlvbkVuZDtcclxuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gdGhhdFxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0XHJcbiAgICAgKiBAcGFyYW0ge2ludHxudWxsfSBlbmRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNlbGVjdGlvbih0aGF0LCBzdGFydCwgZW5kID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZW5kKSkge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xyXG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcclxuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XHJcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xyXG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uRW5kID0gZW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdGhyb3cgZXJyb3IgbWVzc2FnZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VzLCBhY2NvcmRpbmcgdG8gdGhlIGRlYnVnIGxldmVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dXYXJuaW5nIElmIEZBTFNFLCB0aGVuIHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgbm90IGRpc3BsYXllZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHNob3dXYXJuaW5nID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChzaG93V2FybmluZykge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXV0b051bWVyaWMtc3BlY2lmaWMgZnVuY3Rpb25zXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gYW55IGNhbGxiYWNrcyBmb3VuZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxyXG4gICAgICogQW55IHBhcmFtZXRlciBjb3VsZCBiZSBhIGNhbGxiYWNrOlxyXG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXHJcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBMb29wcyB0aHJvdWdoIHRoZSBzZXR0aW5ncyBvYmplY3QgKG9wdGlvbiBhcnJheSkgdG8gZmluZCB0aGUgZm9sbG93aW5nXHJcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoaywgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trXSA9IHZhbCgkdGhpcywgc2V0dGluZ3MsIGspO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trXSA9ICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0oJHRoaXMsIHNldHRpbmdzLCBrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lIHRoZSBtYXhpbXVtIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIHNldHRpbmdzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbmltdW1WYWx1ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1heGltdW1WYWx1ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChkZWNpbWFsUGxhY2VzKG1pbmltdW1WYWx1ZSksIGRlY2ltYWxQbGFjZXMobWF4aW11bVZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpcCBhbGwgdW53YW50ZWQgbm9uLW51bWJlciBjaGFyYWN0ZXJzLlxyXG4gICAgICogVGhpcyBrZWVwcyB0aGUgbnVtYmVycywgdGhlIG5lZ2F0aXZlIHNpZ24gYXMgd2VsbCBhcyB0aGUgY3VzdG9tIGRlY2ltYWwgY2hhcmFjdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVmdE9yQWxsXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhzLCBzZXR0aW5ncywgbGVmdE9yQWxsKSB7XHJcbiAgICAgICAgLy9UT0RPIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIDEwIHRpbWVzIChzaWMhKSBvbiBlYWNoIGtleSBpbnB1dCwgY291bGRuJ3Qgd2UgbG93ZXIgdGhhdCBudW1iZXI/IGNmLiBpc3N1ZSAjMzI1XHJcbiAgICAgICAgLy9UT0RPIFJlZmFjdG9yIHRoaXMgd2l0aCBgY29udmVydFRvTnVtZXJpY1N0cmluZygpYCBpZiBwb3NzaWJsZT9cclxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJyZW5jeSBzaWduXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnN1ZmZpeFRleHQpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHN1ZmZpeFxyXG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbnMocywgc2V0dGluZ3Muc3VmZml4VGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc3VmZml4VGV4dCwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcclxuXHJcbiAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8XHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJlxyXG4gICAgICAgICAgICBpc05lZ2F0aXZlKHMpICYmXHJcbiAgICAgICAgICAgIHMgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAsICckMScpO1xyXG5cclxuICAgICAgICAvLyBUaGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGluZyBjaGFyYWN0ZXJzXHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwLCAnJyk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSwgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXQgb25seSBudW1iZXIgc3RyaW5nXHJcbiAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwKTtcclxuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MubGVhZGluZ1plcm8gPT09ICdhbGxvdycgfHwgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09ICdrZWVwJykge1xyXG4gICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcclxuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0O1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgblNpZ24gPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxyXG4gICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludFBvcyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcclxuICAgICAgICAgICAgaWYgKG5TaWduICE9PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnROZWcgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciArIGRlY2ltYWxQYXJ0fWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGxlZnRPckFsbCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB8fFxyXG4gICAgICAgICAgICAoIXNldHRpbmdzLmhhc0ZvY3VzICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnKSkge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN0cmlwUmVnLCAnJDEkMicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzLCBkZXBlbmRpbmcgb24gdGhlIGZvY3VzIHN0YXRlLlxyXG4gICAgICogVGhlIGZvY3VzIHN0YXRlIGlzICdzdG9yZWQnIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgdW5kZXIgdGhlIGBzZXR0aW5ncy5oYXNGb2N1c2AgYXR0cmlidXRlLlxyXG4gICAgICogLy9UT0RPIFVzZSBhbm90aGVyIG9iamVjdCB0byBrZWVwIHRyYWNrIG9mIGludGVybmFsIGRhdGEgdGhhdCBhcmUgbm90IHNldHRpbmdzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmICgoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB8fFxyXG4gICAgICAgICAgICAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3AnKSkge1xyXG4gICAgICAgICAgICAvL1RPRE8gU3BsaXQgdGhlIGZpcnN0IGFuZCBsYXN0IGJyYWNrZXQgb25seSBvbmNlIGR1cmluZyB0aGUgc2V0dGluZ3MgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNGb2N1cykge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xyXG4gICAgICAgICAgICAgICAgcyA9IGZpcnN0QnJhY2tldCArIHMgKyBsYXN0QnJhY2tldDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5oYXNGb2N1cyAmJiBzLmNoYXJBdCgwKSA9PT0gZmlyc3RCcmFja2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYnJhY2tldHNcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBRdWlkIGlmIHRoZSBuZWdhdGl2ZSBzaWduIGlzIG5vdCBvbiB0aGUgbGVmdCwgc2hvdWxkbid0IHdlIHJlcGxhY2UgdGhlICctJyBzaWduIGF0IHRoZSByaWdodCBwbGFjZT9cclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZmlyc3RCcmFja2V0LCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIG51bWJlciBhcyBhIG51bWVyaWMgc3RyaW5nIHRoYXQgY2FuIGJlIHR5cGVjYXN0IHRvIGEgTnVtYmVyIHRoYXQgSmF2YXNjcmlwdCB3aWxsIHVuZGVyc3RhbmQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm4gdGhlIGdpdmVuIHN0cmluZyBieSBzdHJpcHBpbmcgdGhlIGN1cnJlbmN5IHNpZ24gKGN1cnJlbmN5U3ltYm9sKSwgdGhlIGdyb3VwaW5nIHNlcGFyYXRvcnMgKGRpZ2l0YWxHcm91cFNwYWNpbmcpIGFuZCBieSByZXBsYWNpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIChkZWNpbWFsQ2hhcmFjdGVyKSBieSBhIGRvdC5cclxuICAgICAqIExhc3RseSwgaXQgYWxzbyBwdXQgdGhlIG5lZ2F0aXZlIHNpZ24gYmFjayB0byBpdHMgbm9ybWFsIHBvc2l0aW9uIGlmIG5lZWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR8WE1MfCp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb051bWVyaWNTdHJpbmcocywgc2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbmN5IHN5bWJvbFxyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBncm91cGluZyBzZXBhcmF0b3JzICh0aG91c2FuZHMgc2VwYXJhdG9ycyB1c3VhbGx5KVxyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciwgJycpO1xyXG5cclxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBieSBhIGRvdFxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTW92ZSB0aGUgdHJhaWxpbmcgbmVnYXRpdmUgc2lnbiB0byB0aGUgcmlnaHQgcG9zaXRpb24sIGlmIGFueVxyXG4gICAgICAgIGlmIChpc05lZ2F0aXZlKHMpICYmIHMubGFzdEluZGV4T2YoJy0nKSA9PT0gcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgICAgIHMgPSAnLScgKyBzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBhbnkgYXJhYmljIG51bWJlcnMgdG8gbGF0aW4gb25lc1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBhcmFiaWNUb0xhdGluTnVtYmVycyhzLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIGlmICghaXNOYU4odGVtcCkpIHtcclxuICAgICAgICAgICAgcyA9IHRlbXAudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50LlxyXG4gICAgICogU2VlIHRoZSBcIm91dHB1dEZvcm1hdFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0xvY2FsZSh2YWx1ZSwgbG9jYWxlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChsb2NhbGUpIHx8IGxvY2FsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKGxvY2FsZSkge1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcuLSc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpc05lZ2F0aXZlKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcsJzpcclxuICAgICAgICAgICAgY2FzZSAnLSwnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnLC0nOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpc05lZ2F0aXZlKHJlc3VsdCkgPyByZXN1bHQucmVwbGFjZSgnLScsICcnKSArICctJyA6IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjYXNlXHJcbiAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICBjYXNlICctLic6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBnaXZlbiBvdXRwdXRGb3JtYXQgWyR7bG9jYWxlfV0gb3B0aW9uIGlzIG5vdCByZWNvZ25pemVkLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9mIHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgdG8gYW4gaHlwaGVuICgtKSBhbmQgYSBkb3QgKC4pIGluIG9yZGVyIHRvIG1ha2UgdGhhdCB2YWx1ZSAndHlwZWNhc3RhYmxlJyB0byBhIHJlYWwgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZShzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJy0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSBgZ2V0YCBpcyBub3QgZm9ybWF0dGVkIHdpdGggZGVjaW1hbHNcclxuICAgICAgICAgICAgcyArPSAnMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIHVzZSB0aG9zZSBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUocywgc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yIGVtcHR5IHZhbHVlXHJcbiAgICAgKiAvL1RPRE8gTW9kaWZ5IHRoaXMgZnVuY3Rpb24gc28gdGhhdCBpdCByZXR1cm4gZWl0aGVyIFRSVUUgb3IgRkFMU0UgaWYgdGhlIHZhbHVlIGlzIGVtcHR5LiBUaGVuIGNyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgaW5wdXQgdmFsdWUgaWYgaXQncyBub3QgZW1wdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWduT25FbXB0eVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHNpZ25PbkVtcHR5KSB7XHJcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8IGlucHV0VmFsdWUgPT09IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnYWx3YXlzJyB8fCBzaWduT25FbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSA/IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIHNldHRpbmdzLnN1ZmZpeFRleHQgOiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IHRoZSBpbnB1dCB2YWx1ZSBieSBhZGRpbmcgdGhlIGdyb3VwIHNlcGFyYXRvcnMsIGFzIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRHcm91cFNlcGFyYXRvcnMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3Muc3RyaXApIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhpbnB1dFZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPIFRoaXMgZnVuY3Rpb24gYGFkZEdyb3VwU2VwYXJhdG9ycygpYCBhZGQgZ3JvdXAgc2VwYXJhdG9ycy4gQWRkaW5nIHRoZSBuZWdhdGl2ZSBzaWduIGFzIHdlbGwgaXMgb3V0IG9mIGl0cyBzY29wZS4gTW92ZSB0aGF0IHRvIGFub3RoZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUoaW5wdXRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICctJyArIGlucHV0VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IGlzVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgaXNaZXJvID0gaXNaZXJvT3JIYXNOb1ZhbHVlKGlucHV0VmFsdWUpO1xyXG4gICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKGVtcHR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nID0gc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZy50b1N0cmluZygpO1xyXG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXA7XHJcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJzInOlxyXG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcycyc6XHJcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICc0JzpcclxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcclxuICAgICAgICBsZXQgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XHJcbiAgICAgICAgICAgIFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIFJlLWluc2VydHMgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB2aWEgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0YWxHcm91cC50ZXN0KGludGVnZXJQYXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yfSQyYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgIT09IDAgJiYgIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBKb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGludGVnZXJQYXJ0ICsgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciArIGRlY2ltYWxQYXJ0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiBpdCdzIGFuIGludGVnZXJcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGludGVnZXJQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke2lucHV0VmFsdWV9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn0ke2lucHV0VmFsdWV9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke2lucHV0VmFsdWV9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke2lucHV0VmFsdWV9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHBsYWNlcyBicmFja2V0c1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGlzTmVnYXRpdmVTdHJpY3QoaW5wdXRWYWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1bmNhdGUgbm90IG5lZWRlZCB6ZXJvc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3VuZGVkSW5wdXRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHtpbnR9IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR8WE1MfHN0cmluZ3wqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZVplcm9zKHJvdW5kZWRJbnB1dFZhbHVlLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICBsZXQgcmVnZXg7XHJcbiAgICAgICAgc3dpdGNoICh0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudHMgcGFkZGluZyAtIHJlbW92ZXMgdHJhaWxpbmcgemVyb3MgdW50aWwgdGhlIGZpcnN0IHNpZ25pZmljYW50IGRpZ2l0IGlzIGVuY291bnRlcmVkXHJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBlcXVhbHMgb25lIC0gbGVhdmVzIG9uZSB6ZXJvIHRyYWlsaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLlxcZCg/OlxcZCpbMS05XSk/KTAqJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVzIGFjY2VzcyB6ZXJvcyB0byB0aGUgZGVjaW1hbFBsYWNlc092ZXJyaWRlIGxlbmd0aCB3aGVuIGFsbG93RGVjaW1hbFBhZGRpbmcgaXMgc2V0IHRvIHRydWVcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHt0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGV9fSg/OlxcXFxkKlsxLTldKT8pMCpgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkZWNpbWFsIHBsYWNlcywgd2UgZG9uJ3QgbmVlZCBhIGRlY2ltYWwgcG9pbnQgYXQgdGhlIGVuZFxyXG4gICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZShyZWdleCwgJyQxJyk7XHJcbiAgICAgICAgaWYgKHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UoL1xcLiQvLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcm91bmRlZElucHV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3VuZCB0aGUgaW5wdXQgdmFsdWUgdXNpbmcgdGhlIHJvdW5kaW5nIG1ldGhvZCBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBtdWx0aXBsZSByb3VuZGluZyBtZXRob2RzLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aG9zZS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIDogVGhpcyBpcyBoYW5kbGVkIGFzIHRleHQgc2luY2UgSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kVmFsdWUoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICBpbnB1dFZhbHVlID0gKGlucHV0VmFsdWUgPT09ICcnKSA/ICcwJyA6IGlucHV0VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdOMDUnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQ0hGJyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdEMDUnKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ04wNSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLnJvdW5kKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1UwNSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmNlaWwoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmZsb29yKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKCFjb250YWlucyhpbnB1dFZhbHVlLCAnLicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgJy4wMCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZS5sZW5ndGggLSBpbnB1dFZhbHVlLmluZGV4T2YoJy4nKSA8IDMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnMCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaXZSb3VuZGVkID0gJyc7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGxldCBuU2lnbiA9ICcnO1xyXG4gICAgICAgIGxldCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XHJcblxyXG4gICAgICAgIC8vIHNldHMgdGhlIHRydW5jYXRlIHplcm8gbWV0aG9kXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcpIHtcclxuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGlucHV0VmFsdWUgKGlucHV0IFZhbHVlKSBpcyBhIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVTdHJpY3QoaW5wdXRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgblNpZ24gPSAnLSc7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHRoYXQgd2lsbCBiZSBhZGRlZCBiYWNrIGxhdGVyIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgYSB6ZXJvIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90KVxyXG4gICAgICAgIGlmICghaW5wdXRWYWx1ZS5tYXRjaCgvXlxcZC8pKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnMCcgKyBpbnB1dFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxyXG4gICAgICAgIGlmIChOdW1iZXIoaW5wdXRWYWx1ZSkgPT09IDApIHtcclxuICAgICAgICAgICAgblNpZ24gPSAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgemVybydzIGFzIG5lZWRlZFxyXG4gICAgICAgIGlmICgoTnVtYmVyKGlucHV0VmFsdWUpID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB8fCAoaW5wdXRWYWx1ZS5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnKSkge1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZFBvcyA9IGlucHV0VmFsdWUubGFzdEluZGV4T2YoJy4nKTtcclxuICAgICAgICBjb25zdCBpbnB1dFZhbHVlSGFzQURvdCA9IGRQb3MgPT09IC0xO1xyXG5cclxuICAgICAgICAvLyBWaXJ0dWFsIGRlY2ltYWwgcG9zaXRpb25cclxuICAgICAgICBjb25zdCB2ZFBvcyA9IGlucHV0VmFsdWVIYXNBRG90ID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZFBvcztcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGRlY2ltYWwgcGxhY2VzIHRvIGRldGVybWluZSBpZiByb3VuZGluZyBpcyByZXF1aXJlZCA6XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgbm8gcm91bmRpbmcgaXMgcmVxdWlyZWRcclxuICAgICAgICBsZXQgY0RlYyA9IChpbnB1dFZhbHVlLmxlbmd0aCAtIDEpIC0gdmRQb3M7XHJcblxyXG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXHJcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChjRGVjIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZUhhc0FEb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb3MgPSAnMDAwMDAwJztcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjRGVjIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvcy5zdWJzdHJpbmcoMCwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gY0RlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPT09IDAgJiYgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcclxuICAgICAgICBsZXQgckxlbmd0aDtcclxuICAgICAgICBpZiAoaW5wdXRWYWx1ZUhhc0FEb3QpIHtcclxuICAgICAgICAgICAgckxlbmd0aCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSAtIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgckxlbmd0aCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSArIGRQb3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0Um91bmQgPSBOdW1iZXIoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCArIDEpKTtcclxuICAgICAgICBjb25zdCBvZGQgPSAoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCkgPT09ICcuJykgPyAoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCAtIDEpICUgMikgOiAoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCkgJSAyKTtcclxuICAgICAgICBsZXQgaXZBcnJheSA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XHJcblxyXG4gICAgICAgIGlmICgodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnYScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnYScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxyXG4gICAgICAgICAgICAodFJvdW5kID09PSA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQicgJiYgb2RkID09PSAxKSAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdDJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCB0byBjZWlsaW5nIHRvd2FyZCBwb3NpdGl2ZSBpbmZpbml0ZVxyXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxyXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UnKSkgeyAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIGF3YXkgZnJvbSB6ZXJvXHJcbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXHJcbiAgICAgICAgICAgIGZvciAoaSA9IChpdkFycmF5Lmxlbmd0aCAtIDEpOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gJzAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIHN0cmluZywgY29udmVydGluZyBhbnkgMTAncyB0byAwJ3NcclxuICAgICAgICBpdkFycmF5ID0gaXZBcnJheS5zbGljZSgwLCByTGVuZ3RoICsgMSk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgcm91bmRlZCB2YWx1ZVxyXG4gICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZBcnJheS5qb2luKCcnKSwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydW5jYXRlcyB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRydW5jYXRlRGVjaW1hbChzLCBzZXR0aW5ncywgaXNQYXN0ZSkge1xyXG4gICAgICAgIHMgPSAoaXNQYXN0ZSkgPyByb3VuZFZhbHVlKHMsIHNldHRpbmdzKSA6IHM7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICYmIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcblxyXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XHJcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWREZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBgJHtpbnRlZ2VyUGFydH0ke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHttb2RpZmllZERlY2ltYWxQYXJ0fWA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSBtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSAmIHRoZSBpbnB1dCB2YWx1ZSB0byBwcmVwYXJlIGZvciB0ZXN0aW5nIHRvIGRldGVybWluZSBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gLyBtYXggcmFuZ2UuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IGV4YW1wbGU6IG1pbmltdW1WYWx1ZTogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCIuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy8uIE1hbnkgdGhhbmtzIHRvIE1pa2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuIEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHIobikge1xyXG4gICAgICAgIGNvbnN0IHggPSB7fTsgLy8gQSBCaWcgbnVtYmVyIGluc3RhbmNlLlxyXG4gICAgICAgIGxldCBlO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGxldCBuTDtcclxuICAgICAgICBsZXQgajtcclxuXHJcbiAgICAgICAgLy8gTWludXMgemVybz9cclxuICAgICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcclxuICAgICAgICAgICAgbiA9ICctMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcclxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChpc05lZ2F0aXZlU3RyaWN0KG4pKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB4LnMgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LnMgPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgaWYgKGUgPiAtMSkge1xyXG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgIGlmIChlIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBJbnRlZ2VyXHJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXHJcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xyXG4gICAgICAgIG5MID0gbi5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XHJcbiAgICAgICAgICAgIC8vIFplcm9cclxuICAgICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgICAgeC5jID0gWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvc1xyXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuTCAtPSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVjaW1hbCBsb2NhdGlvblxyXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XHJcbiAgICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHguY1tlXSA9ICtuLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIGUgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byB0ZXN0IGlmIHRoZSBpbnB1dCB2YWx1ZSBmYWxscyB3aXRoIHRoZSBNaW4gLyBNYXggc2V0dGluZ3MuXHJcbiAgICAgKiBUaGlzIHVzZXMgdGhlIHBhcnNlZCBzdHJpbmdzIGZvciB0aGUgYWJvdmUgcGFyc2VTdHIgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy8uIE1hbnkgdGhhbmtzIHRvIE1pa2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHkgQmlnIG51bWJlciBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHggQmlnIG51bWJlciBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0geC5jO1xyXG4gICAgICAgIGNvbnN0IHljID0geS5jO1xyXG4gICAgICAgIGxldCBpID0geC5zO1xyXG4gICAgICAgIGxldCBqID0geS5zO1xyXG4gICAgICAgIGxldCBrID0geC5lO1xyXG4gICAgICAgIGxldCBsID0geS5lO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoIXhjWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoaSAhPT0gaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeE5lZyA9IGkgPCAwO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50c1xyXG4gICAgICAgIGlmIChrICE9PSBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcclxuICAgICAgICBsID0geWMubGVuZ3RoO1xyXG4gICAgICAgIGogPSAoayA8IGwpID8gayA6IGw7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXRcclxuICAgICAgICBmb3IgKGkgKz0gMTsgaSA8IGo7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhjW2ldID4geWNbaV0gXiB4TmVnKT8xOi0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHNcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGlmIChrID09PSBsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gKGsgPiBsIF4geE5lZyk/MTotMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBudW1iZXIgc2F0aXNmeSB0aGUgZm9ybWF0IGNvbmRpdGlvbnNcclxuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3MubWluaW11bVZhbHVlIGFuZCBzZXR0aW5ncy5tYXhpbXVtVmFsdWVcclxuICAgICAqIGFuZCB0aGUgc3RyaW5nIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgdGhlIGRpZ2l0cyBpbiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgYW5kIHNldHRpbmdzLm1heGltdW1WYWx1ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbihzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLCcsICcuJyk7XHJcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcclxuICAgICAgICBjb25zdCB2YWxQYXJzZSA9IHBhcnNlU3RyKHMpO1xyXG5cclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mub3ZlcnJpZGVNaW5NYXhMaW1pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxlbWVudFxyXG4gICAgICogQHJldHVybnMgeyp8alF1ZXJ5fEhUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RWxlbWVudChlbGVtZW50KSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIChhbmQgdGhlcmVmb3JlIGlzIGEgQ1NTIHNlbGVjdG9yKSwgdGhlbiB3ZSBuZWVkIHRvIG1vZGlmeSB0aGlzIHN0cmluZyBpbiBvcmRlclxyXG4gICAgICAgICAqIGZvciBqUXVlcnkgdG8gYmUgYWJsZSB0byBwYXJzZSB0aGUgc2VsZWN0b3IgY29ycmVjdGx5LlxyXG4gICAgICAgICAqIGNmLiBodHRwOi8vbGVhcm4uanF1ZXJ5LmNvbS91c2luZy1qcXVlcnktY29yZS9mYXEvaG93LWRvLWktc2VsZWN0LWFuLWVsZW1lbnQtYnktYW4taWQtdGhhdC1oYXMtY2hhcmFjdGVycy11c2VkLWluLWNzcy1ub3RhdGlvbi9cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgLy9UT0RPIFRoaXMgYmxvY2sgaXMgYXBwYXJlbnRseSBuZXZlciBlbnRlcmVkLiBXZSBzaG91bGQgcmVtb3ZlIGl0IGFmdGVyIG1ha2luZyBzdXJlIHRoYXQncyAxMDAlIHRoZSBjYXNlXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBgIyR7ZWxlbWVudC5yZXBsYWNlKC8oOnxcXC58XFxbfF18LHw9KS9nLCAnXFxcXCQxJyl9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAkKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdGhhdCBhdHRhY2ggdGhlIGF1dG9OdW1lcmljIGZpZWxkIHByb3BlcnRpZXMgdG8gdGhlIERPTSBlbGVtZW50IHZpYSBhbiBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdXBkYXRlID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgZGF0YSA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBob2xkZXIgPSBkYXRhLmhvbGRlcjtcclxuICAgICAgICBpZiAodXBkYXRlIHx8IChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSkge1xyXG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoaXMuZ2V0KDApLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGRhdGEuaG9sZGVyID0gaG9sZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXHJcbiAgICAgKiBUaG9zZSBvcmlnaW5hbCBzZXR0aW5ncyBhcmUgdXNlZCBleGNsdXNpdmVseSBpbiB0aGUgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncykge1xyXG4gICAgICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9sZCBvcHRpb24gbmFtZXMgdG8gdGhlIG5ldyBvbmVzXHJcbiAgICAgICAgc2V0dGluZ3Mub0RlYyAgICAgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XHJcbiAgICAgICAgc2V0dGluZ3Mub1BhZCAgICAgPSBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nO1xyXG4gICAgICAgIHNldHRpbmdzLm9CcmFja2V0ID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI7XHJcbiAgICAgICAgc2V0dGluZ3Mub1NlcCAgICAgPSBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yO1xyXG4gICAgICAgIHNldHRpbmdzLm9TaWduICAgID0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XHJcbiAgICAgICAgc2V0dGluZ3Mub1N1ZmZpeCAgPSBzZXR0aW5ncy5zdWZmaXhUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCAmIGBub1NlcGFyYXRvck9uRm9jdXNgIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXHJcbiAgICAgKiBUaGlzIGlzIHRha2VuIGZyb20gUXVpcmtzbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlYWRDb29raWUobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XHJcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcclxuICAgICAgICBsZXQgYyA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgYyA9IGNhW2ldO1xyXG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBzZXNzaW9uU3RvcmFnZSBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBUaGlzIGlzIHRha2VuIGZyb20gTW9kZXJuaXpyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcclxuICAgICAgICBjb25zdCBtb2QgPSAnbW9kZXJuaXpyJztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcclxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBwcm9wZXJseSBmb3JtYXRzIHRoZSBzdHJpbmcgdG8gYSBudW1lcmljIHdoZW4gbGVhZGluZ1plcm8gZG9lcyBub3QgJ2tlZXAnLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIC8vIFJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlzIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IGVtcHR5LiBUaGlzIHByZXZlbnQgY29udmVydGluZyB0aGF0IHZhbHVlIHRvICcwJy5cclxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHVybiAnMCcgaWYgdGhlIHZhbHVlIGlzIHplcm9cclxuICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykge1xyXG4gICAgICAgICAgICAvLyBUcmltIGxlYWRpbmcgemVybydzIC0gbGVhdmVzIG9uZSB6ZXJvIHRvIHRoZSBsZWZ0IG9mIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXigtKT8wKyg/PVxcZCkvZywnJDEnKTtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyByZW1vdmUgdGhpcyBmcm9tIHRoYXQgZnVuY3Rpb24gYW5kIHVzZSBgdHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMoKWAgaW5zdGVhZC4gQWxzbyBjcmVhdGUgYSBuZXcgYHRyYWlsaW5nWmVyb2Agb3B0aW9uLlxyXG4gICAgICAgICAgICBpZiAoY29udGFpbnModmFsdWUsICcuJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyaW1zIHRyYWlsaW5nIHplcm9zIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC5bMC05XSo/KTArJC8sICckMScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN0cmlwcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIHRyYWlsaW5nIHplcm9zIGluIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyhudW1lcmljU3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBudW1lcmljU3RyaW5nLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShkZWNpbWFsUGFydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVnZXJQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdHJpbW1lZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQucmVwbGFjZSgvMCskL2csICcnKTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAodHJpbW1lZERlY2ltYWxQYXJ0ID09PSAnJykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBgJHtpbnRlZ2VyUGFydH0uJHt0cmltbWVkRGVjaW1hbFBhcnR9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBicm93c2VyIGlzIHN1cHBvcnRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEV2ZW50VGFyZ2V0fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKGVsZW1lbnQsIHNldHRpbmdzLCBhY3Rpb24pIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdG9yZWROYW1lID0gKGVsZW1lbnQubmFtZSAhPT0gJycgJiYgIWlzVW5kZWZpbmVkKGVsZW1lbnQubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudChlbGVtZW50Lm5hbWUpfWAgOmBBVVRPXyR7ZWxlbWVudC5pZH1gO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZTtcclxuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXRzIGNvb2tpZSBmb3IgYnJvd3NlciB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIElFIDYgJiBJRSA3XHJcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0ke3NldHRpbmdzLnJhd1ZhbHVlfTsgZXhwaXJlcz0gOyBwYXRoPS9gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9VVENTdHJpbmcoKTsgLy8gTm90ZSA6IGB0b0dNVFN0cmluZygpYCBoYXMgYmVlbiBkZXByZWNhdGVkIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0dNVFN0cmluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ29va2llKHN0b3JlZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHN0b3JlZE5hbWUsIHNldHRpbmdzLnJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmVkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JlZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBBdXRvTnVtZXJpY0hvbGRlciB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xhc3MgY29uc3RydWN0b3JcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHRoYXQsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgICAgICAgICAgdGhpcy50aGF0ID0gdGhhdDtcclxuICAgICAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgdmFsdWUgYW5kIHRoZSBzZWxlY3Rpb24gdmFsdWVzIGluc2lkZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0LlxyXG4gICAgICAgICAqIFRoaXMga2VlcHMgdHJhY2tzIG9mIHRoZSBpbnB1dCB2YWx1ZSwgYXMgd2VsbCBhcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICAgICAgICogVGhpcyBhbHNvIHJlc2V0cyB0aGUgJ3Byb2Nlc3NlZCcgYW5kICdmb3JtYXR0ZWQnIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZSA6IFRob3NlIHR3byBjYW4gY2hhbmdlIGJldHdlZW4gdGhlIGtleWRvd24sIGtleXByZXNzIGFuZCBrZXl1cCBldmVudHMsIHRoYXQncyB3aHlcclxuICAgICAgICAgKiAgICAgICAgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBldmVudCBoYW5kbGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB0aGUga2V5Y29kZSBvZiB0aGUga2V5IHRoYXQgdHJpZ2dlcmVkIHRoZSBnaXZlbiBldmVudC5cclxuICAgICAgICAgKiBOb3RlIDogZS53aGljaCBpcyBzb21ldGltZXMgZGlmZmVyZW50IHRoYW4gZS5rZXlDb2RlIGR1cmluZyB0aGUga2V5cHJlc3MgZXZlbnQsIHdoZW4gZW50ZXJpbmcgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSAoaWUuICd0JykuIGBlLndoaWNoYCBlcXVhbHMgMCBmb3Igbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy9UT0RPIFN3aXRjaCB0byB0aGUgbm9uLWRlcHJlY2F0ZWQgZS5rZXkgYXR0cmlidXRlLCBpbnN0ZWFkIG9mIGluY29uc2lzdGFudCBlLndoaWNoIGFuZCBlLmtleUNvZGUuXHJcbiAgICAgICAgICogZS5rZXkgZGVzY3JpYmUgdGhlIGtleSBuYW1lIHVzZWQgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXHJcbiAgICAgICAgICogZS5rZXlDb2RlIGJlaW5nIGRlcHJlY2F0ZWQgOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlDb2RlXHJcbiAgICAgICAgICogSG93IGUua2V5IHdvcmtzIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5XHJcbiAgICAgICAgICogVGhlIGtleSBsaXN0IGlzIGRlc2NyaWJlZCBoZXJlXHJcbiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5L0tleV9WYWx1ZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZShlKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBrZXlwcmVzcyBldmVudCBvdmVyd3JpdGVzIG1lYW5pbmdmdWwgdmFsdWUgb2YgZS5rZXlDb2RlLCBoZW5jZSB3ZSBkbyBub3QgdXBkYXRlIHRoYXQgdmFsdWUgb24gJ2tleXByZXNzJ1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9IGtleUNvZGVOdW1iZXIoZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHRleHQgc2VsZWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgd2l0aCB0aGUgZ2l2ZW4gc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBlbmRcclxuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcclxuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4pXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xyXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIHRoaXMudGhhdC52YWx1ZS5sZW5ndGgpOyAvL1RPRE8gUmVwbGFjZSBgdGhpcy50aGF0LnZhbHVlLmxlbmd0aGAgd2l0aCBgdGhpcy52YWx1ZS5sZW5ndGhgXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNldFJlYWwpIHx8IHNldFJlYWwpIHtcclxuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjYXJldCBwb3NpdGlvbiBpbnNpZGUgdGhlIGlucHV0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBwb3NcclxuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfc2V0Q2FyZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcclxuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4pXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihwb3MsIHBvcywgc2V0UmVhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cclxuICAgICAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgbGVmdCAndW50b3VjaGVkJywgaWUuIGZvcm1hdHRlZCBieSBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdGhpcy5zZWxlY3Rpb24uc3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxyXG4gICAgICAgICAqIFRob3NlIHBhcnRzIGFyZSB1bmZvcm1hdHRlZCAoc3RyaXBwZWQpIG9mIGFueSBub24tbnVtYmVycyBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbiwgdW5mb3JtYXR0ZWQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgY2hhbmdpbmcgdGhlIHNpZ24gYW5kIGxlZnQgaXMgZXF1YWwgdG8gdGhlIG51bWJlciB6ZXJvIC0gcHJldmVudHMgc3RyaXBwaW5nIHRoZSBsZWFkaW5nIHplcm9zXHJcbiAgICAgICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkh5cGhlbiAmJiBOdW1iZXIobGVmdCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWZ0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGxlZnQsIHRoaXMuc2V0dGluZ3NDbG9uZSwgc3RyaXBaZXJvcyk7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUobGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSAocmlnaHQgPT09ICctJykgPyAnJyA6IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XHJcbiAgICAgICAgICogQHJldHVybnMge1sqLCpdfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcclxuICAgICAgICAgICAgbGV0IHN0cmlwWmVyb3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSHlwaGVuICYmIE51bWJlcihsZWZ0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlZnQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdCwgc2V0dGluZ3NDbG9uZSwgc3RyaXBaZXJvcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByaWdodCBpcyBub3QgZW1wdHkgYW5kIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgZGVjaW1hbENoYXJhY3RlclxyXG4gICAgICAgICAgICByaWdodCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgc2V0dGluZ3NDbG9uZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubGVhZGluZ1plcm8gPT09ICdkZW55JyAmJlxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bTAgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtcGFkMCkgJiZcclxuICAgICAgICAgICAgICAgIE51bWJlcihsZWZ0KSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikgICYmIHJpZ2h0ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUobGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxyXG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyfWApKTtcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZShtWzFdLCBtWzFdICsgJzAnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBwYXJ0IG9mIG51bWJlciB0byB2YWx1ZSB3aGlsZSBrZWVwaW5nIHRoZSBjdXJzb3IgcG9zaXRpb24uIC8vVE9ETyBXaGF0IGFib3V0IHRoZSBjdXJzb3Igc2VsZWN0aW9uP1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGFzdGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBpc1Bhc3RlID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0c1swXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSB0cnVuY2F0ZURlY2ltYWwodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSwgaXNQYXN0ZSk7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gQ2hlY2sgaWYgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBoYXJkLWNvZGVkICcsJyB3aXRoIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IChjb250YWlucyh0aGlzLm5ld1ZhbHVlLCAnLCcpKSA/IHRoaXMubmV3VmFsdWUucmVwbGFjZSgnLCcsICcuJykgOiB0aGlzLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA9PT0gJycgfHwgdGVzdFZhbHVlID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAoc2V0dGluZ3NDbG9uZS5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykgPyAnMCcgOiAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModGVzdFZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm5ld1ZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5uZXdWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdoZW4gdGhlIHVzZXIgZW50ZXIgYSAnMCcgb24gdGhlIGZhciBsZWZ0IHdpdGggYSBsZWFkaW5nIHplcm8gb3B0aW9uIHNldCB0byAnZGVueScsIHRoYXQgdGhlIGNhcmV0IGRvZXMgbm90IG1vdmVzIHNpbmNlIHRoZSBpbnB1dCBpcyBkcm9wcGVkIChmaXggaXNzdWUgIzI4MylcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMSAmJiBwYXJ0c1swXSA9PT0gJzAnICYmIHNldHRpbmdzQ2xvbmUubGVhZGluZ1plcm8gPT09ICdkZW55Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGVudGVyIGAwYCwgdGhlbiB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSByaWdodCBzaWRlIG9mIGl0IChGaXggaXNzdWUgIzI5OSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICcnIHx8IHBhcnRzWzBdID09PSAnMCcgJiYgcGFydHNbMV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGBfZXhwYW5kU2VsZWN0aW9uT25TaWduKClgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9IFNpZ24gcG9zaXRpb24gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9nZXRTaWduUG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbDtcclxuICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMudGhhdDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xMZW4gPSBjdXJyZW5jeVN5bWJvbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc05lZyA/IFsxLCBjdXJyZW5jeVN5bWJvbExlbiArIDFdIDogWzAsIGN1cnJlbmN5U3ltYm9sTGVuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTGVuID0gdGhhdC52YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlTGVuIC0gY3VycmVuY3lTeW1ib2xMZW4sIHZhbHVlTGVuXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFsxMDAwLCAtMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeHBhbmRzIHNlbGVjdGlvbiB0byBjb3ZlciB3aG9sZSBzaWduXHJcbiAgICAgICAgICogUHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHt1bmRlZmluZWR8Ym9vbGVhbn0gc2V0UmVhbFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2V4cGFuZFNlbGVjdGlvbk9uU2lnbihzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuIG9ubHkpXHJcbiAgICAgICAgICAgIC8vVE9ETyBVc2UgYXJyYXkgZGVzdHJ1Y3R1cmluZyBoZXJlIHRvIHNldCBzaWduUG9zaXRpb24gdG8gbW9yZSBleHBsaWNpdCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5fZ2V0U2lnblBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBzZWxlY3Qgd2l0aG91dCBlbXB0eSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSwgc2V0UmVhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNpZ25Qb3NpdGlvblsxXSwgc2VsZWN0aW9uLmVuZCwgc2V0UmVhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHNlbGVjdCB3aXRoIHdob2xlIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oTWF0aC5taW4oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1heChzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pLCBzZXRSZWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY2hlY2tQYXN0ZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzdHJpcCB0aGUgcGFzdGVkIHZhbHVlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihvbGRQYXJ0c1swXS5sZW5ndGgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5cy5cclxuICAgICAgICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgVFJVRSwgdGhlbiBmdXJ0aGVyIHByb2Nlc3NpbmcgaXMgbm90IHBlcmZvcm1lZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9za2lwQWx3YXlzKGUpIHtcclxuICAgICAgICAgICAgLy8gQ2F0Y2ggdGhlIGN0cmwgdXAgb24gY3RybC12XHJcbiAgICAgICAgICAgIGlmICgoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoZS5zaGlmdEtleSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTW92ZSB0aGlzIHRlc3QgaW5zaWRlIHRoZSBgb25LZXl1cGAgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXN0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTa2lwIGFsbCBmdW5jdGlvbiBrZXlzIChGMS1GMTIpLCBXaW5kb3dzIGtleXMsIHRhYiBhbmQgb3RoZXIgc3BlY2lhbCBrZXlzXHJcbiAgICAgICAgICAgIGlmICgodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5GMSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8PSBrZXlDb2RlLkYxMikgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA+PSBrZXlDb2RlLldpbmRvd3MgJiYgdGhpcy5ldmVudEtleUNvZGUgPD0ga2V5Q29kZS5SaWdodENsaWNrKSB8fFxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuVGFiICYmIHRoaXMuZXZlbnRLZXlDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcclxuICAgICAgICAgICAgICAgIC8vIGBlLndoaWNoYCBpcyBzb21ldGltZXMgZGlmZmVyZW50IHRoYW4gYHRoaXMuZXZlbnRLZXlDb2RlYCBkdXJpbmcgdGhlIGtleXByZXNzIGV2ZW50IHdoZW4gZW50ZXJpbmcgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSAoaWUuICd0JykuIEFsc28sIGBlLndoaWNoYCBlcXVhbHMgMCBmb3Igbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlIDwga2V5Q29kZS5CYWNrc3BhY2UgJiZcclxuICAgICAgICAgICAgICAgIChlLndoaWNoID09PSAwIHx8IGUud2hpY2ggPT09IHRoaXMuZXZlbnRLZXlDb2RlKSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLlNjcm9sbExvY2sgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgXCJTZWxlY3QgYWxsXCIga2V5Ym9hcmQgc2hvcnRjdXQgaXMgZGV0ZWN0ZWQgKGN0cmwgKyBhKVxyXG4gICAgICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE51bWJlck9ubHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaXMgdXNlZCBoZXJlIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gZmlyc3Qgc2VsZWN0IGFsbCB0aGUgaW5wdXQgdGV4dCAoaW5jbHVkaW5nIHRoZSBjdXJyZW5jeSBzaWduKSwgb3RoZXJ3aXNlIHdlIHdvdWxkIHNlZSB0aGF0IHdob2xlIHNlbGVjdGlvbiBmaXJzdCBpbiBhIGZsYXNoLCB0aGVuIHRoZSBzZWxlY3Rpb24gd2l0aCBvbmx5IHRoZSBudW1iZXIgcGFydCB3aXRob3V0IHRoZSBjdXJyZW5jeSBzaWduLlxyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xMZW4gPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWlzTmVnYXRpdmUodGhpcy50aGF0LnZhbHVlKSk/MDoxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeFRleHRMZW4gPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgY3VycmVuY3lTeW1ib2xMZW4gPiAwKT9jdXJyZW5jeVN5bWJvbExlbiArIDE6Y3VycmVuY3lTeW1ib2xMZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gc3VmZml4VGV4dExlbjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChzdWZmaXhUZXh0TGVuICsgY3VycmVuY3lTeW1ib2xMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKGN1cnJlbmN5U3ltYm9sTGVuID4gMCk/dmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBuZWdMZW4gKyBzdWZmaXhUZXh0TGVuKTp2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBzdWZmaXhUZXh0TGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhIFwiQ29weVwiLCBcIlBhc3RlXCIgb3IgXCJDdXRcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAocmVzcGVjdGl2ZWx5ICdjdHJsICsgYycsICdjdHJsICsgdicgb3IgJ2N0cmwgKyB4JylcclxuICAgICAgICAgICAgaWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuYyB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS52IHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLngpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLnYgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5jO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhpcyB0ZXN0IGluc2lkZSB0aGUgYG9uS2V5ZG93bmAgaGFuZGxlclxyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLlJpZ2h0QXJyb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyAmJiAhZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAyKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSkgPT09IHRoaXMuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50S2V5Q29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIHRoaXMuZXZlbnRLZXlDb2RlIDw9IGtleUNvZGUuRG93bkFycm93O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdCBUaGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0IFRoZSBwYXJ0IG9uIHRoZSByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbihbbGVmdCwgcmlnaHRdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSAmJiBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgJiYgc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSArIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKGxlZnQpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNZXJnZSB0aGUgdHdvIGZvbGxvd2luZyAnaWYnIGJsb2NrcyBpbnRvIG9uZSBgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge2AgYW5kIGEgc3dpdGNoIG9uIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCkgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiAoKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRbMF0gPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgdGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgLSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgJiYgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAhPT0gJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3MgdGhlIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsZWZ0O1xyXG4gICAgICAgICAgICBsZXQgcmlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiAoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnIHx8IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmUodGhpcy52YWx1ZSkpIHsgLy9UT0RPIENoYW5nZSBgdGhpcy52YWx1ZWAgdG8gYHRoaXMudGhhdC52YWx1ZWA/XHJcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZGVjaWRlcyBpZiB0aGUga2V5IHByZXNzZWQgc2hvdWxkIGJlIGRyb3BwZWQgb3IgYWNjZXB0ZWQsIGFuZCBtb2RpZnkgdGhlIHZhbHVlICdvbi10aGUtZmx5JyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGtleWNvZGUgaXMgYWxsb3dlZC5cclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9ucyBhbHNvIG1vZGlmeSB0aGUgdmFsdWUgb24tdGhlLWZseS4gLy9GSVhNRSBUaGlzIHNob3VsZCB1c2UgYW5vdGhlciBmdW5jdGlvbiBpbiBvcmRlciB0byBzZXBhcmF0ZSB0aGUgdGVzdCBhbmQgdGhlIG1vZGlmaWNhdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudHxzdHJpbmd9IGV2ZW50T3JDaGFyIFRoZSBldmVudCBvYmplY3QsIG9yIHRoZSBjaGFyYWN0ZXIgZW50ZXJlZCAoZnJvbSBhbiBhbmRyb2lkIGRldmljZSlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbihldmVudE9yQ2hhcikge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGV2ZW50Q2hhcmFjdGVyO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXZlbnRPckNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbmRyb2lkIGJyb3dzZXJzXHJcbiAgICAgICAgICAgICAgICBldmVudENoYXJhY3RlciA9IGV2ZW50T3JDaGFyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGJyb3dzZXJzXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSByZWFsIGNoYXJhY3RlciB0aGF0IGhhcyBiZWVuIGVudGVyZWQgKGllLiAnYScgaW5zdGVhZCBvZiB0aGUga2V5IGNvZGUpXHJcbiAgICAgICAgICAgICAgICBldmVudENoYXJhY3RlciA9IGNoYXJhY3RlcihldmVudE9yQ2hhcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgbm8gZGVjaW1hbCBwYXJ0IGFsbG93ZWRcclxuICAgICAgICAgICAgaWYgKGV2ZW50Q2hhcmFjdGVyID09PSBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBldmVudENoYXJhY3RlciA9PT0gc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpIHx8XHJcbiAgICAgICAgICAgICAgICAoKGV2ZW50Q2hhcmFjdGVyID09PSAnLicgfHwgZXZlbnRDaGFyYWN0ZXIgPT09ICcsJykgJiYgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLmRlY2ltYWxQbGFjZXNPdmVycmlkZSB8fCAhc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBvdGhlciBkZWNpbWFsIGNoYXJhY3RlciBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciwgcmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG1pbnVzIGlmIG5vdCBhbGxvd2VkXHJcbiAgICAgICAgICAgIGlmICgoZXZlbnRDaGFyYWN0ZXIgPT09ICctJyB8fCBldmVudENoYXJhY3RlciA9PT0gJysnKSAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYXJldCBpcyBhbHdheXMgYWZ0ZXIgbWludXNcclxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIG51bWJlciBzaWduLCByZW1vdmUgcGFydCBpZiBzaG91bGRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZVN0cmljdChsZWZ0KSB8fCBjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGV2ZW50Q2hhcmFjdGVyID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0IDogbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoZXZlbnRDaGFyYWN0ZXIgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQgOiBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgdHJpZXMgdG8gaW5zZXJ0IGRpZ2l0IGJlZm9yZSBtaW51cyBzaWduXHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TnVtYmVyID0gTnVtYmVyKGV2ZW50Q2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TnVtYmVyID49IDAgJiYgZXZlbnROdW1iZXIgPD0gOSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5tYXhpbXVtVmFsdWUgPD0gMCAmJiBzZXR0aW5nc0Nsb25lLm1pbmltdW1WYWx1ZSA8IHNldHRpbmdzQ2xvbmUubWF4aW11bVZhbHVlICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgJiYgZXZlbnRDaGFyYWN0ZXIgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgZXZlbnRDaGFyYWN0ZXIsIHJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgb3RoZXIgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9ybWF0dGluZyBvZiBqdXN0IHByb2Nlc3NlZCB2YWx1ZSB3aGlsZSBrZWVwaW5nIHRoZSBjdXJzb3IgcG9zaXRpb25cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9mb3JtYXRWYWx1ZShlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBsZXQgW2xlZnRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBObyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cclxuICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJyAgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvcikpKSAmJlxyXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkpKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcclxuICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKHN1YlBhcnRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhcnRzID0gc3ViUGFydHMucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50UG9zICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxlZnQgPSBuU2lnbiArIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHRoaXMudmFsdWUsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHJlZ2V4cCB3aGljaCBzZWFyY2hlcyBmb3IgY3Vyc29yIHBvc2l0aW9uIGZyb20gdW5mb3JtYXR0ZWQgbGVmdCBwYXJ0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QXIgPSBsZWZ0LnNwbGl0KCcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlcyBjYXJldCBwb3NpdGlvbiB3aXRoIHRyYWlsaW5nIG1pbnVzIHNpZ25cclxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbMF0gPT09ICctJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wuc3BsaXQoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVzaGluZyB0aGUgZXNjYXBlZCBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaChlc2NhcGVkUGFydHMuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyW2ldID0gJ1xcXFwnICsgbGVmdEFyW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVnID0gbmV3IFJlZ0V4cCgnXi4qPycgKyBsZWZ0QXIuam9pbignLio/JykpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBjdXJzb3IgcG9zaXRpb24gaW4gZm9ybWF0dGVkIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gdmFsdWUubWF0Y2gobGVmdFJlZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3TGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbmV3TGVmdFswXS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwb3NpdGl2ZSBzaWduIGlzIHNob3duLCBjYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuc2hvd1Bvc2l0aXZlU2lnbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgbmV3TGVmdC5pbnB1dC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IChuZXdMZWZ0LmlucHV0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgPT09IDEpID8gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAxIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmIG5ld0xlZnQuaW5wdXQuY2hhckF0KHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSA9PT0gc2V0dGluZ3NDbG9uZS5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUganVzdCBiZWZvcmUgdGhlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBjYXJldCBhZnRlciBwcmVmaXggc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHRoZSB0ZXN0IGJlICdpc05lZ2F0aXZlJyBpbnN0ZWFkIG9mICdpc05lZ2F0aXZlU3RyaWN0JyBpbiBvcmRlciB0byBzZWFyY2ggZm9yICctJyBldmVyeXdoZXJlIGluIHRoZSBzdHJpbmc/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArIChpc05lZ2F0aXZlU3RyaWN0KHZhbHVlKSA/IDEgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzaWduIGFzIGEgc3VmZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXggY3VycmVuY3kgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc3VmZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCBoYXMgY2hhbmdlZC4gVGhpcyBwcmV2ZW50cyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbiwgaWYgYW55LlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudGhhdC52YWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IHRoaXMudGhhdC52YWx1ZSAmJiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtMCB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW1wYWQwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBBbmRyb2lkIGJyb3dzZXIgaXMgZGV0ZWN0ZWQsIGZpeCB0aGUgY2FyZXQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgdGhpcyBkb2VzIG5vdCBmaXggYWxsIGFuZHJvaWQgYnJvd3NlcnMsIG9ubHkgQW5kcm9pZCBDaHJvbWUgY3VycmVudGx5LlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhvc2UgcHJvdmlkZSBkaWZmZXJlbnQgb3JkZXIgb2YgZXZlbnRzIGFuZC9vciBrZXljb2RlcyB0aHJvd24gKHRoaXMgaXMgYSByZWFsIG1lc3MgOnwpLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihzZXR0aW5nc0Nsb25lLmFuZHJvaWRTZWxlY3Rpb25TdGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTsgLy9UT0RPIFJlbmFtZSBgdGhpcy5mb3JtYXR0ZWRgIHRvIGB0aGlzLl9mb3JtYXRFeGVjdXRlZGAsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGZvcm1hdCBhbnl0aGluZyAoaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGtleWNvZGUgaXMgZHJvcHBlZCBmb3IgaW5zdGFuY2UpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBmYWN0b3Jpc2UgdGhlIGBnZXRTdHJpbmcoKWAgYW5kIGBnZXRBcnJheSgpYCBmdW5jdGlvbnMgc2luY2UgdGhleSBzaGFyZSBxdWl0ZSBhIGxvdCBvZiBjb2RlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXHJcbiAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxyXG4gICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXHJcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIG1vcmUgZGV0YWlsc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2V0QXJyYXlCZWhhdmlvciAtIElmIHNldCB0byBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gYmVoYXZlIGxpa2UgYGdldEFycmF5KClgLCBvdGhlcndpc2UgaWYgc2V0IHRvIEZBTFNFLCBpdCBiZWhhdmUgbGlrZSBgZ2V0U3RyaW5nKClgXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0aGF0IC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcclxuICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoYXQpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1JbmRleCA9ICQoJ2Zvcm0nKS5pbmRleCgkdGhpcyk7XHJcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XHJcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xyXG5cclxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcclxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XHJcblxyXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxyXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcclxuXHJcbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxyXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcclxuXHJcbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxyXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XHJcbiAgICAgICAgY29uc3Qgck5vbkF1dG9OdW1lcmljVHlwZXMgPSAvXig/OmJ1dHRvbnxjaGVja2JveHxjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGZpbGV8aW1hZ2V8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhZGlvfHJhbmdlfHJlc2V0fHNlYXJjaHxzdWJtaXR8dGltZXx1cmx8d2VlaykvaTtcclxuXHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xyXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSAhPT0gJycgJiYgclN1Ym1pdHRhYmxlLnRlc3QoZmllbGQubG9jYWxOYW1lKSAmJiAhclN1Ym1pdHRlclR5cGVzLnRlc3QoZmllbGQudHlwZSkgJiYgIWZpZWxkLmRpc2FibGVkICYmIChmaWVsZC5jaGVja2VkIHx8ICFyQ2hlY2thYmxlVHlwZS50ZXN0KGZpZWxkLnR5cGUpKSkge1xyXG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcclxuICAgICAgICBjb3VudCA9IDA7XHJcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcclxuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaChjb3VudCk7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XHJcblxyXG4gICAgICAgICAgICAkLmVhY2goZm9ybUZpZWxkcywgKGksIGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSBzY0luZGV4LmluZGV4T2YoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBnZXRTdHJpbmcoKSBiZWhhdmlvclxyXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1QYXJ0cyA9IGZvcm1GaWVsZHMuc3BsaXQoJyYnKTtcclxuXHJcbiAgICAgICAgICAgICQuZWFjaChmb3JtUGFydHMsIGkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW2lucHV0TmFtZSwgaW5wdXRWYWx1ZV0gPSBmb3JtUGFydHNbaV0uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9IHNjSW5kZXguaW5kZXhPZihpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgdmFsaWQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRJbnB1dFZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVBhcnRzW2ldID0gYCR7aW5wdXROYW1lfT0ke21vZGlmaWVkSW5wdXRWYWx1ZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtUGFydHMuam9pbignJicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c2luJyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyLCBlKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcclxuXHJcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2ZvY3VzaW4nIHx8IGUudHlwZSA9PT0gJ21vdXNlZW50ZXInICYmICEkdGhpcy5pcygnOmZvY3VzJykgJiYgc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnZm9jdXMnKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQoZS50YXJnZXQudmFsdWUsIHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNsZWFuIHRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIHJhd1ZhbHVlXHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMoZS50YXJnZXQudmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gY29udmVydFRvTnVtZXJpY1N0cmluZyhyZXN1bHQsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyhyZXN1bHQsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICctJyArIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHJvdW5kZWRWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM7XHJcbiAgICAgICAgICAgICAgICByb3VuZGVkVmFsdWUgPSByb3VuZFZhbHVlKHNldHRpbmdzLnJhd1ZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCBhZGRHcm91cFNlcGFyYXRvcnMocm91bmRlZFZhbHVlLCBzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLm9EZWMpO1xyXG4gICAgICAgICAgICAgICAgcm91bmRlZFZhbHVlID0gcm91bmRWYWx1ZShzZXR0aW5ncy5yYXdWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZSwgc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5ub1NlcGFyYXRvck9uRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSAnJztcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdWZmaXhUZXh0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICByb3VuZGVkVmFsdWUgPSByb3VuZFZhbHVlKHNldHRpbmdzLnJhd1ZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCBhZGRHcm91cFNlcGFyYXRvcnMocm91bmRlZFZhbHVlLCBzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gc2V0dGluZ3MucmF3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdGhlIHJhd1ZhbHVlXHJcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gc2VuZCBhICduYXRpdmUnIGNoYW5nZSBldmVudCB3aGVuIGJsdXJyaW5nIHRoZSBpbnB1dCwgd2UgbmVlZCB0byBmaXJzdCBzdG9yZSB0aGUgaW5pdGlhbCBpbnB1dCB2YWx1ZSBvbiBmb2N1cy5cclxuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci52YWx1ZU9uRm9jdXM7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci52YWx1ZU9uRm9jdXMsIHNldHRpbmdzLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIG9uRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uRW1wdHkgPT09IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlkb3duJyBldmVudHMuXHJcbiAgICAgKiBUaGUgdXNlciBqdXN0IHN0YXJ0ZWQgcHVzaGluZyBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIDpcclxuICAgICAqIEJ5IGRlZmF1bHQgYSAnbm9ybWFsJyBpbnB1dCBvdXRwdXQgdGhvc2UgZXZlbnRzIGluIHRoZSByaWdodCBvcmRlciB3aGVuIGlucHV0dGluZyBhIGNoYXJhY3RlciBrZXkgKGllLiAnYScpIDpcclxuICAgICAqIC0ga2V5ZG93blxyXG4gICAgICogLSBrZXlwcmVzc1xyXG4gICAgICogLSBpbnB1dFxyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICpcclxuICAgICAqIC4uLndoZW4gaW5wdXR0aW5nIGEgbW9kaWZpZXIga2V5IChpZS4gJ2N0cmwnKSA6XHJcbiAgICAgKiAtIGtleWRvd25cclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqXHJcbiAgICAgKiBJZiAnZGVsZXRlJyBvciAnYmFja3NwYWNlJyBpcyBlbnRlcmVkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XHJcbiAgICAgKiAtIGtleWRvd25cclxuICAgICAqIC0gaW5wdXRcclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqXHJcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcclxuICAgICAqIC0ga2V5ZG93blxyXG4gICAgICogLSBrZXlwcmVzc1xyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICpcclxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcclxuICAgICAqIC0ga2V5ZG93blxyXG4gICAgICogLSBrZXlwcmVzc1xyXG4gICAgICogLSBjaGFuZ2VcclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqXHJcbiAgICAgKiBXaGVuIGEgcGFzdGUgaXMgZG9uZSwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxyXG4gICAgICogLSBpbnB1dCAoaWYgcGFzdGUgaXMgZG9uZSB3aXRoIHRoZSBtb3VzZSlcclxuICAgICAqXHJcbiAgICAgKiAtIGtleWRvd24gKGlmIHBhc3RlIGlzIGRvbmUgd2l0aCBjdHJsK3YpXHJcbiAgICAgKiAtIGtleWRvd25cclxuICAgICAqIC0gaW5wdXRcclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqIC0ga2V5dXBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25LZXlkb3duKGhvbGRlciwgZSkge1xyXG4gICAgICAgIC8vVE9ETyBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHJpZXZlIHRoZSBlbGVtZW50IHZhbHVlIChlaXRoZXIgYnkgdXNpbmcgYGUudGFyZ2V0LnZhbHVlYCB3aGVuIHRoZSBlbGVtZW50IGlzIGFuIDxpbnB1dD4sIG9yIGJ5IHVzaW5nIGBlbGVtZW50LnRleHRDb250ZW50YCB3aGVuIHRoZSBlbGVtZW50IGFzIGl0cyBgY29udGVudGVkaXRhYmxlYCBzZXQgdG8gdHJ1ZSlcclxuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyRXZlbnRLZXljb2RlKGUpO1xyXG4gICAgICAgIGhvbGRlci5pbml0aWFsVmFsdWVPbktleWRvd24gPSBlLnRhcmdldC52YWx1ZTsgLy8gVGhpcyBpcyBuZWVkZWQgaW4gYG9uS2V5dXAoKWAgdG8gY2hlY2sgaWYgdGhlIHZhbHVlIGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3NcclxuXHJcbiAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIFwiZW50ZXJcIiBrZXkgdGhyb3dzIGEgYGNoYW5nZWAgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBgZm9jdXNgIGV2ZW50XHJcbiAgICAgICAgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRW50ZXIgJiYgaG9sZGVyLnZhbHVlT25Gb2N1cyAhPT0gZS50YXJnZXQudmFsdWUpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlLnRhcmdldCk7XHJcbiAgICAgICAgICAgIGhvbGRlci52YWx1ZU9uRm9jdXMgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKGUpO1xyXG5cclxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XHJcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtleSBpcyBhIGRlbGV0ZS9iYWNrc3BhY2Uga2V5XHJcbiAgICAgICAgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlKSB7XHJcbiAgICAgICAgICAgIGhvbGRlci5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCk7IC8vIEJlY2F1c2UgYmFja3NwYWNlIGFuZCBkZWxldGUgb25seSB0cmlnZ2VycyBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMsIG5vdCBrZXlwcmVzc1xyXG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGFuZCBvbmx5IGlmIHRoZSByZXN1bHRpbmcgdmFsdWUgaGFzIGNoYW5nZWQgYWZ0ZXIgdGhhdCBiYWNrc3BhY2UvZGVsZXRlLCB0aGVuIHdlIGhhdmUgdG8gc2VuZCBhbiAnaW5wdXQnIGV2ZW50IGxpa2UgYnJvd3NlcnMgbm9ybWFsbHkgZG8uXHJcbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBpbnB1dCBldmVudCB3aGVuIGEgY2hhcmFjdGVyIGRlbGV0aW9uIGlzIGRldGVjdGVkXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBkZWxldGUgYSBzZWNvbmQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD9cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzLlxyXG4gICAgICogVGhlIHVzZXIgaXMgc3RpbGwgcHJlc3NpbmcgdGhlIGtleSwgd2hpY2ggd2lsbCBvdXRwdXQgYSBjaGFyYWN0ZXIgKGllLiAnMicpIGNvbnRpbnVvdXNseSB1bnRpbCBpdCByZWxlYXNlcyB0aGUga2V5LlxyXG4gICAgICogTm90ZTogJ2tleXByZXNzJyBldmVudHMgYXJlIG5vdCBzZW50IGZvciBkZWxldGUga2V5cyBsaWtlIEJhY2tzcGFjZS9EZWxldGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uS2V5cHJlc3MoaG9sZGVyLCBlKSB7XHJcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlYWwgY2hhcmFjdGVyIHRoYXQgaGFzIGJlZW4gZW50ZXJlZCAoaWUuICdhJyBpbnN0ZWFkIG9mIHRoZSBrZXkgY29kZSlcclxuICAgICAgICBjb25zdCBldmVudENoYXJhY3RlciA9IGNoYXJhY3RlcihlKTtcclxuXHJcbiAgICAgICAgLy8gRmlyZWZveCBnZW5lcmF0ZSBhICdrZXlwcmVzcycgZXZlbnQgKGUua2V5Q29kZSA9PT0gMCkgZm9yIHRoZSBrZXlzIHRoYXQgZG8gbm90IHByaW50IGEgY2hhcmFjdGVyIChpZS4gJ0luc2VydCcsICdEZWxldGUnLCAnRm4nIGtleXMsICdQYWdlVXAnLCAnUGFnZURvd24nIGV0Yy4pLiAnU2hpZnQnIG9uIHRoZSBvdGhlciBoYW5kIGRvZXMgbm90IGdlbmVyYXRlIGEga2V5cHJlc3MgZXZlbnQuXHJcbiAgICAgICAgaWYgKGV2ZW50Q2hhcmFjdGVyID09PSBrZXlOYW1lLkluc2VydCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBob2xkZXIucHJvY2Vzc2VkO1xyXG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKGUpO1xyXG5cclxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gaG9sZGVyLl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKGUpO1xyXG4gICAgICAgIGlmIChpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcclxuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRocm93cyBpbnB1dCBldmVudCBvbiBhZGRpbmcgYSBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGFkZCBhIHNlY29uZCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgoZXZlbnRDaGFyYWN0ZXIgPT09IGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyIHx8IGV2ZW50Q2hhcmFjdGVyID09PSBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5zdGFydCA9PT0gZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuZW5kKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLnN0YXJ0ID09PSBlLnRhcmdldC52YWx1ZS5pbmRleE9mKGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIHBvc2l0aW9uLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnaW5wdXQnIGV2ZW50cy5cclxuICAgICAqIGFkZGVkIHRvIHN1cHBvcnQgYW5kcm9pZCBkZXZpY2VzIHdpdGggbW9iaWxlIGNocm9tZSBicm93c2VycyBhbmQgb3RoZXJzXHJcbiAgICAgKiBIYXMgdGhlIHBvdGVudGlhbCB0byByZXBsYWNlIHRoZSBrZXlwcmVzcyBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25JbnB1dChob2xkZXIsIGUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cclxuICAgICAgICAvLyBGaXggdGhlIGNhcmV0IHBvc2l0aW9uIG9uIGtleXVwIGluIHRoZSBgX2Zvcm1hdFZhbHVlKClgIGZ1bmN0aW9uXHJcbiAgICAgICAgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkFuZHJvaWREZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBrZXlDb2RlIGlzIGVxdWFsIHRvIHRoZSBkZWZhdWx0IEFuZHJvaWQgQ2hyb21lIG9uZSAod2hpY2ggaXMgYWx3YXlzIGVxdWFsIHRvIGBrZXlDb2RlLkFuZHJvaWREZWZhdWx0YClcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGhvbGRlci5sYXN0VmFsLmxlbmd0aCB8fCB2YWx1ZS5sZW5ndGggPj0gaG9sZGVyLmxhc3RWYWwubGVuZ3RoIC0gaG9sZGVyLnNlbGVjdGlvbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUga2V5Y29kZSBvZiB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIGVudGVyZWQsIGFuZCBvdmVyd3JpdGUgdGhlIGZhdWx0eSBgZXZlbnRLZXlDb2RlYCBpbmZvIHdpdGggaXRcclxuICAgICAgICAgICAgICAgIGhvbGRlci5ldmVudEtleUNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGhvbGRlci5zZWxlY3Rpb24uc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIGFjdHVhbCBjaGFyYWN0ZXIgZW50ZXJlZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5kcm9pZENoYXJFbnRlcmVkID0gdmFsdWUuY2hhckF0KGhvbGRlci5zZWxlY3Rpb24uc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBnaXZlbiBjaGFyYWN0ZXIgc2hvdWxkIGJlIGluc2VydGVkLCBhbmQgaWYgc28sIGRvIGluc2VydCBpdCBpbnRvIHRoZSBjdXJyZW50IGVsZW1lbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCA9IGhvbGRlci5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbihhbmRyb2lkQ2hhckVudGVyZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlciBlbnRlcmVkIChudW1iZXIsIGRlY2ltYWwgb3IgcGx1cy9taW51cyBzaWduKVxyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIG5ldyBjYXJldCBwb3NpdGlvbi4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIG9uIGtleXVwLCBgX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyRXZlbnRLZXljb2RlKClgIGNhcHR1cmVzIHRoZSBvbGQgY2FyZXQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBBbmRyb2lkIGJ1ZyBvciBhbiBhdXRvTnVtZXJpYyBvbmVcclxuICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gaG9sZGVyLnNlbGVjdGlvbi5zdGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uID0gZS50YXJnZXQudmFsdWUuaW5kZXhPZihob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzRGVjaW1hbENoYXJhY3RlciA9IGRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiA9PT0gLTE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGNhcmV0IHRvIHRoZSByaWdodCBpZiB0aGUgYGFuZHJvaWRDaGFyRW50ZXJlZGAgaXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9yIGlmIGl0J3Mgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZHJvaWRDaGFyRW50ZXJlZCA9PT0gaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIWhhc0RlY2ltYWxDaGFyYWN0ZXIgJiYgZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uIDwgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gaG9sZGVyLnNlbGVjdGlvbi5zdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIHRoZSBjYXJldCByaWdodCBub3cgYmVmb3JlIHRoZSAna2V5dXAnIGV2ZW50IGluIG9yZGVyIHRvIHByZXZlbnQgdGhlIGNhcmV0IGZyb20ganVtcGluZyBhcm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbnRlcmVkIGNoYXJhY3RlciBpcyBub3QgYWxsb3dlZCA7IG92ZXJ3cml0ZSB0aGUgbmV3IGludmFsaWQgdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgdmFsaWQgb25lLCBhbmQgc2V0IGJhY2sgdGhlIGNhcmV0L3NlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gaG9sZGVyLmxhc3RWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNlbGVjdGlvbi5zdGFydCwgaG9sZGVyLnNlbGVjdGlvbi5lbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgPSBob2xkZXIuc2VsZWN0aW9uLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy9GSVhNRSBIb3cgZG9lcyB0aGF0IGFmZmVjdHMgdGhlIG5vcm1hbCB0cmlnZ2VyIG9mIHRoZSBpbnB1dCBldmVudD9cclxuXHJcbiAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGFyYWN0ZXIgZGVsZXRlZFxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFdoYXQgYWJvdXQgdGhlIGBEZWxldGVgIGtleT9cclxuICAgICAgICAgICAgICAgIGhvbGRlci5ldmVudEtleUNvZGUgPSBrZXlDb2RlLkJhY2tzcGFjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdrZXl1cCcgZXZlbnRzLlxyXG4gICAgICogVGhlIHVzZXIganVzdCByZWxlYXNlZCBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbktleXVwKGhvbGRlciwgc2V0dGluZ3MsIGUpIHtcclxuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2tpcCA9IGhvbGRlci5fc2tpcEFsd2F5cyhlKTtcclxuICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcclxuICAgICAgICBjb25zdCBpc09uQW5kcm9pZCA9IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFuZHJvaWRTZWxlY3Rpb25TdGFydCAhPT0gbnVsbDtcclxuICAgICAgICBpZiAoc2tpcCAmJiAhaXNPbkFuZHJvaWQgfHwgZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZGVkIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBjYXJldCB3aGVuIG9ubHkgdGhlIGN1cnJlbmN5IHNpZ24gaXMgcHJlc2VudFxyXG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLlRhYikge1xyXG4gICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgfHxcclxuICAgICAgICAgICAgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpKSB7XHJcbiAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxyXG4gICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaG9sZGVyLmZvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFZhbHVlKGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBjaGFuZ2VkIGR1cmluZyB0aGUga2V5IHByZXNzIGV2ZW50IGNoYWluLCBhbiBldmVudCBpcyBzZW50IHRvIGFsZXJ0IHRoYXQgYSBmb3JtYXR0aW5nIGhhcyBiZWVuIGRvbmUgKGNmLiBJc3N1ZSAjMTg3KVxyXG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmluaXRpYWxWYWx1ZU9uS2V5ZG93bikge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2F1dG9OdW1lcmljOmZvcm1hdHRlZCcsIGUudGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKSB7XHJcbiAgICAgICAgaWYgKCEkdGhpcy5pcygnOmZvY3VzJykpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ub1NlcGFyYXRvck9uRm9jdXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSBzZXR0aW5ncy5vU2VwO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgPSBzZXR0aW5ncy5vU2lnbjtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnN1ZmZpeFRleHQgPSBzZXR0aW5ncy5vU3VmZml4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Mub0RlYztcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcgPSBzZXR0aW5ncy5vUGFkO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgPSBzZXR0aW5ncy5vQnJhY2tldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFpc05lZ2F0aXZlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tFbXB0eSh2YWx1ZSwgc2V0dGluZ3MsIGZhbHNlKSA9PT0gbnVsbCAmJiBtaW5UZXN0ICYmIG1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZSwgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSA/IE51bWJlcihzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpIDogc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MucmF3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnemVybycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUoJzAnLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSBhZGRHcm91cFNlcGFyYXRvcnModmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gb3JpZ1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCBncm91cGVkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIudmFsdWVPbkZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVPbkZvY3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ3Bhc3RlJyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25QYXN0ZSgkdGhpcywgaG9sZGVyLCBlKSB7XHJcbiAgICAgICAgLy9UT0RPIFVzaW5nIGN0cmwreiBhZnRlciBhIHBhc3RlIHNob3VsZCBjYW5jZWwgaXQgLT4gSG93IHdvdWxkIHRoYXQgYWZmZWN0IG90aGVyIGZyYW1ld29ya3MvY29tcG9uZW50IGJ1aWx0IHdpdGggdGhhdCBmZWF0dXJlIGluIG1pbmQgdGhvdWdoP1xyXG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWQgKGNmLiBpc3N1ZSAjMzAyKVxyXG4gICAgICAgIC8vIFRoZSBldmVudCBpcyBwcmV2ZW50ZWQgYnkgZGVmYXVsdCwgc2luY2Ugb3RoZXJ3aXNlIHRoZSB1c2VyIHdvdWxkIGJlIGFibGUgdG8gcGFzdGUgaW52YWxpZCBjaGFyYWN0ZXJzIGludG8gdGhlIGlucHV0XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBsZXQgcmF3UGFzdGVkVGV4dCA9IGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XHJcblxyXG4gICAgICAgIC8vIDAuIFNwZWNpYWwgY2FzZSBpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYWxsIHRoZSBpbnB1dCB0ZXh0IGJlZm9yZSBwYXN0aW5nXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbEZvcm1hdHRlZFZhbHVlID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblNpemUgPSBzZWxlY3Rpb25FbmQgLSBzZWxlY3Rpb25TdGFydDtcclxuICAgICAgICBsZXQgaXNBbGxJbnB1dFRleHRTZWxlY3RlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoc2VsZWN0aW9uU2l6ZSA9PT0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDEuIENoZWNrIGlmIHRoZSBwYXN0ZSBoYXMgYSBuZWdhdGl2ZSBzaWduIChvbmx5IGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3RlciksIGFuZCBzdG9yZSB0aGF0IGluZm9ybWF0aW9uIGZvciBsYXRlciB1c2VcclxuICAgICAgICBjb25zdCBpc1Bhc3RlTmVnYXRpdmUgPSBpc05lZ2F0aXZlU3RyaWN0KHJhd1Bhc3RlZFRleHQpO1xyXG4gICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgLy8gMWEuIFJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnbiBmcm9tIHRoZSBwYXN0ZWQgdGV4dFxyXG4gICAgICAgICAgICByYXdQYXN0ZWRUZXh0ID0gcmF3UGFzdGVkVGV4dC5zbGljZSgxLCByYXdQYXN0ZWRUZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyLiBTdHJpcCBhbGwgdGhvdXNhbmQgc2VwYXJhdG9ycywgYnJhY2tldHMgYW5kIGN1cnJlbmN5IHNpZ24sIGFuZCBjb252ZXJ0IHRoZSBkZWNpbWFsIGNoYXJhY3RlciB0byBhIGRvdFxyXG4gICAgICAgIGNvbnN0IHVudHJhbnNsYXRlZFBhc3RlZFRleHQgPSBwcmVwYXJlUGFzdGVkVGV4dChyYXdQYXN0ZWRUZXh0LCBob2xkZXIpO1xyXG5cclxuICAgICAgICBsZXQgcGFzdGVkVGV4dDtcclxuICAgICAgICBpZiAodW50cmFuc2xhdGVkUGFzdGVkVGV4dCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSA6IElmIHRoZSB1c2VyIHRyaWVzIHRvIHBhc3RlIGEgc2luZ2xlIGRlY2ltYWwgY2hhcmFjdGVyICh0aGF0IGhhcyBiZWVuIHRyYW5zbGF0ZWQgdG8gJy4nIGFscmVhZHkpXHJcbiAgICAgICAgICAgIHBhc3RlZFRleHQgPSAnLic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2VcclxuICAgICAgICAgICAgLy8gQWxsb3cgcGFzdGluZyBhcmFiaWMgbnVtYmVyc1xyXG4gICAgICAgICAgICBwYXN0ZWRUZXh0ID0gYXJhYmljVG9MYXRpbk51bWJlcnModW50cmFuc2xhdGVkUGFzdGVkVGV4dCwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAzLiBUZXN0IGlmIHRoZSBwYXN0ZSBpcyB2YWxpZCAob25seSBoYXMgbnVtYmVycyBhbmQgZXZlbnR1YWxseSBhIGRlY2ltYWwgY2hhcmFjdGVyKS4gSWYgaXQncyBub3QgdmFsaWQsIHN0b3AgaGVyZS5cclxuICAgICAgICBpZiAocGFzdGVkVGV4dCAhPT0gJy4nICYmICghaXNOdW1iZXIocGFzdGVkVGV4dCkgfHwgcGFzdGVkVGV4dCA9PT0gJycpKSB7XHJcbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBTaG91bGQgd2Ugc2VuZCBhIHdhcm5pbmcgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcj9cclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIGlzIG5vdCBhIHZhbGlkIHBhc3RlIGNvbnRlbnQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDQuIENhbGN1bGF0ZSB0aGUgcGFzdGUgcmVzdWx0XHJcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xyXG4gICAgICAgIGxldCBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXI7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAvLyBhdXRvTnVtZXJpYyAnZ2V0JyByZXR1cm5zICcwLjAwJyBpZiB0aGUgaW5wdXQgaXMgZW1wdHksIGhlbmNlIHdlIG5lZWQgdG8gc3RvcmUgdGhlICdyZWFsJyBlbXB0eSBpbml0aWFsIHZhbHVlIHdoZW4gbmVlZGVkXHJcbiAgICAgICAgICAgIC8vRklYTUUgVGhpcyBoYXMgYmVlbiBmaXhlZCBpbiBhIHByZXZpb3VzIGNvbW1pdCwgZ2V0IHNob3VsZCByZXR1cm4gJycgb24gYW4gZW1wdHkgaW5wdXQuIFJlbW92ZSB0aGlzIHVubmVlZGVkICdpZidcclxuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gJyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmVTdHJpY3QoaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyKTtcclxuICAgICAgICBsZXQgaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZTtcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIGNvbnRlbnQgaXMgbmVnYXRpdmUsIHRoZW4gdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlIHRvb1xyXG4gICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmUgJiYgIWlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gYC0ke2luaXRpYWxVbmZvcm1hdHRlZE51bWJlcn1gO1xyXG4gICAgICAgICAgICBpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGVmdFBhcnRDb250YWluZWRBRG90ID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGxlZnRQYXJ0O1xyXG4gICAgICAgIGxldCByaWdodFBhcnQ7XHJcbiAgICAgICAgc3dpdGNoIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcclxuICAgICAgICAgICAgLyogNGEuIFRydW5jYXRlIHBhc3RlIGJlaGF2aW9yOlxyXG4gICAgICAgICAgICAgKiBJbnNlcnQgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGNhcmV0IGZyb20gdGhlIHBhc3RlZCB0ZXh0IGNvbnRlbnQsIHVudGlsIHRoZSBpbnB1dCByZWFjaCBpdHMgcmFuZ2UgbGltaXQuXHJcbiAgICAgICAgICAgICAqIElmIHRoZXJlIGlzIG1vcmUgY2hhcmFjdGVycyBpbiB0aGUgY2xpcGJvYXJkIG9uY2UgYSBsaW1pdCBpcyByZWFjaGVkLCBkcm9wIHRoZSBleHRyYW5lb3VzIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAqIE90aGVyd2lzZSBwYXN0ZSBhbGwgdGhlIG51bWJlcnMgaW4gdGhlIGNsaXBib2FyZC5cclxuICAgICAgICAgICAgICogV2hpbGUgZG9pbmcgc28sIHdlIGNoZWNrIGlmIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBhbGxvd2VkLCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIGVuY291bnRlciBvbmUgb2YgdGhvc2UuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIDRiLiBSZXBsYWNlIHBhc3RlIGJlaGF2aW9yOlxyXG4gICAgICAgICAgICAgKiBJZGVtIHRoYW4gdGhlICd0cnVuY2F0ZScgcGFzdGUgYmVoYXZpb3IsIGV4Y2VwdCB0aGF0IHdoZW4gYSByYW5nZSBsaW1pdCBpcyBoaXQsIHdlIHRyeSB0byByZXBsYWNlIHRoZSBzdWJzZXF1ZW50IGluaXRpYWwgbnVtYmVycyB3aXRoIHRoZSBwYXN0ZWQgb25lcywgdW50aWwgd2UgaGl0IHRoZSByYW5nZSBsaW1pdCBhIHNlY29uZCAoYW5kIGxhc3QpIHRpbWUsIG9yIHdlIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLyogZXNsaW50IG5vLWNhc2UtZGVjbGFyYXRpb25zOiAwICovXHJcbiAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcclxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Rm9ybWF0dGVkUGFydCA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZSgwLCBzZWxlY3Rpb25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChsZWZ0Rm9ybWF0dGVkUGFydCArIHJpZ2h0Rm9ybWF0dGVkUGFydCwgaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIHRoZSBuZWdhdGl2ZSBzaWduIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRSYXdOZWdhdGl2ZVNpZ24ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcclxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBRdWlkIGlmIHRoZSBuZWdhdGl2ZSBzaWduIGlzIG5vdCBvbiB0aGUgbGVmdCAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgYW5kIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50KT9cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IHJlc3VsdC5zbGljZSgwLCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyk7XHJcbiAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0UGFydCwgJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBJIHJlbW92ZSBhIGRvdCBoZXJlLCB0aGVuIEkgbmVlZCB0byB1cGRhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIChkZWNyZW1lbnQgaXQgYnkgMSkgd2hlbiBwb3NpdGlvbmluZyBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBkbyBzbywgd2Uga2VlcCB0aGF0IGluZm8gaW4gb3JkZXIgdG8gbW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IGxlZnRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJpZ2h0UGFydC5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gLS0gSGVyZSwgd2UgYXJlIGdvb2QgdG8gZ28gdG8gY29udGludWUgb24gdGhlIHNhbWUgYmFzaXNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjLiBBZGQgbnVtYmVycyBvbmUgYnkgb25lIGF0IHRoZSBjYXJldCBwb3NpdGlvbiwgd2hpbGUgdGVzdGluZyBpZiB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyAgICBDb250aW51ZSB1bnRpbCB5b3UgZWl0aGVyIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZSwgb3IgdGhhdCB5b3UgZ2V0IG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKGhvbGRlci5zZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihob2xkZXIuc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0OyAvLyBUaGlzIGlzIHNldCBhcyB0aGUgZGVmYXVsdCwgaW4gY2FzZSB3ZSBkbyBub3QgYWRkIGV2ZW4gb25lIG51bWJlclxyXG4gICAgICAgICAgICAgICAgbGV0IHBhc3RlZFRleHRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnRQYXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXN0ZWRUZXh0SW5kZXggPCBwYXN0ZWRUZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgcmVzdWx0IHdpdGggYW5vdGhlciBwYXN0ZWQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMZWZ0UGFydCArPSBwYXN0ZWRUZXh0W3Bhc3RlZFRleHRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbW9kaWZpZWRMZWZ0UGFydCArIHJpZ2h0UGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlIGxpbWl0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkluUmFuZ2UocmVzdWx0LCBtaW5QYXJzZSwgbWF4UGFyc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMsIHN0b3AgdGhlIGxvb3AgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZ29vZCBrbm93biByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZFRleHRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBjYXJldCBwb3NpdGlvbiB3aGVyZSB0byBpbnNlcnQgYSBuZXcgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyArPSBwYXN0ZWRUZXh0SW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9YWFggSGVyZSB3ZSBoYXZlIHRoZSByZXN1bHQgZm9yIHRoZSBgdHJ1bmNhdGVgIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gJ3RydW5jYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBJZiB0aGUgdXNlciBhcyBkZWZpbmVkIGEgdHJ1bmNhdGUgY2FsbGJhY2sgYW5kIHRoZXJlIGFyZSBzdGlsbCBzb21lIG51bWJlcnMgKHRoYXQgd2lsbCBiZSBkcm9wcGVkKSwgdGhlbiBjYWxsIHRoaXMgY2FsbGJhY2sgd2l0aCB0aGUgaW5pdGlhbCBwYXN0ZSBhcyB3ZWxsIGFzIHRoZSByZW1haW5pbmcgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxhc3RHb29kS25vd25SZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9YWFggLi4uZWxzZSB3ZSBuZWVkIHRvIGNvbnRpbnVlIG1vZGlmeWluZyB0aGUgcmVzdWx0IGZvciB0aGUgJ3JlcGxhY2UnIG9wdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGQuIFVudGlsIHRoZXJlIGFyZSBudW1iZXJzIHRvIHBhc3RlLCByZXBsYWNlIHRoZSBpbml0aWFsIG51bWJlcnMgb25lIGJ5IG9uZSwgYW5kIHN0aWxsIGRvIHRoZSByYW5nZSB0ZXN0LlxyXG4gICAgICAgICAgICAgICAgLy8gICAgU3RvcCB3aGVuIHlvdSBoYXZlIG5vIG1vcmUgbnVtYmVycyB0byBwYXN0ZSwgb3IgaWYgeW91IGFyZSBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cy5cclxuICAgICAgICAgICAgICAgIC8vICAgIElmIHlvdSBkbyBnZXQgdG8gdGhlIHJhbmdlIGxpbWl0cywgdXNlIHRoZSBwcmV2aW91cyBrbm93biBnb29kIHZhbHVlIHdpdGhpbiB0aG9zZSBsaW1pdHMuXHJcbiAgICAgICAgICAgICAgICAvLyAgICBOb3RlOiBUaGUgbnVtYmVycyBhcmUgcmVwbGFjZWQgb25lIGJ5IG9uZSwgaW4gdGhlIGludGVnZXIgdGhlbiBkZWNpbWFsIHBhcnQsIHdoaWxlIGlnbm9yaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFdoYXQgc2hvdWxkIGhhcHBlbiBpZiB0aGUgdXNlciB0cnkgdG8gcGFzdGUgYSBkZWNpbWFsIG51bWJlcj8gU2hvdWxkIHdlIG92ZXJyaWRlIHRoZSBjdXJyZW50IGluaXRpYWwgZGVjaW1hbCBjaGFyYWN0ZXIgaW4gZmF2b3Igb2YgdGhpcyBuZXcgb25lPyBJZiB3ZSBkbywgdGhlbiB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoZSB2TWluL3ZNYXggZnJvbSB0aGUgc3RhcnQgaW4gb3JkZXIgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhpcyBuZXcgZGVjaW1hbCBjaGFyYWN0ZXIgcG9zaXRpb24uLlxyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHb29kS25vd25SZXN1bHRJbmRleCA9IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEdvb2RLbm93blJlc3VsdFNpemUgPSBsYXN0R29vZEtub3duUmVzdWx0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFzdGVkVGV4dEluZGV4IDwgcGFzdGVkVGV4dC5sZW5ndGggJiYgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4IDwgbGFzdEdvb2RLbm93blJlc3VsdFNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEdvb2RLbm93blJlc3VsdFtsYXN0R29vZEtub3duUmVzdWx0SW5kZXhdID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2tpcCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ3JlcGxhY2VtZW50Jy4gVGhhdCB3YXksIHdlIGRvIG5vdCBjaGFuZ2UgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHBvc2l0aW9uIHJlZ2FyZGluZyB0aGUgcmVtYWluaW5nIG51bWJlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVwbGFjZSBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VDaGFyQXQobGFzdEdvb2RLbm93blJlc3VsdCwgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4LCBwYXN0ZWRUZXh0W3Bhc3RlZFRleHRJbmRleF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgbGltaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmSW5SYW5nZShyZXN1bHQsIG1pblBhcnNlLCBtYXhQYXJzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cywgc3RvcCB0aGUgbG9vcCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBnb29kIGtub3duIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkVGV4dEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gbGFzdEdvb2RLbm93blJlc3VsdEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRvdCBoYXMgYmVlbiByZW1vdmVkIGZvciB0aGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQsIHdlIGRlY3JlbWVudCB0aGUgY2FyZXQgaW5kZXggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxhc3RHb29kS25vd25SZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8qIDRjLiBOb3JtYWwgcGFzdGUgYmVoYXZpb3I6XHJcbiAgICAgICAgICAgICAqIEluc2VydCB0aGUgcGFzdGVkIG51bWJlciBpbnNpZGUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgdGV4dCwgYXQgdGhlIHJpZ2h0IGNhcmV0IHBvc2l0aW9uIG9yIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxyXG4gICAgICAgICAgICBjYXNlICdjbGFtcCc6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBHZW5lcmF0ZSB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Rm9ybWF0dGVkUGFydDIgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRGb3JtYXR0ZWRQYXJ0MiA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZShzZWxlY3Rpb25FbmQsIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYS4gSWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgc2VsZWN0ZWQgcGFydCwgYW5kIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGxlZnRGb3JtYXR0ZWRQYXJ0MiArIHJpZ2h0Rm9ybWF0dGVkUGFydDIsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGIuIEVsc2UgaWYgdGhpcyBpcyBvbmx5IG9uZSBjYXJldCAoYW5kIHRoZXJlZm9yZSBubyBzZWxlY3Rpb24pLCB0aGVuIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2V0UmF3TmVnYXRpdmVTaWduKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBwYXN0ZSBpcyBuZWdhdGl2ZSBhbmQgdGhlIGluaXRpYWwgdmFsdWUgaXMgbm90LCB0aGVuIEkgbXVzdCBvZmZzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGJ5IG9uZSBwbGFjZSB0byB0aGUgcmlnaHQgdG8gdGFrZSB0aGUgYWRkaXRpb25hbCBoeXBoZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQgKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGFuZCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCk/XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGVmdFBhcnQgPSByZXN1bHQuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcpO1xyXG4gICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmVzdWx0LnNsaWNlKGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCByZXN1bHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXN0ZWRUZXh0ID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBvbmx5IHBhc3RlIGEgc2luZ2xlIGRlY2ltYWwgY2hhcmFjdGVyLCB0aGVuIHdlIHJlbW92ZSB0aGUgcHJldmlvdXNseSBleGlzdGluZyBvbmUgKGlmIGFueSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdFBhcnQsICcuJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgSSByZW1vdmUgYSBkb3QgaGVyZSwgdGhlbiBJIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvbiAoZGVjcmVtZW50IGl0IGJ5IDEpIHdoZW4gcG9zaXRpb25pbmcgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gZG8gc28sIHdlIGtlZXAgdGhhdCBpbmZvIGluIG9yZGVyIHRvIG1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnRDb250YWluZWRBRG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnQgPSBsZWZ0UGFydC5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByaWdodFBhcnQucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tIEhlcmUsIHdlIGFyZSBnb29kIHRvIGdvIHRvIGNvbnRpbnVlIG9uIHRoZSBzYW1lIGJhc2lzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7bGVmdFBhcnR9JHtwYXN0ZWRUZXh0fSR7cmlnaHRQYXJ0fWA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMi4gQ2FsY3VsYXRlIHRoZSBjYXJldCBwb3NpdGlvbiBpbiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGZvciBsYXRlciB1c2VcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc2VsZWN0aW9uLCB0aGVuIHRoZSBjYXJldCBwb3NpdGlvbiBpcyBzZXQgYWZ0ZXIgdGhlIHBhc3RlZCB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBpbmRleFdoZXJlUGFzdGVkVGV4dEhhc0JlZW5JbnNlcnRlZCArIHBhc3RlZFRleHQubGVuZ3RoOyAvLyBJIG11c3Qgbm90IGNvdW50IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFzdGVkIHRleHQgKGllLiAnLicpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbElucHV0VGV4dFNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGFsbCB0aGUgaW5wdXQgdGV4dCBpcyBzZWxlY3RlZCBiZWZvcmUgcGFzdGluZywgd2hpY2ggbWVhbnMgd2UnbGwgY29tcGxldGVseSBlcmFzZSBpdHMgY29udGVudCBhbmQgcGFzdGUgb25seSB0aGUgY2xpcGJvYXJkIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRQYXJ0ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBzZWxlY3RlZCBmcm9tIHRoZSBjYXJldCBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCAob24gdGhlIGZhciByaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkgKyBwYXN0ZWRUZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uRW5kLCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBJIG11c3Qgbm90IGNvdW50IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFzdGVkIHRleHQgKGllLiAnLicpLCBvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9ycyBpbiB0aGUgaW5pdGlhbCBzZWxlY3RlZCB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IGUudGFyZ2V0LnZhbHVlLnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSAtIHNlbGVjdGlvblNpemUgKyBjb3VudENoYXJJblRleHQoaG9sZGVyLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIHNlbGVjdGVkVGV4dCkgKyBwYXN0ZWRUZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBmb3Igc3BlY2lhbCBjYXNlcywgb25seSBpZiB0aGUgd2hvbGUgaW5wdXQgaGFzIG5vdCBiZWVuIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIHZhbHVlIGhhcyBhICctJyBzaWduLCBidXQgdGhlIGluaXRpYWwgdmFsdWUgZG9lcyBub3QsIG9mZnNldCB0aGUgaW5kZXggYnkgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFBhcnRDb250YWluZWRBRG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDUuIENoZWNrIGlmIHRoZSByZXN1bHQgaXMgYSB2YWxpZCBudW1iZXIsIGlmIG5vdCwgZHJvcCB0aGUgcGFzdGUgYW5kIGRvIG5vdGhpbmcuXHJcbiAgICAgICAgaWYgKCFpc051bWJlcihyZXN1bHQpIHx8IHJlc3VsdCA9PT0gJycpIHtcclxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgd291bGQgcmVzdWx0IGludG8gYW4gaW52YWxpZCBjb250ZW50ICcke3Jlc3VsdH0nLmApOyAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gVGhpcyBpcyBub3QgRFJZIDsgcmVmYWN0b3Igd2l0aCBhYm92ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDYuIElmIGl0J3MgYSB2YWxpZCBudW1iZXIsIGNoZWNrIGlmIGl0IGZhbGxzIGluc2lkZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgdGhpcyBmYWlscywgbW9kaWZ5IHRoZSB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBwcm9jZWR1cmUgOlxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogSWYgJ2Vycm9yJyAodGhpcyBpcyB0aGUgZGVmYXVsdCkgOlxyXG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXHJcbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgaWYgaXQgZmFpbHMsIHRoZW4gdGhyb3cgYW4gZXJyb3IgaW4gdGhlIGNvbnNvbGUuXHJcbiAgICAgICAgICogICAgICAtIERvIG5vdCBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlLCBkbyBub3QgY2hhbmdlIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgICAgICAgKiBJZiAnaWdub3JlJyA6XHJcbiAgICAgICAgICogICAgICAtIE5vcm1hbCBwYXN0ZSBiZWhhdmlvci5cclxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgZG8gbm90aGluZyBtb3JlLlxyXG4gICAgICAgICAqICAgICAgLSBEbyBub3QgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgZG8gbm90IGNoYW5nZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICAgICAgICogSWYgJ2NsYW1wJyA6XHJcbiAgICAgICAgICogICAgICAtIE5vcm1hbCBwYXN0ZSBiZWhhdmlvci5cclxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgc2V0IHRoZSB2YWx1ZSB0byB0aGUgbWluaW11bSBvciBtYXhpbXVtIGxpbWl0LCB3aGljaGV2ZXIgaXMgY2xvc2VzdCB0byB0aGVcclxuICAgICAgICAgKiAgICAgICAgcGFzdGUgcmVzdWx0LlxyXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgb24gdGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBkZWNpbWFsIGNoYXJhY3Rlci5cclxuICAgICAgICAgKiBJZiAndHJ1bmNhdGUnIDpcclxuICAgICAgICAgKiAgICAgIC0gVHJ1bmNhdGUgcGFzdGUgYmVoYXZpb3IuXHJcbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgdW50aWwgaXQgZmFpbHMgKGlmIHRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSBtaW4gYW5kIG1heCB2YWx1ZSBsaW1pdHMpLlxyXG4gICAgICAgICAqICAgICAgLSBEcm9wIHRoZSByZW1haW5pbmcgbm9uLXBhc3RlZCBudW1iZXJzLCBhbmQga2VlcCB0aGUgbGFzdCBrbm93biBub24tZmFpbGluZyByZXN1bHQuXHJcbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBhZnRlciB0aGUgbGFzdCBwYXN0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAqIElmICdyZXBsYWNlJyA6XHJcbiAgICAgICAgICogICAgICAtIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3IuXHJcbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgdW50aWwgaXQgZmFpbHMgKGlmIHRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSBtaW4gYW5kIG1heCB2YWx1ZSBsaW1pdHMpLlxyXG4gICAgICAgICAqICAgICAtIFRoZW4gdHJ5IHRvIHJlcGxhY2UgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIHdpdGggdGhlIHBhc3RlZCBvbmVzLiBPbmNlIGl0IGZhaWxzLCBrZWVwIHRoZSBsYXN0IGtub3duIG5vbi1mYWlsaW5nIHJlc3VsdC5cclxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIGFmdGVyIHRoZSBsYXN0IHBhc3RlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IHZhbHVlSGFzQmVlblNldCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB2YWx1ZUhhc0JlZW5DbGFtcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHZhbHVlSGFzQmVlblNldCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsZXQgY2xhbXBlZFZhbHVlO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYW1wZWRWYWx1ZSA9IGNsYW1wVG9SYW5nZUxpbWl0cyhyZXN1bHQsIGhvbGRlci5zZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGNsYW1wZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBGYXRhbCBlcnJvcjogVW5hYmxlIHRvIHNldCB0aGUgY2xhbXBlZCB2YWx1ZSAnJHtjbGFtcGVkVmFsdWV9Jy5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlbkNsYW1wZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlblNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2xhbXBlZFZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgb25seSBmb3Igc2V0dGluZyB0aGUgY2FyZXQgcG9zaXRpb24gbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGFzdGVkIHZhbHVlICcke3Jhd1Bhc3RlZFRleHR9JyByZXN1bHRzIGluIGEgdmFsdWUgJyR7cmVzdWx0fScgdGhhdCBpcyBvdXRzaWRlIG9mIHRoZSBtaW5pbXVtIFske2hvbGRlci5zZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bSBbJHtob2xkZXIuc2V0dGluZ3MubWF4aW11bVZhbHVlfV0gdmFsdWUgcmFuZ2UuYCk7XHJcbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyAuLi5hbmQgbm90aGluZyBlbHNlIHNob3VsZCBiZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDcuIFRoZW4gbGFzdGx5LCBzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGF0IHRoZSByaWdodCBsb2dpY2FsIHBsYWNlXHJcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcjtcclxuICAgICAgICBpZiAodmFsdWVIYXNCZWVuU2V0KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFtcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlSGFzQmVlbkNsYW1wZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBlLnRhcmdldC52YWx1ZS5sZW5ndGggLSBob2xkZXIuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKTsgLy8gVGhpcyBwdXRzIHRoZSBjYXJldCBvbiB0aGUgcmlnaHQgb2YgdGhlIGxhc3QgZGVjaW1hbCBwbGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTsgLy8gLi5hbmQgdGhpcyBvbiB0aGUgZmFyIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBpZiB0aGUgdmFsdWUgaGFzIG5vdCBiZWVuIGNsYW1wZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHVzZWQuLi5cclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0cnVuY2F0ZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW5ldmVyIG9uZSBvciBtdWx0aXBsZSBjaGFyYWN0ZXJzIGFyZSBwYXN0ZWQsIHRoaXMgbWVhbnMgd2UgaGF2ZSB0byBtYW5hZ2UgdGhlIHBvdGVudGlhbCB0aG91c2FuZCBzZXBhcmF0b3JzIHRoYXQgY291bGQgYmUgYWRkZWQgYnkgdGhlIGZvcm1hdHRpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIgPSBmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKHJlc3VsdCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIGUudGFyZ2V0LnZhbHVlLCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gOC4gV2UgbWFrZSBzdXJlIHdlIHNlbmQgYW4gaW5wdXQgZXZlbnQgb25seSBpZiB0aGUgcmVzdWx0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBpbml0aWFsIHZhbHVlIGJlZm9yZSB0aGUgcGFzdGVcclxuICAgICAgICBpZiAodmFsdWVIYXNCZWVuU2V0ICYmIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSAhPT0gZS50YXJnZXQudmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gT24gYSAnbm9ybWFsJyBub24tYXV0b051bWVyaWMgaW5wdXQsIGFuIGBpbnB1dGAgZXZlbnQgaXMgc2VudCB3aGVuIGEgcGFzdGUgaXMgZG9uZS4gV2UgbWltaWMgdGhhdC5cclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25TdWJtaXQoJHRoaXMsIGhvbGRlcikge1xyXG4gICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuZm9ybWF0T25TdWJtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGpRdWVyeSBzZWxlY3RlZCBpbnB1dCBpZiB0aGUgdGFnIGFuZCB0eXBlIGFyZSBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcclxuICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxyXG4gICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIGlucHV0IHR5cGVzXHJcbiAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICRpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgb25seSBpZiB0aGUgYGZvcm1hdE9uUGFnZUxvYWRgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICRpbnB1dCBqUXVlcnktc2VsZWN0ZWQgPGlucHV0PiBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQoc2V0dGluZ3MsICRpbnB1dCwgJHRoaXMpIHtcclxuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMpO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGJlZW4gc2V0IGJ5IHRoZSBkZXYsIGJ1dCBub3QgZGlyZWN0bHkgYXMgYW4gYXR0cmlidXRlIGluIHRoZSBodG1sLCB0aGVuIGl0IHRha2VzXHJcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkYCkpLlxyXG4gICAgICAgICAgICAgKiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlciBoYXMgc2V0IGZvciBgZGF0YS1hbi1kZWZhdWx0YCBpbiB0aGUgaHRtbCAoYXNwLm5ldCB1c2VycykuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cclxuICAgICAgICAgICAgICogQnV0IGlmIGBpbnB1dC52YWx1ZWAgaXMgc2V0IHRvIGEgbnVtYmVyLCBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsIHRoZW4gaXQgbWVhbnMgdGhlIGRldiBoYXNcclxuICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXHJcbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXHJcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBpZ25vcmUgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBhbHRvZ2V0aGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUgPSB0b051bWVyaWNWYWx1ZShjdXJyZW50VmFsdWUsIHNldHRpbmdzKTsgLy8gVGhpcyBhbGxvd3MgdG8gdXNlIGEgbG9jYWxpemVkIHZhbHVlIG9uIHN0YXJ0dXAgb0RlY1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHVuTG9jYWxpemVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogQ2hlY2tzIGZvciA6XHJcbiAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxyXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIFRoZSBmb2xsb3dpbmcgSFRNTCBkYXRhIGF0dHJpYnV0ZSBpcyBSRVFVSVJFRCAoZGF0YS1hbi1kZWZhdWx0PVwic2FtZSB2YWx1ZSBhcyB0aGUgdmFsdWUgYXR0cmlidXRlXCIpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUudG9TdHJpbmcoKSAhPT0gY3VycmVudFZhbHVlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICFpc051bWJlcih1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ2dldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgdmFsdWUgc2hvdWxkIE5PVCBiZSBzYXZlZCBpbiBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGN1cnJlbnRWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJyAmJiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmUoY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA9PT0gJHRoaXMuYXR0cigndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgPT09ICR0aGlzLnRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmhhbmNlIHRoZSB1c2VyIGV4cGVyaWVuY2UgYnkgbW9kaWZ5aW5nIHRoZSBkZWZhdWx0IGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGRlcGVuZGluZyBvbiBgY3VycmVuY3lTeW1ib2xgIGFuZCBgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnRgLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gKGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGApLCBidXQgaGFzIHNldCBhIGN1cnJlbmN5IHN5bWJvbCAoYGN1cnJlbmN5U3ltYm9sYCksXHJcbiAgICAgKiB0aGVuIHdlIG1vZGlmeSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGluIG9yZGVyIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvdXRwdXQgbG9naWNhbCBieSBkZWZhdWx0IDpcclxuICAgICAqIC0gXCIkLTEsMjM0LjU2XCIgaW5zdGVhZCBvZiBcIi0kMSwyMzQuNTZcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSlcclxuICAgICAqIC0gXCItMSwyMzQuNTYkXCIgaW5zdGVhZCBvZiBcIjEsMjM0LjU2LSRcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJwXCJ9KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBJZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyBhbHJlYWR5IHNldCwgd2UgZG8gbm90IG92ZXJ3cml0ZSBpdFxyXG4gICAgICAgIGlmICghaXNOdWxsKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNldHRpbmdzKSAmJlxyXG4gICAgICAgICAgICBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpICYmXHJcbiAgICAgICAgICAgICFpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gJ3AnOyAvLyBEZWZhdWx0IC0xLDIzNC41NiDigqxcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gJ2wnOyAvLyBEZWZhdWx0IC0kMSwyMzQuNTZcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNldHMgdGhlIGRlZmF1bHQgdmFsdWUgaWYgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBpcyBgbnVsbGBcclxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAnbCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5hbHl6ZSBhbmQgc2F2ZSB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgaW50ZWdlciBzaXplIGZvciBsYXRlciB1c2VzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzKHNldHRpbmdzKSB7XHJcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIGxldCBbbWluaW11bVZhbHVlSW50ZWdlclBhcnRdID0gKCFzZXR0aW5ncy5taW5pbXVtVmFsdWUgJiYgc2V0dGluZ3MubWluaW11bVZhbHVlICE9PSAwKT9bXTpzZXR0aW5ncy5taW5pbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIG1heGltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWF4aW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICBtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XHJcblxyXG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heChtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xyXG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGFzIG5lZWRlZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uKHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR0aW5ncy5vRGVjID0gU3RyaW5nKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XHJcblxyXG4gICAgICAgIC8vIE1vc3QgY2FsY3VsdXMgYXNzdW1lIGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGlzIGFuIGludGVnZXIsIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IG1ha2VzIGl0IGNsZWFyIChvdGhlcndpc2UgaGF2aW5nIGl0IGFzIGEgc3RyaW5nIGxlYWRzIHRvIHByb2JsZW1zIGluIHJvdW5kaW5nIGZvciBpbnN0YW5jZSlcclxuICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcuJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcsJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLCcgJiYgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPSAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZXMgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKSB7XHJcbiAgICAgICAgY29uc3QgYWxsTnVtYmVyc1JlZyA9ICdbMC05XSc7XHJcbiAgICAgICAgY29uc3Qgbm9BbGxOdW1iZXJzUmVnID0gJ1teMC05XSc7XHJcblxyXG4gICAgICAgIC8vIFRlc3QgaWYgdGhlcmUgaXMgYSBuZWdhdGl2ZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZ1xyXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YChbLVxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1dPylgOicoLT8pJztcclxuICAgICAgICBzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwID0gYU5lZ1JlZztcclxuXHJcbiAgICAgICAgbGV0IG5lZ2F0aXZlU2lnblJlZ1BhcnQ7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25SZWdQYXJ0ID0gYFxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7bmVnYXRpdmVTaWduUmVnUGFydH1cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dLio/KCR7YWxsTnVtYmVyc1JlZ318XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9KWApO1xyXG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKCR7YWxsTnVtYmVyc1JlZ31cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8pW15cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dJHtub0FsbE51bWJlcnNSZWd9KiRgKTtcclxuXHJcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcclxuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnJyk7XHJcbiAgICAgICAgc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfSg/OlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9Pygke2FsbE51bWJlcnNSZWd9K1xcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfSspfCgke2FsbE51bWJlcnNSZWd9Kig/OlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfSopPykpYCk7XHJcblxyXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcclxuICAgICAgICBzZXR0aW5ncy5zdHJpcFJlZyA9IG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooJHthbGxOdW1iZXJzUmVnfSlgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJyBsYXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKSB7XHJcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgJ3RydWUnIGFuZCAnZmFsc2UnIHRvIHJlYWwgQm9vbGVhblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcclxuICAgICAgICAgICAgLy9UT0RPIGlmIGEgdmFsdWUgaXMgYWxyZWFkeSBvZiB0eXBlICdOdW1iZXInLCBzaG91bGRuJ3Qgd2Uga2VlcCBpdCBhcyBhIG51bWJlciBmb3IgZnVydGhlciBtYW5pcHVsYXRpb24sIGluc3RlYWQgb2YgdXNpbmcgYSBzdHJpbmc/XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBvbGQgc2V0dGluZ3Mgb3B0aW9ucyBuYW1lIHRvIG5ldyBvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpIHtcclxuICAgICAgICAvL1RPRE8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gb25jZSB0aGUgb2xkIG9wdGlvbnMgYXJlIG5vdCB1c2VkIGFueW1vcmVcclxuICAgICAgICBjb25zdCBvbGRPcHRpb25zQ29udmVydGVyID0ge1xyXG4gICAgICAgICAgICAvLyBPbGQgb3B0aW9uIG5hbWUsIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBuZXcgb3B0aW9uXHJcbiAgICAgICAgICAgIGFTZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRHcm91cFNlcGFyYXRvcicsXHJcbiAgICAgICAgICAgIG5TZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9TZXBhcmF0b3JPbkZvY3VzJyxcclxuICAgICAgICAgICAgZEdyb3VwICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdGFsR3JvdXBTcGFjaW5nJyxcclxuICAgICAgICAgICAgYURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyJyxcclxuICAgICAgICAgICAgYWx0RGVjICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnLFxyXG4gICAgICAgICAgICBhU2lnbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sJyxcclxuICAgICAgICAgICAgcFNpZ24gICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcsXHJcbiAgICAgICAgICAgIHBOZWcgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnLFxyXG4gICAgICAgICAgICBhU3VmZml4ICAgICAgICAgICAgICAgICAgICAgIDogJ3N1ZmZpeFRleHQnLFxyXG4gICAgICAgICAgICBvTGltaXRzICAgICAgICAgICAgICAgICAgICAgIDogJ292ZXJyaWRlTWluTWF4TGltaXRzJyxcclxuICAgICAgICAgICAgdk1heCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtYXhpbXVtVmFsdWUnLFxyXG4gICAgICAgICAgICB2TWluICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pbmltdW1WYWx1ZScsXHJcbiAgICAgICAgICAgIG1EZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyxcclxuICAgICAgICAgICAgZURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyxcclxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsICAgICAgICAgICAgICAgICA6ICdzY2FsZURlY2ltYWxQbGFjZXMnLFxyXG4gICAgICAgICAgICBhU3RvciAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnLFxyXG4gICAgICAgICAgICBtUm91bmQgICAgICAgICAgICAgICAgICAgICAgIDogJ3JvdW5kaW5nTWV0aG9kJyxcclxuICAgICAgICAgICAgYVBhZCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhbGxvd0RlY2ltYWxQYWRkaW5nJyxcclxuICAgICAgICAgICAgbkJyYWNrZXQgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicsXHJcbiAgICAgICAgICAgIHdFbXB0eSAgICAgICAgICAgICAgICAgICAgICAgOiAnZW1wdHlJbnB1dEJlaGF2aW9yJyxcclxuICAgICAgICAgICAgbFplcm8gICAgICAgICAgICAgICAgICAgICAgICA6ICdsZWFkaW5nWmVybycsXHJcbiAgICAgICAgICAgIGFGb3JtICAgICAgICAgICAgICAgICAgICAgICAgOiAnZm9ybWF0T25QYWdlTG9hZCcsXHJcbiAgICAgICAgICAgIHNOdW1iZXIgICAgICAgICAgICAgICAgICAgICAgOiAnc2VsZWN0TnVtYmVyT25seScsXHJcbiAgICAgICAgICAgIGFuRGVmYXVsdCAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdFZhbHVlT3ZlcnJpZGUnLFxyXG4gICAgICAgICAgICB1blNldE9uU3VibWl0ICAgICAgICAgICAgICAgIDogJ3VuZm9ybWF0T25TdWJtaXQnLFxyXG4gICAgICAgICAgICBvdXRwdXRUeXBlICAgICAgICAgICAgICAgICAgIDogJ291dHB1dEZvcm1hdCcsXHJcbiAgICAgICAgICAgIGRlYnVnICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2hvd1dhcm5pbmdzJyxcclxuICAgICAgICAgICAgLy8gQ3VycmVudCBvcHRpb25zIDpcclxuICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG5vU2VwYXJhdG9yT25Gb2N1cyAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiB0cnVlLFxyXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93UG9zaXRpdmVTaWduICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc3VmZml4VGV4dCAgICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG92ZXJyaWRlTWluTWF4TGltaXRzICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZSAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2NhbGVEaXZpc29yICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbFBsYWNlcyAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzY2FsZVN5bWJvbCAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9uSW52YWxpZFBhc3RlICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgYWxsb3dEZWNpbWFsUGFkZGluZyAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNlbGVjdEFsbE9uRm9jdXNJZlplcm8gICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZW1wdHlJbnB1dEJlaGF2aW9yICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBmb3JtYXRPblBhZ2VMb2FkICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICB1bmZvcm1hdE9uU3VibWl0ICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3dXYXJuaW5ncyAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBmYWlsT25Vbmtub3duT3B0aW9uICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgLy9GSVhNRSBGaW5kIGEgd2F5IHRvIGV4Y2x1ZGUgdGhvc2UgaW50ZXJuYWwgZGF0YSBmcm9tIHRoZSBzZXR0aW5ncyBvYmplY3QgKGlkZWFsbHkgYnkgdXNpbmcgYW5vdGhlciBvYmplY3QsIG9yIGJldHRlciB5ZXQsIGNsYXNzIGF0dHJpYnV0ZXMpIC0tPlxyXG4gICAgICAgICAgICBoYXNGb2N1cyAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzdHJpcCAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbmVnYXRpdmVTaWduQ2hhcmFjdGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBwb3NpdGl2ZVNpZ25DaGFyYWN0ZXI6IHRydWUsXHJcbiAgICAgICAgICAgIG1JbnRQb3MgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbUludE5lZyAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvRGVjICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9QYWQgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb0JyYWNrZXQgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvU2VwICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9TaWduICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb1N1ZmZpeCAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBhTmVnUmVnQXV0b1N0cmlwICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNraXBGaXJzdEF1dG9TdHJpcCAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2tpcExhc3RBdXRvU3RyaXAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBhbGxvd2VkQXV0b1N0cmlwICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG51bVJlZ0F1dG9TdHJpcCAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc3RyaXBSZWcgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBob2xkZXIgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiBpcyBhICduZXcnIG9wdGlvbiwgd2UgY29udGludWUgbG9vcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRPcHRpb25zQ29udmVydGVyLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHdlIGhhdmUgYW4gJ29sZCcgb3B0aW9uIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nKGBZb3UgYXJlIHVzaW5nIHRoZSBkZXByZWNhdGVkIG9wdGlvbiBuYW1lICcke29wdGlvbn0nLiBQbGVhc2UgdXNlICcke29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXX0nIGluc3RlYWQgZnJvbSBub3cgb24uIFRoZSBvbGQgb3B0aW9uIG5hbWUgd2lsbCBiZSBkcm9wcGVkIHNvb24uYCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gd2UgbW9kaWZ5IHRoZSBpbml0aWFsIG9wdGlvbiBvYmplY3QgdG8gdXNlIHRoZSBuZXcgb3B0aW9ucyBpbnN0ZWFkIG9mIHRoZSBvbGQgb25lc1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dXSA9IG9wdGlvbnNbb3B0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc1tvcHRpb25dO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5vciB0aGUgb3B0aW9uIG5hbWUgaXMgdW5rbm93bi4gVGhpcyBtZWFucyB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgb3B0aW9ucyBvYmplY3QsIHRoZXJlZm9yZSB3ZSB0aHJvdyBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBPcHRpb24gbmFtZSAnJHtvcHRpb259JyBpcyB1bmtub3duLiBQbGVhc2UgZml4IHRoZSBvcHRpb25zIHBhc3NlZCB0byBhdXRvTnVtZXJpY2ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5hbHlzZSB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBwYXNzZWQgYnkgdGhlIHVzZXIsIHZhbGlkYXRlIGFuZCBjbGVhbiB0aGVtLCB0aGVuIHJldHVybiB0aGVtLlxyXG4gICAgICogTm90ZTogVGhpcyByZXR1cm5zIGBudWxsYCBpZiBzb21laG93IHRoZSBzZXR0aW5ncyByZXR1cm5lZCBieSBqUXVlcnkgaXMgbm90IGFuIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGUgLSBJZiBUUlVFLCB0aGVuIHRoZSBzZXR0aW5ncyBhbHJlYWR5IGV4aXN0cyBhbmQgdGhpcyBmdW5jdGlvbiBvbmx5IHVwZGF0ZXMgdGhlbSBpbnN0ZWFkIG9mIHJlY3JlYXRpbmcgdGhlbSBmcm9tIHNjcmF0Y2hcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCB1cGRhdGUgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXHJcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCAhaXNOdWxsKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCBpc1VuZGVmaW5lZChzZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNldHRpbmdzIGFyZSB1cGRhdGVkXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHNldHRpbmdzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNldHRpbmdzIGFyZSBnZW5lcmF0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gYXR0ZW1wdCB0byBncmFiIHRoZSBIVE1MNSBkYXRhLiBJZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdGFnRGF0YSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvY3VzICAgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgICAgICA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmUgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhbmRyb2lkU2VsZWN0aW9uU3RhcnQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgICAgICAgOiB0cnVlLCAvLyBUaHJvdyBpbnB1dCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cmlwICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJ1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW1wcm92ZSB0aGUgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGNvcnJlY3ROZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudE9wdGlvbihzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIG5lZ2F0aXZlIGFuZCBwb3NpdGl2ZSBzaWducywgYXMgbmVlZGVkXHJcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9IHNldHRpbmdzLm1pbmltdW1WYWx1ZSA8IDAgPyAnLScgOiAnJztcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyID0gc2V0dGluZ3MubWF4aW11bVZhbHVlID49IDAgPyAnKycgOiAnJztcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgY2hhbmdlcyB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IChmcm9tIHRoZSBvcmlnaW5hbCBhdXRvQ29kZSgpIGZ1bmN0aW9uKVxyXG4gICAgICAgICAgICBydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QoJHRoaXMsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzZXR0aW5nc1xyXG4gICAgICAgICAgICB2YWxpZGF0ZShzZXR0aW5ncywgZmFsc2UpOyAvLyBUaHJvd3MgaWYgbmVjZXNzYXJ5XHJcblxyXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cywgc2NhbGVEaXZpc29yICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcclxuICAgICAgICAgICAga2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgbmV3IHNldHRpbmdzXHJcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyIHRoYXQgY2FuIGVpdGhlciBiZSA6XHJcbiAgICAgKiAtIGEgcmVhbCBudW1iZXIsXHJcbiAgICAgKiAtIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHJlYWwgbnVtYmVyLCBvclxyXG4gICAgICogLSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBsb2NhbGl6ZWQgbnVtYmVyICh3aXRoIHNwZWNpZmljIGdyb3VwIHNlcGFyYXRvcnMgYW5kIGRlY2ltYWwgY2hhcmFjdGVyKSxcclxuICAgICAqIC4uLnRvIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHJlYWwgJ2phdmFzY3JpcHQnIG51bWJlciAoaWUuICcxMjM0JyBvciAnMTIzNC41NjcnKS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYE5hTmAgaWYgc3VjaCBjb252ZXJzaW9uIGZhaWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW50fGZsb2F0fHN0cmluZ30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ3xOYU59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKE51bWJlcih2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBoYXMgZWl0aGVyIGFscmVhZHkgYmVlbiBzdHJpcHBlZCwgb3IgYSAncmVhbCcgamF2YXNjcmlwdCBudW1iZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEVsc2UgaWYgaXQncyBhIHN0cmluZyB0aGF0IGBOdW1iZXIoKWAgY2Fubm90IHR5cGVjYXN0LCB0aGVuIHdlIHRyeSB0byBjb252ZXJ0IHRoZSBsb2NhbGl6ZWQgbnVtZXJpYyBzdHJpbmcgdG8gYSBudW1lcmljIG9uZVxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWVyaWMgc3RyaW5nLCBzdHJpcHBpbmcgdW5uZWNlc3NhcnkgY2hhcmFjdGVycyBpbiB0aGUgcHJvY2Vzc1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCksIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc3RpbGwgbm90IGEgbnVtZXJpYyBzdHJpbmcsIHRoZW4gd2UgdGhyb3cgYSB3YXJuaW5nXHJcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIoTnVtYmVyKHJlc3VsdCkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmAsIHNldHRpbmdzLnNob3dXYXJuaW5ncyk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOYU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xyXG4gICAgICovXHJcbiAgICBjb25zdCBtZXRob2RzID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0byBpbml0aWFsaXplIGF1dG9OdW1lcmljIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIChvcHRpb25zIGNhbiBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIpXHJcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHtkaWdpdEdyb3VwU2VwYXJhdG9yOiBcIi5cIiwgZGVjaW1hbENoYXJhY3RlcjogXCIsXCIsIGN1cnJlbmN5U3ltYm9sOiAn4oKsICd9KVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCk7ICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb25zfSk7IC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7Knx7c3RhdGVtZW50cywgYnJhbmNoZXMsIGxpbmVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzLCBvdmVycmlkZXN9fHtzdGF0ZW1lbnRzLCBicmFuY2hlcywgbGluZXMsIGZ1bmN0aW9ucywgZXhjbHVkZXN9fHtzdGF0ZW1lbnRzLCBsaW5lcywgYnJhbmNoZXMsIGZ1bmN0aW9ucywgZXhjbHVkZXN9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0IHRoYXQgc3RvcmUgdGhlIGZpZWxkIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhvbGRlciA9IGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MucnVuT25jZSAmJiBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucnVuT25jZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBldmVudHMgbGlzdGVuZXJzIHRvIHN1cHBvcnRlZCBpbnB1dCB0eXBlcyAoXCJ0ZXh0XCIsIFwiaGlkZGVuXCIsIFwidGVsXCIgYW5kIG5vIHR5cGUpXHJcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0ICYmICR0aGlzLmRhdGEoJ2luaXRpYWxpemVkJykgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEhhbmRsZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzSW5BbmRNb3VzZUVudGVyOiBlID0+IHsgb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyLCBlKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Gb2N1c091dEFuZE1vdXNlTGVhdmU6IGUgPT4geyBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlkb3duOiBlID0+IHsgb25LZXlkb3duKGhvbGRlciwgZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5cHJlc3M6IGUgPT4geyBvbktleXByZXNzKGhvbGRlciwgZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6IGUgPT4geyBvbklucHV0KGhvbGRlciwgZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5dXA6IGUgPT4geyBvbktleXVwKGhvbGRlciwgc2V0dGluZ3MsIGUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblBhc3RlOiBlID0+IHsgb25QYXN0ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25KcUZvY3VzOiAoKSA9PiB7IGlmIChzZXR0aW5ncy5zZWxlY3RBbGxPbkZvY3VzSWZaZXJvICYmICR0aGlzLmF1dG9OdW1lcmljKCdnZXROdW1iZXInKSA9PT0gMCkgeyBzZXRUaW1lb3V0KCgpID0+ICR0aGlzLnNlbGVjdCgpLCAwKTsgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRDb25maWdzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmb2N1c2luJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbkZvY3VzSW5BbmRNb3VzZUVudGVyIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZW50ZXInLCBoYW5kbGVyOiBldmVudEhhbmRsZXJzLm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYmx1cicsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25Gb2N1c091dEFuZE1vdXNlTGVhdmUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VsZWF2ZScsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25Gb2N1c091dEFuZE1vdXNlTGVhdmUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAna2V5ZG93bicsIGhhbmRsZXI6IGV2ZW50SGFuZGxlcnMub25LZXlkb3duIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2tleXByZXNzJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbktleXByZXNzIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2lucHV0JywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbklucHV0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2tleXVwJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vbktleXVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Bhc3RlJywgaGFuZGxlcjogZXZlbnRIYW5kbGVycy5vblBhc3RlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb25maWdzLmZvckVhY2goZXZlbnRDb25maWcgPT4gdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50Q29uZmlnLm5hbWUsIGV2ZW50Q29uZmlnLmhhbmRsZXIsIGZhbHNlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpOyAvL1RPRE8gU3dpdGNoIHRvIGBhZGRFdmVudExpc3RlbmVyJ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZm9jdXMnLCBldmVudEhhbmRsZXJzLm9uSnFGb2N1cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzYzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsRXZlbnRzOiBlbCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDb25maWdzLmZvckVhY2goZXZlbnRDb25maWcgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudENvbmZpZy5uYW1lLCBldmVudENvbmZpZy5oYW5kbGVyLCBmYWxzZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVsKS5vZmYoJ2ZvY3VzJywgZXZlbnRIYW5kbGVycy5vbkpxRm9jdXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVsKS5jbG9zZXN0KCdmb3JtJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9mZignLmF1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gc3RvcCBhbmQgcmVtb3ZlIGF1dG9OdW1lcmljIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gICAgICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gRGVzdHJveXMgYXV0b051bWVyaWMgb24gdGhpcyBzZWxlY3RlZCBlbGVtZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyVmFsdWUgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGNsZWFycyB0aGUgdGV4dCBib3ggdXBvbiBkZXN0cnVjdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVzdHJveShjbGVhclZhbHVlID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIGNsZWFyVmFsdWUgPT09IHRydWUgPyAnJyA6ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICd3aXBlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnbWlzYycpLnJlbW92ZUFsbEV2ZW50cyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycsICdpbml0aWFsaXplZCcsICdyZW1vdmVBbGxFdmVudHMnKTtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGZyb20gc2Vzc2lvblN0b3JhZ2UgKG9yIGNvb2tpZSwgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHMpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwid2lwZVwiKTsgLy8gUmVtb3ZlcyBzZXNzaW9uIHN0b3JhZ2UgYW5kIGNvb2tpZXMgZnJvbSBtZW1vcnlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aXBlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICd3aXBlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IHVwZGF0ZXMgdGhlIGF1dG9OdW1lcmljIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkLlxyXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7ZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLCBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnfSkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gVXBkYXRlcyB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgY3VycmVudCB1bmZvcm1hdHRlZCBpbnB1dCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICBnZXRBdXRvTnVtZXJpY0hvbGRlcigkdGhpcywgc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlZm9ybWF0IHRoZSBpbnB1dCB2YWx1ZSB3aXRoIHRoZSBuZXcgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc3RyaXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gZm9ybWF0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogSWYgdGhlIHZhbHVlIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgaXQgY2FuIGJlIGFuIGludGVnZXIgJzEyMzQnIG9yIGEgZG91YmxlICcxMjM0LjU2Nzg5J1xyXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnc2V0JywgJzEyMzQ1LjY3Jyk7IC8vIEZvcm1hdHMgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCB8fCBpc1VuZGVmaW5lZChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgbG9va3MgYSBsb3QgbGlrZSBgZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoKWAuIElzIHRoYXQgbmVjZXNzYXJ5PyBDYW4gdGhlIGlucHV0IGVsZW1lbnQgYmUgY2hhbmdlZCBzaW5jZSBhdXRvTnVtZXJpYyBoYXMgYmVlbiBpbml0aWFsaXplZD9cclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0cmFpbGluZyBuZWdhdGl2ZSBzZXR0aW5ncywgc2luY2UgaXQncyBwb3NzaWJsZSB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIG5lZ2F0aXZlLCBidXQgbm90IHRoZSBuZXdseSBzZXQgb25lXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRvTnVtZXJpY1ZhbHVlKG5ld1ZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRlc3QgaXMgbmVlZGVkIGJ5IHRoZSBzaG93UG9zaXRpdmVTaWduIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IGlzWmVyb09ySGFzTm9WYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWmVybykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCB8fCBpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBlbnN1cmUgcm91bmRpbmcgZG9lcyBub3QgaGFwcGVuIHR3aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQmVlblJvdW5kZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByb3VuZHMgdGhlIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBEZWNpbWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wRGVjaW1hbCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJvdW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHRlbXBEZWNpbWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgIXNldHRpbmdzLm9uT2ZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9OdW1lcmljVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBEZWNpbWFsID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0JlZW5Sb3VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRzIGlmIHRoaXMgaGFzIG5vdCBiZWVuIGRvbmUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNCZWVuUm91bmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlcyByYXdWYWx1ZSBpbmNsdWRpbmcgdGhlIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzICYmICFzZXR0aW5ncy5vbk9mZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHRlbXBEZWNpbWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAmJiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3NldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICd3aXBlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7YXR0ZW1wdGVkVmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3NldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtVmFsdWUgWyR7c2V0dGluZ3MubWF4aW11bVZhbHVlfV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaGFzRm9jdXMgJiYgc2V0dGluZ3Muc2NhbGVTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudGV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gdW4tZm9ybWF0IGlucHV0cy5cclxuICAgICAgICAgKiBUaGlzIGlzIGhhbmR5IHRvIHVzZSByaWdodCBiZWZvcmUgZm9ybSBzdWJtaXNzaW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmdzIChpZS4gXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiKSwgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kLlxyXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMuXHJcbiAgICAgICAgICogUGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5TZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgJHRoaXMuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMuXHJcbiAgICAgICAgICogVGhpcyBpcyBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlICd1blNldCcgbWV0aG9kIHRvIHJlZm9ybWF0IHRoZSBpbnB1dFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdyZVNldCcpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlU2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBXaHkgd291bGQgd2UgbmVlZCB0byBnZXQgYSBuZXcgcmVmZXJlbmNlIHRvICR0aGlzIHNpbmNlIGl0IGhhcyBiZWVuIGRvbmUgaW4gYGluaXQoKWA/XHJcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XHJcbiAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kLmApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGVsZW1lbnQgdHlwZSB0aGVuIHVzZSAuZXEoMCkgc2VsZWN0b3IgdG8gZ3JhYiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gc2VsZWN0b3JcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcy5lcSgwKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS50ZXh0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgXCI8JHskdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKX0+XCIgdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKC9cXGQvKS50ZXN0KHZhbHVlKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlIHx8IHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXBzIHRyYWlsaW5nIG5lZ2F0aXZlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpbXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgemVyb3Mgd2hlbiBsZWFkaW5nWmVybyBkb2VzIE5PVCBlcXVhbCBcImtlZXBcIi5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlcyB0aGUgbmVnYXRpdmUgc3ltYm9sIGluIGZyb250IG9mIHRoZSB0cmFpbGluZyBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmIGlzVmFsdWVOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZSh2YWx1ZSkgJiYgTnVtYmVyKHZhbHVlKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICctJyArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnIHx8IHZhbHVlID09PSAnJyAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYSBudW1lcmljIHN0cmluZ1xyXG4gICAgICAgICAgICAvLyBUaGlzIGdldHMgcmlkIG9mIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwbGFjZXMgc2luY2UgYGdldGAgZG9lcyBub3QgcGFkIGRlY2ltYWxzXHJcbiAgICAgICAgICAgIHJldHVybiB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGJ1dCBmb2xsb3dpbmcgdGhlIGBvdXRwdXRGb3JtYXRgIHNldHRpbmcsIHdoaWNoIG1lYW5zIHRoZSBvdXRwdXQgY2FuIGVpdGhlciBiZSA6XHJcbiAgICAgICAgICogLSBhIHN0cmluZyAodGhhdCBjb3VsZCBvciBjb3VsZCBub3QgcmVwcmVzZW50IGEgbnVtYmVyIChpZS4gXCIxMjM0NSw2Ny1cIikpLCBvclxyXG4gICAgICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgcmV0dXJuZWQgdmFsdWVzIGFyZSBhbiBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cclxuICAgICAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRMb2NhbGl6ZWQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3Mub3V0cHV0Rm9ybWF0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIGlucHV0IHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgcmVhbCBKYXZhc2NyaXB0IG51bWJlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldE51bWJlcicpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXROdW1iZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRvTG9jYWxlKHZhbHVlLCAnbnVtYmVyJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZSBvZiB0aGUgYXV0b051bWVyaWMgZWxlbWVudC5cclxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEZvcm1hdHRlZCgpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGB0aGlzWzBdYCBleGlzdHMgYXMgd2VsbCBhcyBgLnZhbHVlYCBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGF0IHByb3BlcnR5XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnMCcpIHx8ICEoJ3ZhbHVlJyBpbiB0aGlzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcignVW5hYmxlIHRvIGdldCB0aGUgZm9ybWF0dGVkIHN0cmluZyBmcm9tIHRoZSBlbGVtZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXS52YWx1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgZGV0YWlsc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRTdHJpbmcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgZGV0YWlsc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3t9fFtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFycmF5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlICdnZXRTZXR0aW5ncycgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGN1cnJlbnQgYXV0b051bWVyaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTtcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuZGVjaW1hbENoYXJhY3RlcjsgLy8gUmV0dXJuIHRoZSBkZWNpbWFsQ2hhcmFjdGVyIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnkgdmFsaWQgb3B0aW9uIG5hbWUgY2FuIGJlIHVzZWRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBBZGQgYW4gb3B0aW9uIGFyZ3VtZW50IGBvcHRpb25OYW1lYCB0byB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgaXQgcmV0dXJuIG9ubHkgdGhlIHZhbHVlIG9mIHRoYXQgb3B0aW9uLCBub3QgdGhlIGVudGlyZSBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhdXRvTnVtZXJpYyBmdW5jdGlvbiBhY2NlcHRzIG1ldGhvZHMgbmFtZXMgKGluIHN0cmluZyBmb3JtYXQpIGFuZCB0aG9zZSBtZXRob2QgcGFyYW1ldGVycyBpZiBuZWVkZWQuXHJcbiAgICAgKiBJdCBpbml0aWFsaXplIGF1dG9OdW1lcmljIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lIChpZS4gJ3NldCcsICdnZXQnLCBldGMuKVxyXG4gICAgICogQHBhcmFtIHsqfSBhcmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJC5mbi5hdXRvTnVtZXJpYyA9IGZ1bmN0aW9uKG1ldGhvZCwgLi4uYXJncykge1xyXG4gICAgICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBvcHRpb25zIGhhdmUgYmVlbiBwYXNzZWQgZGlyZWN0bHksIHdpdGhvdXQgdXNpbmcgYSBuYW1lZCBtZXRob2RcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSh0aGlzLCBbbWV0aG9kXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvd0Vycm9yKGBNZXRob2QgXCIke21ldGhvZH1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGF1dG9OdW1lcmljIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiBkZWZhdWx0U2V0dGluZ3M7XHJcblxyXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IGRlZmF1bHRTZXR0aW5nczsgLy8gTWFrZSB0aG9zZSBzZXR0aW5ncyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYWxsIHRoZSBwcmVkZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMgaW4gb25lIG9iamVjdC5cclxuICAgICAqIFlvdSBjYW4gYWxzbyBhY2Nlc3MgYSBzcGVjaWZpYyBsYW5ndWFnZSBvYmplY3QgZGlyZWN0bHkgYnkgdXNpbmcgYGFuLmdldExhbmd1YWdlcygpLkZyZW5jaGAgZm9yIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGdldExhbmd1YWdlcyA9ICgpID0+IGxhbmd1YWdlT3B0aW9uO1xyXG5cclxuICAgICQuZm4uYXV0b051bWVyaWMubGFuZyA9IGxhbmd1YWdlT3B0aW9uOyAvLyBNYWtlIHRob3NlIHByZWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIEEgbnVtYmVyLCBvciBhIHN0cmluZyB0aGF0IHJlcHJlc2VudCBhIGphdmFzY3JpcHQgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucyA9IG51bGwpID0+IHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkgJiYgIWlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhdGUgYSB2ZXJ5IGJhc2ljIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1lcmljIHN0cmluZywgc3RyaXBwaW5nIHVubmVjZXNzYXJ5IGNoYXJhY3RlcnMgaW4gdGhlIHByb2Nlc3NcclxuICAgICAgICBsZXQgdmFsdWVTdHJpbmcgPSB0b051bWVyaWNWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZVN0cmluZykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlU3RyaW5nfV0gdGhhdCB5b3UgYXJlIHRyeWluZyB0byBmb3JtYXQgaXMgbm90IGEgcmVjb2duaXplZCBudW1iZXIuYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCYXNpYyB0ZXN0cyB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWVTdHJpbmcgaXMgdmFsaWRcclxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xyXG4gICAgICAgIGlmICghbWluVGVzdCB8fCAhbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBkb2N1bWVudCwgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZVN0cmluZ31dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIG9mIHRoZSBtaW5pbXVtVmFsdWUgWyR7c2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHtzZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXZlcnl0aGluZyBpcyBvaywgcHJvY2VlZCB0byByb3VuZGluZywgZm9ybWF0dGluZyBhbmQgZ3JvdXBpbmdcclxuICAgICAgICB2YWx1ZVN0cmluZyA9IHJvdW5kVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcclxuICAgICAgICB2YWx1ZVN0cmluZyA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xyXG4gICAgICAgIHZhbHVlU3RyaW5nID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZztcclxuICAgIH07XHJcblxyXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDsgLy8gVGhlIGpRdWVyeSBleHBvcnRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdpdmluZyBhbiB1bmZvcm1hdHRlZCB2YWx1ZSBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHVuZm9ybWF0dGVkIHZhbHVlLCB3aGF0ZXZlciB0aGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcclxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkgeyAvL1RPRE8gQ29tcGxldGUgdGhlIHRlc3QgdG8gdGhyb3cgd2hlbiBnaXZlbiBhIHdyb25nbHkgZm9ybWF0dGVkIG51bWJlciAoaWUuICdmb29iYXInKVxyXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYEEgbnVtYmVyIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIG51bWJlciBpcyBuZWVkZWQgdG8gYmUgYWJsZSB0byB1bmZvcm1hdCBpdCwgWyR7dmFsdWV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcclxuICAgICAgICBjb25zdCBhdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAvLyBUaGlzIGNoZWNrcyBpcyBhIG5lZ2F0aXZlIHNpZ24gaXMgYW55d2hlcmUgaW4gdGhlIGB2YWx1ZWAsIG5vdCBqdXN0IG9uIHRoZSB2ZXJ5IGZpcnN0IGNoYXJhY3RlciAoaWUuICcxMjM0NS42Ny0nKVxyXG4gICAgICAgIGlmIChpc05lZ2F0aXZlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAmJiBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5zcGxpdCgnLCcpWzBdID09PSB2YWx1ZS5jaGFyQXQoMCkpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoYXV0b1N0cmlwLCAnJyk7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XHJcbiAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3Mub3V0cHV0Rm9ybWF0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmF1dG9VbmZvcm1hdCA9IGF1dG9VbkZvcm1hdDsgLy8gVGhlIGpRdWVyeSBleHBvcnRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiBvcHRpb24gb2JqZWN0LlxyXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHRlc3RzIGlmIHRoZSBvcHRpb25zIGFyZSBub3QgY29uZmxpY3RpbmcgYW5kIGFyZSB3ZWxsIGZvcm1hdHRlZC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHVzZXJPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGV4dGVuZHMgdGhlIGB1c2VyT3B0aW9uc2AgcGFzc2VkIGJ5IHRoZSB1c2VyLCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlID0gKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUpID0+IHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHVzZXJPcHRpb25zKSB8fCAhaXNPYmplY3QodXNlck9wdGlvbnMpIHx8IGlzRW1wdHlPYmoodXNlck9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1c2VyT3B0aW9ucyBhcmUgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHZhbGlkIG9iamVjdCwgWyR7dXNlck9wdGlvbnN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHVzZWQgb2xkIG9wdGlvbnMsIHdlIGNvbnZlcnQgdGhlbSB0byBuZXcgb25lc1xyXG4gICAgICAgIGlmICghaXNOdWxsKHVzZXJPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyh1c2VyT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcclxuICAgICAgICBsZXQgb3B0aW9ucztcclxuICAgICAgICBpZiAoc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHVzZXJPcHRpb25zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gdXNlck9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3QsIHdlIHRlc3QgdGhhdCB0aGUgYHNob3dXYXJuaW5nc2Agb3B0aW9uIGlzIHZhbGlkXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdzaG93V2FybmluZ3MnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNob3dXYXJuaW5nc31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVmaW5lIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIG5lZWRlZCBmb3IgdGhlIGZvbGxvd2luZyB0ZXN0c1xyXG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUludGVnZXIgPSAvXlswLTldKyQvO1xyXG4gICAgICAgIGNvbnN0IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzID0gL1swLTldKy87XHJcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XHJcbiAgICAgICAgY29uc3QgdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspPyQvO1xyXG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyID0gL15bMC05XSsoXFwuP1swLTldKyk/JC87XHJcblxyXG4gICAgICAgIC8vIFRoZW4gdGVzdHMgdGhlIG9wdGlvbnMgaW5kaXZpZHVhbGx5XHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBbXHJcbiAgICAgICAgICAgICcsJywgICAgICAvLyBDb21tYVxyXG4gICAgICAgICAgICAnLicsICAgICAgLy8gRG90XHJcbiAgICAgICAgICAgICcgJywgICAgICAvLyBOb3JtYWwgc3BhY2VcclxuICAgICAgICAgICAgJ1xcdTIwMDknLCAvLyBUaGluLXNwYWNlXHJcbiAgICAgICAgICAgICdcXHUyMDJmJywgLy8gTmFycm93IG5vLWJyZWFrIHNwYWNlXHJcbiAgICAgICAgICAgICdcXHUwMGEwJywgLy8gTm8tYnJlYWsgc3BhY2VcclxuICAgICAgICAgICAgJycsICAgICAgIC8vIE5vIHNlcGFyYXRvclxyXG4gICAgICAgICAgICBcIidcIiwgICAgICAvLyBBcG9zdHJvcGhlXHJcbiAgICAgICAgICAgICfZrCcsICAgICAgLy8gQXJhYmljIHRob3VzYW5kcyBzZXBhcmF0b3JcclxuICAgICAgICAgICAgJ8uZJywgICAgICAvLyBEb3QgYWJvdmVcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RpZ2l0R3JvdXBTZXBhcmF0b3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJywnLCAnLicsICfZrCcsICfLmScsIFwiJ1wiLCAnICcsICdcXHUyMDA5JywgJ1xcdTIwMmYnLCAnXFx1MDBhMCcgb3IgZW1wdHkgKCcnKSwgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXMpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSAnbm9TZXBhcmF0b3JPbkZvY3VzJyBvcHRpb24gaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaWdpdGFsIGdyb3VwaW5nIGZvciB0aG91c2FuZCBzZXBhcmF0b3Igb3B0aW9uICdkaWdpdGFsR3JvdXBTcGFjaW5nJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIsIFtcclxuICAgICAgICAgICAgJywnLCAvLyBDb21tYVxyXG4gICAgICAgICAgICAnLicsIC8vIERvdFxyXG4gICAgICAgICAgICAnwrcnLCAvLyBNaWRkbGUtZG90XHJcbiAgICAgICAgICAgICfZqycsIC8vIEFyYWJpYyBkZWNpbWFsIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAn4o6WJywgLy8gRGVjaW1hbCBzZXBhcmF0b3Iga2V5IHN5bWJvbFxyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJywgJywnLCAnwrcnLCAn4o6WJyBvciAn2asnLCBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyID09PSBvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ2RlY2ltYWxDaGFyYWN0ZXInIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGFuZCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yICdkaWdpdEdyb3VwU2VwYXJhdG9yJyBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmICFpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFsdGVybmF0ZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgIWlzU3RyaW5nKG9wdGlvbnMuY3VycmVuY3lTeW1ib2wpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdjdXJyZW5jeVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCwgWydwJywgJ3MnXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgY3VycmVuY3kgc2lnbiBvcHRpb24gJ2N1cnJlbmN5U3ltYm9sUGxhY2VtZW50JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCkgb3IgJ3MnIChzdWZmaXgpLCBbJHtvcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LCBbJ3AnLCAncycsICdsJywgJ3InLCBudWxsXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiBvcHRpb24gJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSwgJ3InIChyaWdodCkgb3IgJ251bGwnLCBbJHtvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93UG9zaXRpdmVTaWduKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbikpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNob3cgcG9zaXRpdmUgc2lnbiBvcHRpb24gJ3Nob3dQb3NpdGl2ZVNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNob3dQb3NpdGl2ZVNpZ259XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCAob3B0aW9ucy5zdWZmaXhUZXh0ICE9PSAnJyAmJiAoaXNOZWdhdGl2ZShvcHRpb25zLnN1ZmZpeFRleHQpIHx8IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzLnRlc3Qob3B0aW9ucy5zdWZmaXhUZXh0KSkpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhZGRpdGlvbmFsIHN1ZmZpeCBvcHRpb24gJ3N1ZmZpeFRleHQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgbm90IGNvbnRhaW5zIHRoZSBuZWdhdGl2ZSBzaWduICctJyBub3IgYW55IG51bWVyaWNhbCBjaGFyYWN0ZXJzLCBbJHtvcHRpb25zLnN1ZmZpeFRleHR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMpICYmICFpc0luQXJyYXkob3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cywgWydjZWlsaW5nJywgJ2Zsb29yJywgJ2lnbm9yZSddKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgb3ZlcnJpZGUgbWluICYgbWF4IGxpbWl0cyBvcHRpb24gJ292ZXJyaWRlTWluTWF4TGltaXRzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnY2VpbGluZycsICdmbG9vcicgb3IgJ2lnbm9yZScsIFske29wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5tYXhpbXVtVmFsdWUpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21heGltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMubWluaW11bVZhbHVlKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLm1pbmltdW1WYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICdtaW5pbXVtVmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlRmxvYXQob3B0aW9ucy5taW5pbXVtVmFsdWUpID4gcGFyc2VGbG9hdChvcHRpb25zLm1heGltdW1WYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gOyAnbWluaW11bVZhbHVlJyBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghKGlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgfHxcclxuICAgICAgICAgICAgKGlzSW50KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiBvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA+PSAwKSB8fCAvLyBJZiBpbnRlZ2VyIG9wdGlvblxyXG4gICAgICAgICAgICAoaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIHRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpKSAgLy8gSWYgc3RyaW5nIG9wdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIG1pbmltdW1WYWx1ZS9tYXhpbXVtVmFsdWUgaXMgb3ZlcnJpZGRlbiBieSBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKGFuZCBub3QgaWYgZGVjaW1hbFBsYWNlc092ZXJyaWRlIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZGVjaW1hbCB1c2VkIGluIG1pbmltdW1WYWx1ZS9tYXhpbXVtVmFsdWUpXHJcbiAgICAgICAgY29uc3Qgdk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgob3B0aW9ucy5taW5pbXVtVmFsdWUsIG9wdGlvbnMubWF4aW11bVZhbHVlKTtcclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xyXG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHRvIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gd2lsbCBvdmVycmlkZSB0aGUgZGVjaW1hbHMgZGVjbGFyZWQgaW4gJ21pbmltdW1WYWx1ZScgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBhbmQgJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZyAmJiAhaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xyXG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdhbGxvd0RlY2ltYWxQYWRkaW5nJyB0byBbZmFsc2VdIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dLmAsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgJiYgKCFpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBleHBhbmRlZCBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGVcIlxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgJiYgIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSA+IE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcoYFRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzfV0gc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSB2YWx1ZS4gQ3VycmVudGx5LCB0aGlzIHdpbGwgbGltaXQgdGhlIGFiaWxpdHkgb2YgeW91ciBjbGllbnQgdG8gbWFudWFsbHkgY2hhbmdlIHNvbWUgb2YgdGhlIGRlY2ltYWwgcGxhY2VzLiBEbyB5b3UgcmVhbGx5IHdhbnQgdG8gZG8gdGhhdD9gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGl2aXNvcikgJiYgIXRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURpdmlzb3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBkaXZpc29yIG9wdGlvbiAnc2NhbGVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEaXZpc29yfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykgJiYgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIG51bWJlciBvZiBkZWNpbWFscyBvcHRpb24gJ3NjYWxlRGVjaW1hbFBsYWNlcycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEZWNpbWFsUGxhY2VzfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlU3ltYm9sKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5zY2FsZVN5bWJvbCkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIHN5bWJvbCBvcHRpb24gJ3NjYWxlU3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLnNjYWxlU3ltYm9sfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNhdmUgdG8gc2Vzc2lvbiBzdG9yYWdlIG9wdGlvbiAnc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5vbkludmFsaWRQYXN0ZSwgW1xyXG4gICAgICAgICAgICAnZXJyb3InLFxyXG4gICAgICAgICAgICAnaWdub3JlJyxcclxuICAgICAgICAgICAgJ2NsYW1wJyxcclxuICAgICAgICAgICAgJ3RydW5jYXRlJyxcclxuICAgICAgICAgICAgJ3JlcGxhY2UnLFxyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZSBiZWhhdmlvciBvcHRpb24gJ29uSW52YWxpZFBhc3RlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnZXJyb3InLCAnaWdub3JlJywgJ2NsYW1wJywgJ3RydW5jYXRlJyBvciAncmVwbGFjZScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5vbkludmFsaWRQYXN0ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5yb3VuZGluZ01ldGhvZCwgW1xyXG4gICAgICAgICAgICAnUycsXHJcbiAgICAgICAgICAgICdBJyxcclxuICAgICAgICAgICAgJ3MnLFxyXG4gICAgICAgICAgICAnYScsXHJcbiAgICAgICAgICAgICdCJyxcclxuICAgICAgICAgICAgJ1UnLFxyXG4gICAgICAgICAgICAnRCcsXHJcbiAgICAgICAgICAgICdDJyxcclxuICAgICAgICAgICAgJ0YnLFxyXG4gICAgICAgICAgICAnTjA1JyxcclxuICAgICAgICAgICAgJ0NIRicsXHJcbiAgICAgICAgICAgICdVMDUnLFxyXG4gICAgICAgICAgICAnRDA1JyxcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAncm91bmRpbmdNZXRob2QnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdTJywgJ0EnLCAncycsICdhJywgJ0InLCAnVScsICdEJywgJ0MnLCAnRicsICdOMDUnLCAnQ0hGJywgJ1UwNScgb3IgJ0QwNScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5yb3VuZGluZ01ldGhvZH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZykgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FsbG93RGVjaW1hbFBhZGRpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmd9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNlbGVjdEFsbE9uRm9jdXNJZlplcm8pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zZWxlY3RBbGxPbkZvY3VzSWZaZXJvKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgb3B0aW9uICdzZWxlY3RBbGxPbkZvY3VzSWZaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zZWxlY3RBbGxPbkZvY3VzSWZaZXJvfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIsIFsnKCwpJywgJ1ssXScsICc8LD4nLCAneyx9J10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBicmFja2V0cyBmb3IgbmVnYXRpdmUgdmFsdWVzIG9wdGlvbiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICcoLCknLCAnWyxdJywgJzwsPicgb3IgJ3ssfScsIFske29wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXJ9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2VtcHR5SW5wdXRCZWhhdmlvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycgb3IgJ3plcm8nLCBbJHtvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5sZWFkaW5nWmVybywgWydhbGxvdycsICdkZW55JywgJ2tlZXAnXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xlYWRpbmdaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxlYWRpbmdaZXJvfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGZvcm1hdCBvbiBpbml0aWFsaXphdGlvbiBvcHRpb24gJ2Zvcm1hdE9uUGFnZUxvYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5KSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc2VsZWN0TnVtYmVyT25seScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0TnVtYmVyT25seX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkgJiYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09ICcnICYmICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2RlZmF1bHRWYWx1ZU92ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByZW1vdmUgZm9ybWF0dGluZyBvbiBzdWJtaXQgb3B0aW9uICd1bmZvcm1hdE9uU3VibWl0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51bmZvcm1hdE9uU3VibWl0fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm91dHB1dEZvcm1hdCkgJiYgIWlzSW5BcnJheShvcHRpb25zLm91dHB1dEZvcm1hdCwgW1xyXG4gICAgICAgICAgICAnc3RyaW5nJyxcclxuICAgICAgICAgICAgJ251bWJlcicsXHJcbiAgICAgICAgICAgICcuJyxcclxuICAgICAgICAgICAgJy0uJyxcclxuICAgICAgICAgICAgJywnLFxyXG4gICAgICAgICAgICAnLSwnLFxyXG4gICAgICAgICAgICAnLi0nLFxyXG4gICAgICAgICAgICAnLC0nLFxyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dEZvcm1hdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgbnVsbCwgJ3N0cmluZycsICdudW1iZXInLCAnLicsICctLicsICcsJywgJy0sJywgJy4tJyBvciAnLC0nLCBbJHtvcHRpb25zLm91dHB1dEZvcm1hdH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ2ZhaWxPblVua25vd25PcHRpb24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmZhaWxPblVua25vd25PcHRpb259XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICQuZm4uYXV0b1ZhbGlkYXRlID0gdmFsaWRhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZSBhbiBhcmFiaWMgbnVtYmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gYSBqYXZhc2NyaXB0IG51bWJlci5cclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdHJ5IHRvIGNvbnZlcnQgdGhlIGFyYWJpYyBkZWNpbWFsIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVycy5cclxuICAgICAqIFRoaXMgcmV0dXJucyBgTmFOYCBpcyB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXHJcbiAgICAgKiBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzAyNTM5Mi8yODM0ODk4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyYWJpY051bWJlcnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuQU51bWJlciBJZiBgdHJ1ZWAsIHJldHVybiBhIE51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBhIFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZURlY2ltYWxDaGFyYWN0ZXJcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2VUaG91c2FuZFNlcGFyYXRvclxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ8TmFOfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcmFiaWNUb0xhdGluTnVtYmVycyhhcmFiaWNOdW1iZXJzLCByZXR1cm5BTnVtYmVyID0gdHJ1ZSwgcGFyc2VEZWNpbWFsQ2hhcmFjdGVyID0gZmFsc2UsIHBhcnNlVGhvdXNhbmRTZXBhcmF0b3IgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBhcmFiaWNOdW1iZXJzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gJycgfHwgcmVzdWx0Lm1hdGNoKC9b2aDZodmi2aPZpNml2abZp9mo2anbtNu127ZdL2cpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIEFyYWJpYy9QZXJzaWFuIG51bWJlcnMgYXJlIGZvdW5kLCByZXR1cm4gdGhlIG51bWVyaWMgc3RyaW5nIGRpcmVjdGx5XHJcbiAgICAgICAgICAgIHJldHVybiBhcmFiaWNOdW1iZXJzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlRGVjaW1hbENoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgv2asvLCAnLicpOyAvLyBEZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlVGhvdXNhbmRTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL9msL2csICcnKTsgLy8gVGhvdXNhbmQgc2VwYXJhdG9yXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBudW1iZXJzIG9ubHlcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW9mg2aHZotmj2aTZpdmm2afZqNmpXS9nLCBkID0+IGQuY2hhckNvZGVBdCgwKSAtIDE2MzIpIC8vIEFyYWJpYyBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1vbsNux27Lbs9u027Xbttu327jbuV0vZywgZCA9PiBkLmNoYXJDb2RlQXQoMCkgLSAxNzc2KTsgLy8gUGVyc2lhbiBudW1iZXJzXHJcblxyXG4gICAgICAgIC8vIGBOYU5gIGhhcyBwcmVjZWRlbmNlIG92ZXIgdGhlIHN0cmluZyBgJ05hTidgXHJcbiAgICAgICAgY29uc3QgcmVzdWx0QXNOdW1iZXIgPSBOdW1iZXIocmVzdWx0KTtcclxuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0QXNOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRBc051bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXR1cm5BTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdEFzTnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICogQnkgZGVmYXVsdCwgaWYgbm8gZWxlbWVudCBpcyBnaXZlbiwgdGhlIGV2ZW50IGlzIHRocm93biBmcm9tIGBkb2N1bWVudGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGVsZW1lbnQgPSBkb2N1bWVudCwgZGV0YWlsID0gbnVsbCkge1xyXG4gICAgICAgIGxldCBldmVudDtcclxuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIHsgZGV0YWlsIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXHJcbiAgICAgKi9cclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB2b2lkKDApIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcclxuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgJC5leHRlbmQodHJ1ZSwgZGVmYXVsdFNldHRpbmdzLCAkLmZuLmF1dG9OdW1lcmljLmxhbmcuVHVya2lzaCwgeyBjdXJyZW5jeVN5bWJvbDogJycgfSk7XHJcblxyXG4gICAgLy8gSGlqYWNrIHRoZSBvcmlnaW5hbCB2YWwgZm4gaW4gb3JkZXIgdG9cclxuICAgIC8vIHVzZSAkYXV0b051bWVyaWMudmFsKCkgYW5kIGJlIGFibGUgdG8gZ2V0L3NldFxyXG4gICAgLy8gdGhlIHVubWFza2VkIHZhbHVlLlxyXG4gICAgJC5mbi52YWwgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICBjb25zdCAkbWUgPSAkKG1lKTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhbiBpbnN0YW5jZSBvZiBhdXRvTnVtZXJpYyxcclxuICAgICAgICAvLyBzaW1wbHkgY2FsbCB0aGUgb3JpZ2luYWwgalF1ZXJ5LmZuLnZhbFxyXG4gICAgICAgIGlmICgkbWUuZGF0YSgnYXV0b051bWVyaWMnKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlPcmlnaW5hbFZhbC5hcHBseShtZSwgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBXZSdyZSB0cnlpbmcgdG8gcmVhZCB0aGUgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICAgICAgICByZXR1cm4gJG1lLmF1dG9OdW1lcmljKCdnZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIFdlJ3JlIHRyeWluZyB0byBzZXQgYSB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFZhbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBsZXQgbnVtZXJpY1ZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpLnJlcGxhY2UoJywnLCAnLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG51bWVyaWNWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBcIiR7b3JpZ2luYWxWYWx9XCIgaXMgbm90IGEgbnVtYmVyLmA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYFRoZSB0eXBlIFwiJHt0eXBlb2YgdmFsdWV9XCIgaXMgbm90IHN1cHBvcnRlZC5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbnVtZXJpY1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAkbWUuYXV0b051bWVyaWMoJ3NldCcsIG51bWVyaWNWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcclxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXHJcbiAgICBnZXREZWZhdWx0Q29uZmlnLFxyXG4gICAgZ2V0TGFuZ3VhZ2VzLFxyXG4gICAgdmFsaWRhdGUsIC8vIGFuLnZhbGlkYXRlKG9wdGlvbnMpIDogdGhyb3dzIGlmIG5lY2Vzc2FyeVxyXG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy8gYW4uYXJlU2V0dGluZ3NWYWxpZChvcHRpb25zKSA6IHJldHVybiB0cnVlIG9yIGZhbHNlIC8vVE9ETyBJcyB0aGlzIHJlZHVuZGFudD8gU2hvdWxkIHdlIGxldCB0aGUgZGV2ZWxvcGVycyB3cmFwIGVhY2ggYXV0b051bWVyaWMudmFsaWRhdGUoKSBjYWxscyBpbiB0cnkvY2F0Y2ggYmxvY2s/IE9yIHNob3VsZCB3ZSBqdXN0IGZhY2lsaXRhdGUgdGhlaXIgbGlmZSBieSBkb2luZyBpdCBhbHJlYWR5P1xyXG5cclxuICAgIC8vVE9ETyBDb21wbGV0ZSB0aGUgaW50ZXJmYWNlIHdpdGggZnVuY3Rpb25zIGhhdmluZyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgOlxyXG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxyXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXHJcbiAgICAvL3NldCAgICAgICAgICA6IGFuLnNldCh2YWx1ZSwgaW5wdXQpXHJcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcclxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXHJcbiAgICAvL2dldEZvcm1hdHRlZCA6IGFuLmdldEZvcm1hdHRlZChpbnB1dClcclxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxyXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxyXG4gICAgLy9zZXR0aW5ncyAgICAgOiBhbi5zZXR0aW5ncyhpbnB1dClcclxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxyXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxyXG4gICAgLy9kZXN0cm95ICAgICAgOiBhbi5kZXN0cm95KGlucHV0KVxyXG5cclxuICAgIC8vcmF3ICAgICAgICAgIDogYW4ucmF3KGlucHV0KSAvLyBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nXHJcbiAgICAvL251bWJlciAgICAgICA6IGFuLm51bWJlcihpbnB1dCkgLy8gUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIG51bWJlciAoV2FybmluZzogVGhpcyBjYW4gbGVhZCB0byBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBiaWcgbnVtYmVycylcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;