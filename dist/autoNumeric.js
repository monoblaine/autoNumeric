(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n *               autoNumeric.js\r\n *\r\n * @version      2.0.12\r\n * @date         2017-04-07 UTC 07:00\r\n *\r\n * @author       Bob Knothe\r\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n *               cf. AUTHORS.md.\r\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n * @since        2009-08-09\r\n *\r\n * @summary      autoNumeric is a library that provides live as-you-type\r\n *               formatting for international numbers and currencies.\r\n *\r\n *               Note : Some functions are borrowed from big.js\r\n * @link         https://github.com/MikeMcl/big.js/\r\n *\r\n * Please report any bugs to https://github.com/autoNumeric/autoNumeric\r\n *\r\n * @license      Released under the MIT License\r\n * @link         http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\n\n/* global module, require, define */\n\nvar jQueryOriginalVal = jQuery.fn.val;\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar getLanguages = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\r\n * List of allowed tag on which autoNumeric can be used.\r\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\r\n * Defaults options are public - these can be overridden by the following method:\r\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" €\">`)\r\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' €' });`)\r\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n */\nvar defaultSettings = {\n    /* Allowed thousand grouping separator characters :\r\n     * ','      // Comma\r\n     * '.'      // Dot\r\n     * ' '      // Normal space\r\n     * '\\u2009' // Thin-space\r\n     * '\\u202f' // Narrow no-break space\r\n     * '\\u00a0' // No-break space\r\n     * ''       // No separator\r\n     * \"'\"      // Apostrophe\r\n     * '٬'      // Arabic thousands separator\r\n     * '˙'      // Dot above\r\n     * Deprecated older option name : aSep\r\n     */\n    digitGroupSeparator: ',',\n\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n     * example if the input value \"$ 1,999.88 suffix\"\r\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n     * Deprecated older option name : nSep\r\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\r\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n     * Deprecated older option name : dGroup\r\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters :\r\n     * ',' : Comma\r\n     * '.' : Dot\r\n     * '·' : Middle-dot\r\n     * '٫' : Arabic decimal separator\r\n     * '⎖' : Decimal separator key symbol\r\n     * Deprecated older option name : aDec\r\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n     * Deprecated older option name : altDec\r\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\r\n     * Must be in quotes currencySymbol: \"$\"\r\n     * space to the right of the currency symbol currencySymbol: '$ '\r\n     * space to the left of the currency symbol currencySymbol: ' $'\r\n     * Deprecated older option name : aSign\r\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n     * for prefix currencySymbolPlacement: \"p\" (default)\r\n     * for suffix currencySymbolPlacement: \"s\"\r\n     * Deprecated older option name : pSign\r\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n     * -1,234.56  => default no options required\r\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n     * Deprecated older option name : pNeg\r\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    negativePositiveSignPlacement: null,\n\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n     * By default, this positive sign is not shown.\r\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n     */\n    showPositiveSign: false,\n\n    /* Additional suffix\r\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n     * Numeric characters and negative sign not allowed'\r\n     * Deprecated older option name : aSuffix\r\n     */\n    suffixText: '',\n\n    /* Override min max limits\r\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n     * Deprecated older option name : oLimits\r\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be larger than minimumValue\r\n     * Deprecated older option name : vMax\r\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be smaller than maximumValue\r\n     * Deprecated older option name : vMin\r\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n     * Deprecated older option name : mDec\r\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\r\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n     * the \"get\" method returns the extended decimal places\r\n     * Deprecated older option name : eDec\r\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n     */\n    scaleDivisor: null,\n\n    /*\r\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n     * Deprecated older option name : scaleDecimal\r\n     */\n    scaleDecimalPlaces: null,\n\n    /*\r\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n     * This is optional too.\r\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n     * if ie 6 or 7 the value will be saved as a session cookie\r\n     * Deprecated older option name : aStor\r\n     */\n    saveValueToSessionStorage: false,\n\n    /*\r\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n     *                The non-pasted numbers are dropped and therefore not used at all.\r\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n     *\r\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n     *          Only the first number will be used (here '123').\r\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\r\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n     * roundingMethod: \"U05\" Rounds up to next .05\r\n     * roundingMethod: \"D05\" Rounds down to next .05\r\n     * Deprecated older option name : mRound\r\n     */\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\n    roundingMethod: 'S',\n\n    /* Allow padding the decimal places with zeros\r\n     * allowDecimalPadding: true - always Pad decimals with zeros\r\n     * allowDecimalPadding: false - does not pad with zeros.\r\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n     *\r\n     * thanks to Jonas Johansson for the suggestion\r\n     * Deprecated older option name : aPad\r\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n     * Those brackets are visible only when the field does NOT have the focus.\r\n     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n     * This option can be of the following values :\r\n     * null, // This is the default value, which deactivate this feature\r\n     * '(,)',\r\n     * '[,]',\r\n     * '<,>' or\r\n     * '{,}'\r\n     * Deprecated older option name : nBracket\r\n     */\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\r\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n     * Deprecated older option name : wEmpty\r\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\r\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n     * Deprecated older option name : lZero\r\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\r\n     * true = automatically formats the default value on initialization\r\n     * false = will not format the default value on initialization\r\n     * Deprecated older option name : aForm\r\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n     * Deprecated older option name : sNumber\r\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\r\n     * should be the value of the unformatted default value\r\n     * examples:\r\n     * no default value=\"\" {defaultValueOverride: \"\"}\r\n     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n     * Deprecated older option name : anDefault\r\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\r\n     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n     * review the 'unSet' method for other formats\r\n     * Deprecated older option name : unSetOnSubmit\r\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n     * Deprecated older option name : outputType\r\n     */\n    outputFormat: null,\n\n    /* Defines if warnings should be shown\r\n     * Error handling function\r\n     * true => all warning are shown\r\n     * false => no warnings are shown, only the thrown errors\r\n     * Deprecated older option name : debug\r\n     */\n    showWarnings: true,\n\n    /*\r\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n     */\n    failOnUnknownOption: false\n};\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n * //TODO Replace every call to this object with a call to `keyName`\r\n * @deprecated\r\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224,\n    AndroidDefault: 229 };\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n * Those names are listed here :\r\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n */\nvar keyName = {\n    // Special values\n    Unidentified: 'Unidentified',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta', // The Windows, Command or ⌘ key // 'OS' under Firefox and IE9\n    Windows: 'Meta', // This is a non-official key name\n    Command: 'Meta', // This is a non-official key name\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageDown: 'PageDown',\n    PageUp: 'PageUp',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    MultiplyNumpad: '*',\n    PlusNumpad: '+',\n    MinusNumpad: '-',\n    DotNumpad: '.',\n    SlashNumpad: '/',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\",\n    NumpadDot: '.',\n    NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n    NumpadMultiply: '*',\n    NumpadPlus: '+',\n    NumpadMinus: '-',\n    NumpadSlash: '/',\n    NumpadDotObsoleteBrowsers: 'Decimal',\n    NumpadMultiplyObsoleteBrowsers: 'Multiply',\n    NumpadPlusObsoleteBrowsers: 'Add',\n    NumpadMinusObsoleteBrowsers: 'Subtract',\n    NumpadSlashObsoleteBrowsers: 'Divide'\n};\n\nvar defaultMinimumValue = '-999999999999.99';\nvar defaultMaximumValue = '999999999999.99';\nvar defaultRoundingMethod = 'U';\nvar defaultLeadingZero = 'deny';\nvar defaultSelectNumberOnly = true;\n\n/**\r\n * Predefined options for the most common languages\r\n */\nvar languageOption = {\n    French: { // Français\n        digitGroupSeparator: '.', // or '\\u202f'\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: '\\u202F\\u20AC',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    NorthAmerican: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '$',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    British: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '£',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Swiss: { // Suisse\n        digitGroupSeparator: '\\'',\n        decimalCharacter: '.',\n        currencySymbol: '\\u202FCHF',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Japanese: { // 日本語\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '¥',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Turkish: {\n        digitGroupSeparator: '.',\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: ' ₺',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue,\n        negativePositiveSignPlacement: 'p'\n    }\n};\nlanguageOption.Spanish = languageOption.French; // Español (idem French)\nlanguageOption.Chinese = languageOption.Japanese; // 中国語 (Chinese)\n\n/**\r\n * UMD structure\r\n */\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\r\n     * Return TRUE if the `value` is null\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\r\n     * Return TRUE if the given parameter is a String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a boolean\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string 'true' or 'false'\r\n     *\r\n     * This function accepts any cases for those strings.\r\n     * @param {string} value\r\n     * @returns {boolean}\r\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an object\r\n     *\r\n     * @param {*} reference\r\n     * @returns {boolean}\r\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\r\n     * Return TRUE if the given object is empty\r\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n     *\r\n     * @param {object} obj\r\n     * @returns {boolean}\r\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a number (or a number written as a string).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an integer (and not a float).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\r\n     * Return the pasted text that will be used.\r\n     *\r\n     * @param {string} text\r\n     * @param {AutoNumericHolder} holder\r\n     * @returns {string|void|XML|*}\r\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {*} needle\r\n     * @param {Array} array\r\n     * @returns {boolean}\r\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n     *\r\n     * @param {string} str\r\n     * @returns {boolean}\r\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\r\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n     *\r\n     * @param {string} str\r\n     * @returns {int}\r\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\r\n     * Return the code for the key used to generate the given event.\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string|Number}\r\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\r\n     * Return the character from the event key code.\r\n     * @example character(50) => '2'\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string}\r\n     */\n    function character(event) {\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n            return String.fromCharCode(keyCodeNumber(event));\n        } else {\n            // Special case for obsolete browsers like IE that return the old names\n            var result = void 0;\n            switch (event.key) {\n                case 'Decimal':\n                    result = keyName.NumpadDot;\n                    break;\n                case 'Multiply':\n                    result = keyName.NumpadMultiply;\n                    break;\n                case 'Add':\n                    result = keyName.NumpadPlus;\n                    break;\n                case 'Subtract':\n                    result = keyName.NumpadMinus;\n                    break;\n                case 'Divide':\n                    result = keyName.NumpadSlash;\n                    break;\n                case 'Del':\n                    // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401 //FIXME à terminer\n                    result = keyName.Dot; // as of version 2.0.8 the character() function is only called on keypress event. The 'Del' does not throw the keypress event.\n                    break;\n                default:\n                    result = event.key;\n            }\n\n            return result;\n        }\n    }\n\n    /**\r\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n     * @returns {boolean}\r\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\r\n     * Return TRUE if the given string contains a negative sign :\r\n     * - everywhere in the string (by default), or\r\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n     *\r\n     * @param {string} numericString A number represented by a string\r\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n     * @returns {boolean}\r\n     */\n    function isNegative(numericString) {\n        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        //TODO Use the `negativeSignCharacter` from the settings here\n        if (checkEverywhere) {\n            return contains(numericString, '-');\n        }\n\n        return isNegativeStrict(numericString);\n    }\n\n    /**\r\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n     *\r\n     * @example isNegativeStrict('1234.56')     => false\r\n     * @example isNegativeStrict('1234.56-')    => false\r\n     * @example isNegativeStrict('-1234.56')    => true\r\n     * @example isNegativeStrict('-1,234.56 €') => true\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\n    function isNegativeStrict(numericString) {\n        //TODO Using the `negativeSignCharacter` from the settings here\n        return numericString.charAt(0) === '-';\n    }\n\n    /**\r\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 €'), or is empty (' €').\r\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\n    function isZeroOrHasNoValue(numericString) {\n        return !/[1-9]/g.test(numericString);\n    }\n\n    /**\r\n     * Return the negative version of the value (represented as a string) given as a parameter.\r\n     *\r\n     * @param {string} value\r\n     * @returns {*}\r\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegativeStrict(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\r\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n     *\r\n     * @param {string} string\r\n     * @param {int} index\r\n     * @param {string} newCharacter\r\n     * @returns {string}\r\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\r\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} settings\r\n     * @returns {number}\r\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\r\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n     *\r\n     * @param {string} formattedNumberString\r\n     * @param {int} caretPosition This must be a positive integer\r\n     * @param {string} decimalCharacter\r\n     * @returns {number}\r\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\r\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n     *\r\n     * @example\r\n     * 1234567|89.01   : position 7 (rawNumberString)\r\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n     *\r\n     * @param {string} rawNumberString\r\n     * @param {int} caretPositionInRawValue\r\n     * @param {string} formattedNumberString\r\n     * @param {string} decimalCharacter\r\n     * @returns {*}\r\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\r\n     * Count the number of occurrence of the given character, in the given text.\r\n     *\r\n     * @param {string} character\r\n     * @param {string} text\r\n     * @returns {number}\r\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\r\n     * Return the index that can be used to set the caret position.\r\n     * This takes into account that the position is starting at '0', not 1.\r\n     *\r\n     * @param {int} characterCount\r\n     * @returns {number}\r\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @returns {{}}\r\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @param {int} start\r\n     * @param {int|null} end\r\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\r\n     * Function that throw error messages\r\n     *\r\n     * @param {string} message\r\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\r\n     * Function that display a warning messages, according to the debug level.\r\n     *\r\n     * @param {string} message\r\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\r\n     * Run any callbacks found in the settings object.\r\n     * Any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\r\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n     *\r\n     * @param {string} minimumValue\r\n     * @param {string} maximumValue\r\n     * @returns {number}\r\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\r\n     * Strip all unwanted non-number characters.\r\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} leftOrAll\r\n     * @returns {string|*}\r\n     */\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n        //TODO Refactor this with `convertToNumericString()` if possible?\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Sets or removes brackets on negative values, depending on the focus state.\r\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n     * //TODO Use another object to keep track of internal data that are not settings\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            //TODO Split the first and last bracket only once during the settings initialization\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.hasFocus) {\n                // Add brackets\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n                // Remove brackets\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n     *\r\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n     * Lastly, it also put the negative sign back to its normal position if needed.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string|void|XML|*}\r\n     */\n    function convertToNumericString(s, settings) {\n        // Remove the currency symbol\n        s = s.replace(settings.currencySymbol, '');\n\n        // Remove the grouping separators (thousands separators usually)\n        s = s.replace(settings.digitGroupSeparator, '');\n\n        // Replace the decimal character by a dot\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n\n        // Move the trailing negative sign to the right position, if any\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        // Convert any arabic numbers to latin ones\n        var temp = arabicToLatinNumbers(s, true, false, false);\n        if (!isNaN(temp)) {\n            s = temp.toString();\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n     * See the \"outputFormat\" option definition for more details.\r\n     *\r\n     * @param {string|null} value\r\n     * @param {string} locale\r\n     * @returns {*}\r\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is not formatted with decimals\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Private function to check for empty value\r\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @param {boolean} signOnEmpty\r\n     * @returns {*}\r\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Modify the input value by adding the group separators, as defined in the settings.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n        if (settings.trailingNegative && !isNegative(inputValue)) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isValueNegative = isNegative(inputValue);\n        var isZero = isZeroOrHasNoValue(inputValue);\n        if (isValueNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        settings.trailingNegative = false;\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\r\n     * Truncate not needed zeros\r\n     *\r\n     * @param {string} roundedInputValue\r\n     * @param {int} temporaryDecimalPlacesOverride\r\n     * @returns {void|XML|string|*}\r\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\r\n     * Round the input value using the rounding method defined in the settings.\r\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n     *\r\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (isNegativeStrict(inputValue)) {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\r\n     * Truncates the decimal part of a number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} isPaste\r\n     * @returns {*}\r\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {number|string} n A numeric value.\r\n     * @returns {{}}\r\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (isNegativeStrict(n)) {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings.\r\n     * This uses the parsed strings for the above parseStr function.\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {object} y Big number instance\r\n     * @param {object} x Big number instance\r\n     * @returns {*}\r\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Check that the number satisfy the format conditions\r\n     * and lays between settings.minimumValue and settings.maximumValue\r\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Thanks to Anthony & Evan C\r\n     *\r\n     * @param {Element|string} element\r\n     * @returns {*|jQuery|HTMLElement}\r\n     */\n    function getCurrentElement(element) {\n        /*\r\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n         * for jQuery to be able to parse the selector correctly.\r\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\r\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     * @param {boolean} update\r\n     * @returns {*}\r\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\r\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\r\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n     * This is taken from Quirksmode.\r\n     *\r\n     * @param {string} name\r\n     * @returns {*}\r\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Test if sessionStorage is supported.\r\n     * This is taken from Modernizr.\r\n     *\r\n     * @returns {boolean}\r\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\r\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\n    function cleanLeadingTrailingZeros(value, settings) {\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n        if (value === '') {\n            return '';\n        }\n\n        // Return '0' if the value is zero\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n            return '0';\n        }\n\n        if (settings.leadingZero !== 'keep') {\n            // Trim leading zero's - leaves one zero to the left of the decimal point\n            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n            if (contains(value, '.')) {\n                // Trims trailing zeros after the decimal point\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n        }\n        // Strips trailing decimal point\n        value = value.replace(/\\.$/, '');\n\n        return value;\n    }\n\n    /**\r\n     * Remove the trailing zeros in the decimal part of a number.\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {*}\r\n     */\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\n        var _numericString$split = numericString.split('.'),\n            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n            integerPart = _numericString$split2[0],\n            decimalPart = _numericString$split2[1];\n\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n            return integerPart;\n        }\n\n        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n        var result = void 0;\n        if (trimmedDecimalPart === '') {\n            result = integerPart;\n        } else {\n            result = integerPart + '.' + trimmedDecimalPart;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n     *\r\n     * @param {Element|EventTarget} element\r\n     * @param {object} settings\r\n     * @param {string} action\r\n     * @returns {*}\r\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Holder object for field properties\r\n     */\n\n    var AutoNumericHolder = function () {\n        /**\r\n         * Class constructor\r\n         *\r\n         * @param {HTMLElement} that - A reference to the current DOM element\r\n         * @param {object} settings\r\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\r\n         * Update the value and the selection values inside the AutoNumericHolder object.\r\n         * This keeps tracks of the input value, as well as the current selection.\r\n         * This also resets the 'processed' and 'formatted' state.\r\n         *\r\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n         *        this function is called on each event handler.\r\n         *\r\n         * @private\r\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateAutoNumericHolderProperties',\n            value: function _updateAutoNumericHolderProperties() {\n                this.value = this.that.value;\n                this.selection = getElementSelection(this.that);\n                this.processed = false;\n                this.formatted = false;\n            }\n\n            /**\r\n             * Update the keycode of the key that triggered the given event.\r\n             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n             *\r\n             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n             * e.key describe the key name used to trigger the event.\r\n             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n             * The key list is described here\r\n             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n             *\r\n             * @param {Event} e\r\n             * @private\r\n             */\n\n        }, {\n            key: '_updateAutoNumericHolderEventKeycode',\n            value: function _updateAutoNumericHolderEventKeycode(e) {\n                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n                this.eventKeyCode = keyCodeNumber(e);\n            }\n\n            /**\r\n             * Set the text selection inside the input with the given start and end position.\r\n             *\r\n             * @param {int} start\r\n             * @param {int} end\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\r\n             * Set the caret position inside the input at the given position.\r\n             *\r\n             * @param {int} pos\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\r\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n             *\r\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\r\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n             * Those parts are unformatted (stripped) of any non-numbers characters.\r\n             *\r\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                if (left === '' && right === '') {\n                    settingsClone.trailingNegative = false;\n                }\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                    settingsClone.trailingNegative = false;\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Strip parts from excess characters and leading zeros.\r\n             *\r\n             * @param {string} left\r\n             * @param {string} right\r\n             * @returns {[*,*]}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n             *\r\n             * @param {string} left\r\n             * @param {string} right\r\n             * @param {boolean} isPaste\r\n             * @returns {boolean}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n                    } else {\n                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\r\n             * Helper function for `_expandSelectionOnSign()`.\r\n             *\r\n             * @returns {*} Sign position of a formatted value\r\n             * @private\r\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\r\n             * Expands selection to cover whole sign\r\n             * Prevents partial deletion/copying/overwriting of a sign\r\n             *\r\n             * @param {undefined|boolean} setReal\r\n             * @private\r\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\r\n             * Try to strip pasted value to digits\r\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // Try to strip the pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\r\n             * Process pasting, cursor moving and skipping of not interesting keys.\r\n             * If this function returns TRUE, then further processing is not performed.\r\n             *\r\n             * @param {Event} e\r\n             * @returns {boolean}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n                    //TODO Move this test inside the `onKeyup` handler\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !isNegative(this.that.value) ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // Try to prevent wrong paste\n                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n                }\n\n                if (e.ctrlKey || e.metaKey) {\n                    return true;\n                }\n\n                // Jump over thousand separator\n                //TODO Move this test inside the `onKeydown` handler\n                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                    if (e.type === 'keydown' && !e.shiftKey) {\n                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start - 1);\n                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n            }\n\n            /**\r\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n             *\r\n             * @param {string} left The part on the left of the caret or selection\r\n             * @param {string} right The part on the right of the caret or selection\r\n             * @returns {[string, string]}\r\n             * @private\r\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\r\n             * Process the deletion of characters.\r\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.eventKeyCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\r\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n             * Returns TRUE if the keycode is allowed.\r\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n             *\r\n             * @param {Event|string} eventOrChar The event object, or the character entered (from an android device)\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion(eventOrChar) {\n                var settingsClone = this.settingsClone;\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                var eventCharacter = void 0;\n                if (isString(eventOrChar)) {\n                    // Android browsers\n                    eventCharacter = eventOrChar;\n                } else {\n                    // Normal browsers\n                    settingsClone.throwInput = true;\n\n                    // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n                    eventCharacter = character(eventOrChar);\n                }\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If the user tries to insert digit before minus sign\n                var eventNumber = Number(eventCharacter);\n                if (eventNumber >= 0 && eventNumber <= 9) {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + eventCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\r\n             * Formatting of just processed value while keeping the cursor position\r\n             *\r\n             * @param {Event} e\r\n             * @private\r\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (isNegative(subParts)) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (_this.eventKeyCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If the positive sign is shown, calculate the caret position accordingly\n                        if (settingsClone.showPositiveSign) {\n                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n                            }\n\n                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n                                position = settingsClone.currencySymbol.length + 1;\n                            }\n                        }\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                if (settingsClone.androidSelectionStart !== null) {\n                    // If an Android browser is detected, fix the caret position\n                    // Unfortunately this does not fix all android browsers, only Android Chrome currently.\n                    // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\n                    this._setCaretPosition(settingsClone.androidSelectionStart);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @param {HTMLElement} that - A reference to the current DOM element\r\n     * @returns {*}\r\n     * @private\r\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = scIndex.indexOf(i);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\r\n     * Handler for 'focusin' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.hasFocus = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                jQueryOriginalVal.call($this, toggleNegativeBracket(e.target.value, settings));\n            }\n\n            // clean the value to compare to rawValue\n            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n            result = convertToNumericString(result, settings);\n            result = cleanLeadingTrailingZeros(result, settings);\n            if (settings.trailingNegative) {\n                result = '-' + result;\n            }\n\n            var roundedValue = void 0;\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = Number(settings.oDec);\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                roundedValue = roundValue(settings.rawValue, settings);\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n            } else if (result !== settings.rawValue) {\n                // updates the rawValue\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                jQueryOriginalVal.call($this, onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'keydown' events.\r\n     * The user just started pushing any key, hence one event is sent.\r\n     *\r\n     * Note :\r\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n     * - keydown\r\n     * - keypress\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * ...when inputting a modifier key (ie. 'ctrl') :\r\n     * - keydown\r\n     * - keyup\r\n     *\r\n     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - change\r\n     * - keyup\r\n     *\r\n     * When a paste is done, the following events are sent :\r\n     * - input (if paste is done with the mouse)\r\n     *\r\n     * - keydown (if paste is done with ctrl+v)\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     * - keyup\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\r\n     * Handler for 'keypress' events.\r\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onKeypress(holder, e) {\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n        var eventCharacter = character(e);\n\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (eventCharacter === keyName.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n                    var position = getElementSelection(e.target).start + 1;\n                    setElementSelection(e.target, position, position);\n                }\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\r\n     * Handler for 'input' events.\r\n     * added to support android devices with mobile chrome browsers and others\r\n     * Has the potential to replace the keypress event.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onInput(holder, e) {\n        var value = e.target.value;\n\n        // Fix the caret position on keyup in the `_formatValue()` function\n        holder.settings.androidSelectionStart = null;\n\n        if (holder.eventKeyCode === keyCode.AndroidDefault) {\n            // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\n            if (value.length > holder.lastVal.length || value.length >= holder.lastVal.length - holder.selection.length) {\n                // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\n                holder.eventKeyCode = value.charCodeAt(holder.selection.start);\n\n                // Capture the actual character entered\n                var androidCharEntered = value.charAt(holder.selection.start);\n\n                // Check if the given character should be inserted, and if so, do insert it into the current element value\n                var isCharacterInsertionAllowed = holder._processCharacterInsertion(androidCharEntered);\n\n                if (isCharacterInsertionAllowed) {\n                    // Allowed character entered (number, decimal or plus/minus sign)\n                    holder._formatValue(e);\n\n                    // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\n                    //TODO Check if this is an Android bug or an autoNumeric one\n                    holder.settings.androidSelectionStart = holder.selection.start;\n\n                    var decimalCharacterPosition = e.target.value.indexOf(holder.settings.decimalCharacter);\n                    var hasDecimalCharacter = decimalCharacterPosition === -1;\n\n                    // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\n                    if (androidCharEntered === holder.settings.decimalCharacter || !hasDecimalCharacter && decimalCharacterPosition < holder.settings.androidSelectionStart) {\n                        holder.settings.androidSelectionStart = holder.selection.start + 1;\n                    }\n\n                    if (e.target.value.length > value.length) {\n                        // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\n                        setElementSelection(e.target, holder.settings.androidSelectionStart, holder.settings.androidSelectionStart);\n                    }\n\n                    holder.lastVal = e.target.value;\n\n                    return;\n                } else {\n                    // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\n                    e.target.value = holder.lastVal;\n                    setElementSelection(e.target, holder.selection.start, holder.selection.end);\n                    holder.settings.androidSelectionStart = holder.selection.start;\n                }\n\n                e.preventDefault(); //FIXME How does that affects the normal trigger of the input event?\n\n                holder.formatted = false;\n            } else {\n                // Character deleted\n                //TODO What about the `Delete` key?\n                holder.eventKeyCode = keyCode.Backspace;\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'keyup' events.\r\n     * The user just released any key, hence one event is sent.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {object} settings\r\n     * @param {Event} e\r\n     */\n    function onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        var isOnAndroid = holder.settingsClone.androidSelectionStart !== null;\n        if (skip && !isOnAndroid || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\r\n     * Handler for 'focusout' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.hasFocus = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative && !isNegative(value)) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? Number(settings.scaleDecimalPlaces) : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                jQueryOriginalVal.call($this, groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\r\n     * Handler for 'paste' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegativeStrict(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\n        var pastedText = void 0;\n        if (untranslatedPastedText === '.') {\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n            pastedText = '.';\n        } else {\n            // Normal case\n            // Allow pasting arabic numbers\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n        }\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = void 0;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        var leftPartContainedADot = false;\n        var leftPart = void 0;\n        var rightPart = void 0;\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\r\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n             * Otherwise paste all the numbers in the clipboard.\r\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n             *\r\n             * 4b. Replace paste behavior:\r\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                if (leftPartContainedADot) {\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                    caretPositionOnInitialTextAfterPasting--;\n                }\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\r\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // 1. Generate the unformatted result\n                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // Generate the unformatted result\n                result = '' + leftPart + pastedText + rightPart;\n\n                // 2. Calculate the caret position in the unformatted value, for later use\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, then the caret position is set after the pasted text\n                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else if (rightPart === '') {\n                        // If the user selected from the caret position to the end of the input (on the far right)\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                    }\n                }\n\n                // Modify the caret position for special cases, only if the whole input has not been selected\n                if (!isAllInputTextSelected) {\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        caretPositionOnInitialTextAfterPasting++;\n                    }\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\r\n         * If 'error' (this is the default) :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'ignore' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, do nothing more.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'clamp' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n         *        paste result.\r\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n         * If 'truncate' :\r\n         *      - Truncate paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         * If 'replace' :\r\n         *      - Replace paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\r\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n        }\n    }\n\n    /**\r\n     * Handler for 'submit' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    jQueryOriginalVal.call($this, $settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\r\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @returns {boolean|*}\r\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\r\n     * Formats the default value on page load.\r\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n     *\r\n     * @param {object} settings\r\n     * @param {object} $input jQuery-selected <input> element\r\n     * @param {object} $this jQuery-selected DOM element\r\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = jQueryOriginalVal.call($this);\n            /*\r\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n             *\r\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n             * we should ignore `defaultValueOverride` altogether.\r\n             */\n            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup oDec\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\r\n                 * - page reload from back button, and\r\n                 * - ASP.net form post back\r\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                 */\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.hasFocus = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n                        } else {\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n                        }\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        jQueryOriginalVal.call($this, settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\r\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n     *\r\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n     *\r\n     * @param {object} settings\r\n     */\n    function correctNegativePositiveSignPlacementOption(settings) {\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\n        if (!isNull(settings.negativePositiveSignPlacement)) {\n            return;\n        }\n\n        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 €\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n                    break;\n                default:\n                //\n            }\n        } else {\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\n            settings.negativePositiveSignPlacement = 'l';\n        }\n    }\n\n    /**\r\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n     *\r\n     * @param {object} settings\r\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\r\n     * Modify `decimalPlacesOverride` as needed\r\n     *\r\n     * @param {object} settings\r\n     */\n    function correctDecimalPlacesOverrideOption(settings) {\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\r\n     * Sets the alternative decimal separator key.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\r\n     * Caches regular expressions for stripAllNonNumberCharacters\r\n     *\r\n     * @param {object} settings\r\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var allNumbersReg = '[0-9]';\n        var noAllNumbersReg = '[^0-9]';\n\n        // Test if there is a negative character in the string\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n\n        var negativeSignRegPart = void 0;\n        if (settings.negativeSignCharacter) {\n            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n        } else {\n            negativeSignRegPart = '';\n        }\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n    }\n\n    /**\r\n     * Modify the user settings to make them 'exploitable' later.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\r\n     * Convert the old settings options name to new ones.\r\n     *\r\n     * @param {object} options\r\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            showPositiveSign: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            hasFocus: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            positiveSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n     *\r\n     * @param {object} options\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n     * @returns {object|null}\r\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    hasFocus: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    androidSelectionStart: null,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctNegativePositiveSignPlacementOption(settings);\n\n            // Set the negative and positive signs, as needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctDecimalPlacesOverrideOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\r\n     * Convert the `value` parameter that can either be :\r\n     * - a real number,\r\n     * - a string representing a real number, or\r\n     * - a string representing a localized number (with specific group separators and decimal character),\r\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n     *\r\n     * This function returns `NaN` if such conversion fails.\r\n     *\r\n     * @param {int|float|string} value\r\n     * @param {object} settings\r\n     * @returns {string|NaN}\r\n     */\n    function toNumericValue(value, settings) {\n        var result = void 0;\n        if (isNumber(Number(value))) {\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n            result = value;\n        } else {\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\n            result = convertToNumericString(value.toString(), settings);\n\n            // If the result is still not a numeric string, then we throw a warning\n            if (!isNumber(Number(result))) {\n                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                result = NaN;\n            }\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\n    var methods = {\n        /**\r\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('input', function (e) {\n                        onInput(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to stop and remove autoNumeric for the current element.\r\n         * Note: this does not remove the formatting.\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    jQueryOriginalVal.call($this, '');\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    jQueryOriginalVal.call($this, '');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method that updates the autoNumeric settings.\r\n         * It can be called multiple times if needed.\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '}).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|jQuery}\r\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                // Retrieve the current unformatted input value\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n\n                // Update the settings\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                // Reformat the input value with the new settings\n                if (jQueryOriginalVal.call($this) !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         *\r\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n         *\r\n         * @param {*} newValue\r\n         * @returns {*|jQuery}\r\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n                }\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n                settings.trailingNegative = false;\n\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                var value = toNumericValue(newValue, settings);\n                if (isNaN(value)) {\n                    return jQueryOriginalVal.call($this, '');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n                    // This test is needed by the showPositiveSign option\n\n\n                    var isZero = isZeroOrHasNoValue(value);\n                    if (isZero) {\n                        value = '0';\n                    }\n\n                    if (minTest && maxTest) {\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            // to ensure rounding does not happen twice\n                            var hasBeenRounded = false;\n\n                            // rounds the the extended decimal places\n                            var tempDecimal = void 0;\n                            if (settings.decimalPlacesShownOnFocus) {\n                                tempDecimal = settings.decimalPlacesOverride;\n                                settings.decimalPlacesOverride = Number(settings.decimalPlacesShownOnFocus);\n                                value = roundValue(value, settings);\n                                hasBeenRounded = true;\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = roundValue(value, settings);\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                                value = toNumericValue(value, settings);\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                if (settings.scaleDecimalPlaces) {\n                                    tempDecimal = settings.decimalPlacesOverride;\n                                    settings.decimalPlacesOverride = Number(settings.scaleDecimalPlaces);\n                                    value = roundValue(value, settings);\n                                    hasBeenRounded = true;\n                                }\n                            }\n\n                            // Rounds if this has not been done already\n                            if (!hasBeenRounded) {\n                                value = roundValue(value, settings);\n                            }\n\n                            // Stores rawValue including the decimalPlacesShownOnFocus\n                            if (!settings.scaleDivisor) {\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n\n                            if (settings.scaleDivisor && settings.scaleDecimalPlaces && !settings.onOff) {\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return jQueryOriginalVal.call($this, '');\n                    }\n                } else {\n                    return jQueryOriginalVal.call($this, '');\n                }\n\n                if (!settings.hasFocus && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return jQueryOriginalVal.call($this, value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\r\n         * Method to un-format inputs.\r\n         * This is handy to use right before form submission.\r\n         *\r\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n         * Please see option \"outputFormat\" for more details\r\n         *\r\n         * @example $(someSelector).autoNumeric('unSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.hasFocus = true;\n                    jQueryOriginalVal.call($this, $this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to re-format inputs.\r\n         * This is handy to use right after form submission.\r\n         *\r\n         * This is called after the 'unSet' method to reformat the input\r\n         *\r\n         * @example $(someSelector).autoNumeric('reSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', jQueryOriginalVal.call($this));\n                }\n            });\n        },\n\n\n        /**\r\n         * Return the unformatted value as a string.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('get');\r\n         *\r\n         * @returns {string}\r\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = jQueryOriginalVal.call($this.eq(0));\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                // Test if the value is negative\n                var isValueNegative = isNegative(value);\n\n                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.hasFocus = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    // Strips trailing negative symbol\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\n                    // Places the negative symbol in front of the trailing negative\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n                        value = '-' + value;\n                    }\n                }\n\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                }\n            }\n\n            // Always return a numeric string\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n            return trimPaddedZerosFromDecimalPlaces(value);\n        },\n\n\n        /**\r\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n         * - a plain number (if the setting 'number' is used).\r\n         *\r\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n         * Check the \"outputFormat\" option definition for more details.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getLocalized');\r\n         *\r\n         * @returns {*}\r\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\r\n         * Return the input unformatted value as a real Javascript number.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getNumber');\r\n         *\r\n         * @returns {number}\r\n         */\n        getNumber: function getNumber() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {string}\r\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {{}|[]}\r\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\r\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('getSettings');\r\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n         *\r\n         * @returns {object}\r\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\r\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n     * It initialize autoNumeric on the given element.\r\n     *\r\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n     * @param {*} args\r\n     * @returns {*}\r\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\r\n     * Return the default autoNumeric settings.\r\n     *\r\n     * @returns {object}\r\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\r\n     * Return all the predefined language options in one object.\r\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n     *\r\n     * @returns {object}\r\n     */\n    getLanguages = function getLanguages() {\n        return languageOption;\n    };\n\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\n    /**\r\n     * Public function that allows formatting without an element trigger.\r\n     *\r\n     * @param {number|string} value A number, or a string that represent a javascript number\r\n     * @param {object|null} options\r\n     * @returns {*}\r\n     */\n    autoFormat = function autoFormat(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        if (!isString(value) && !isNumber(value)) {\n            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Check the validity of the `value` parameter\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\n        var valueString = toNumericValue(value, settings);\n        if (isNaN(valueString)) {\n            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\r\n     * Public function that allows unformatting without an element.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} options\r\n     * @returns {*}\r\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n        if (isNegative(value)) {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.hasFocus = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(settings.decimalCharacter, '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\r\n     * Validate the given option object.\r\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n     *\r\n     * This tests if the options are not conflicting and are well formatted.\r\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n     *\r\n     * @param {*} userOptions\r\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n     * @throws Error\r\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n        '.', // Dot\n        ' ', // Normal space\n        '\\u2009', // Thin-space\n        '\\u202F', // Narrow no-break space\n        '\\xA0', // No-break space\n        '', // No separator\n        \"'\", // Apostrophe\n        '٬', // Arabic thousands separator\n        '˙'])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', // Comma\n        '.', // Dot\n        '·', // Middle-dot\n        '٫', // Arabic decimal separator\n        '⎖'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\r\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n     *\r\n     * @param {object} options\r\n     * @returns {boolean}\r\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\r\n     * Take an arabic number as a string and return a javascript number.\r\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n     * This returns `NaN` is the conversion is not possible.\r\n     * Based on http://stackoverflow.com/a/17025392/2834898\r\n     *\r\n     * @param {string} arabicNumbers\r\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n     * @param {boolean} parseDecimalCharacter\r\n     * @param {boolean} parseThousandSeparator\r\n     * @returns {string|number|NaN}\r\n     */\n    function arabicToLatinNumbers(arabicNumbers) {\n        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var result = arabicNumbers.toString();\n        if (result === '' || result.match(/[٠١٢٣٤٥٦٧٨٩۴۵۶]/g) === null) {\n            // If no Arabic/Persian numbers are found, return the numeric string directly\n            return arabicNumbers;\n        }\n\n        if (parseDecimalCharacter) {\n            result = result.replace(/٫/, '.'); // Decimal character\n        }\n\n        if (parseThousandSeparator) {\n            result = result.replace(/٬/g, ''); // Thousand separator\n        }\n\n        // Replace the numbers only\n        result = result.replace(/[٠١٢٣٤٥٦٧٨٩]/g, function (d) {\n            return d.charCodeAt(0) - 1632;\n        }) // Arabic numbers\n        .replace(/[۰۱۲۳۴۵۶۷۸۹]/g, function (d) {\n            return d.charCodeAt(0) - 1776;\n        }); // Persian numbers\n\n        // `NaN` has precedence over the string `'NaN'`\n        var resultAsNumber = Number(result);\n        if (isNaN(resultAsNumber)) {\n            return resultAsNumber;\n        }\n\n        if (returnANumber) {\n            result = resultAsNumber;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Create a custom event and immediately sent it from the given element.\r\n     * By default, if no element is given, the event is thrown from `document`.\r\n     *\r\n     * @param {string} eventName\r\n     * @param {Element} element\r\n     * @param {object} detail\r\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n\n    jQuery.extend(true, defaultSettings, jQuery.fn.autoNumeric.lang.Turkish, { currencySymbol: '' });\n\n    // Hijack the original val fn in order to\n    // use $autoNumeric.val() and be able to get/set\n    // the unmasked value.\n    jQuery.fn.val = function (value) {\n        var me = this,\n            $me = $(me);\n\n        // If we're not dealing with an instance of autoNumeric,\n        // simply call the original jQuery.fn.val\n        if ($me.data('autoNumeric') === undefined) {\n            return jQueryOriginalVal.apply(me, arguments);\n        }\n\n        if (!arguments.length) {\n            // We're trying to read the numeric value\n            return $me.autoNumeric('get');\n        } else {\n            // We're trying to set a value\n            var originalVal = value;\n            var numericValue = void 0;\n\n            if (typeof value === 'string') {\n                value = value.replace(',', '.');\n                numericValue = parseFloat(value, 10);\n\n                if (isNaN(numericValue)) {\n                    throw '\"' + originalVal + '\" is not a number.';\n                }\n            } else if (typeof value !== 'number') {\n                throw 'The type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is not supported.';\n            } else {\n                numericValue = value;\n            }\n\n            return $me.autoNumeric('set', numericValue);\n        }\n    };\n});\n\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    getLanguages: getLanguages,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJqUXVlcnlPcmlnaW5hbFZhbCIsImpRdWVyeSIsImZuIiwidmFsIiwiYXV0b0Zvcm1hdCIsImF1dG9VbkZvcm1hdCIsImdldERlZmF1bHRDb25maWciLCJnZXRMYW5ndWFnZXMiLCJ2YWxpZGF0ZSIsImFyZVNldHRpbmdzVmFsaWQiLCJhbGxvd2VkVGFnTGlzdCIsImRlZmF1bHRTZXR0aW5ncyIsImRpZ2l0R3JvdXBTZXBhcmF0b3IiLCJub1NlcGFyYXRvck9uRm9jdXMiLCJkaWdpdGFsR3JvdXBTcGFjaW5nIiwiZGVjaW1hbENoYXJhY3RlciIsImRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSIsImN1cnJlbmN5U3ltYm9sIiwiY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQiLCJuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCIsInNob3dQb3NpdGl2ZVNpZ24iLCJzdWZmaXhUZXh0Iiwib3ZlcnJpZGVNaW5NYXhMaW1pdHMiLCJtYXhpbXVtVmFsdWUiLCJtaW5pbXVtVmFsdWUiLCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIiwic2NhbGVEaXZpc29yIiwic2NhbGVEZWNpbWFsUGxhY2VzIiwic2NhbGVTeW1ib2wiLCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlIiwib25JbnZhbGlkUGFzdGUiLCJyb3VuZGluZ01ldGhvZCIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsImVtcHR5SW5wdXRCZWhhdmlvciIsImxlYWRpbmdaZXJvIiwiZm9ybWF0T25QYWdlTG9hZCIsInNlbGVjdE51bWJlck9ubHkiLCJkZWZhdWx0VmFsdWVPdmVycmlkZSIsInVuZm9ybWF0T25TdWJtaXQiLCJvdXRwdXRGb3JtYXQiLCJzaG93V2FybmluZ3MiLCJmYWlsT25Vbmtub3duT3B0aW9uIiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsIkFuZHJvaWREZWZhdWx0Iiwia2V5TmFtZSIsIlVuaWRlbnRpZmllZCIsIkFsdEdyIiwiRm4iLCJGbkxvY2siLCJIeXBlciIsIk1ldGEiLCJTdXBlciIsIlN5bWJvbCIsIlN5bWJvbExvY2siLCJDbGVhciIsIkNvcHkiLCJDclNlbCIsIkN1dCIsIkVyYXNlRW9mIiwiRXhTZWwiLCJQYXN0ZSIsIlJlZG8iLCJVbmRvIiwiQWNjZXB0IiwiQWdhaW4iLCJBdHRuIiwiQ2FuY2VsIiwiQ29udGV4dE1lbnUiLCJFeGVjdXRlIiwiRmluZCIsIkZpbmlzaCIsIkhlbHAiLCJQYXVzZSIsIlBsYXkiLCJQcm9wcyIsIlNlbGVjdCIsIlpvb21JbiIsIlpvb21PdXQiLCJCcmlnaHRuZXNzRG93biIsIkJyaWdodG5lc3NVcCIsIkVqZWN0IiwiTG9nT2ZmIiwiUG93ZXIiLCJQb3dlck9mZiIsIlByaW50U2NyZWVuIiwiSGliZXJuYXRlIiwiU3RhbmRieSIsIldha2VVcCIsIkNvbXBvc2UiLCJEZWFkIiwiUHJpbnQiLCJNaW51cyIsIlBsdXMiLCJOdW1wYWREb3QiLCJOdW1wYWREb3RBbHQiLCJOdW1wYWRNdWx0aXBseSIsIk51bXBhZFBsdXMiLCJOdW1wYWRNaW51cyIsIk51bXBhZFNsYXNoIiwiTnVtcGFkRG90T2Jzb2xldGVCcm93c2VycyIsIk51bXBhZE11bHRpcGx5T2Jzb2xldGVCcm93c2VycyIsIk51bXBhZFBsdXNPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkTWludXNPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkU2xhc2hPYnNvbGV0ZUJyb3dzZXJzIiwiZGVmYXVsdE1pbmltdW1WYWx1ZSIsImRlZmF1bHRNYXhpbXVtVmFsdWUiLCJkZWZhdWx0Um91bmRpbmdNZXRob2QiLCJkZWZhdWx0TGVhZGluZ1plcm8iLCJkZWZhdWx0U2VsZWN0TnVtYmVyT25seSIsImxhbmd1YWdlT3B0aW9uIiwiRnJlbmNoIiwiTm9ydGhBbWVyaWNhbiIsIkJyaXRpc2giLCJTd2lzcyIsIkphcGFuZXNlIiwiVHVya2lzaCIsIlNwYW5pc2giLCJDaGluZXNlIiwiZmFjdG9yeSIsImRlZmluZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwid2luZG93IiwiaXNOdWxsIiwidmFsdWUiLCJpc1VuZGVmaW5lZCIsImlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSIsImlzU3RyaW5nIiwic3RyIiwiU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNUcnVlT3JGYWxzZVN0cmluZyIsImxvd2VyY2FzZVZhbHVlIiwidG9Mb3dlckNhc2UiLCJpc09iamVjdCIsInJlZmVyZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsImlzRW1wdHlPYmoiLCJvYmoiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJpc051bWJlciIsImlzTmFOIiwicGFyc2VGbG9hdCIsImlzRmluaXRlIiwiaXNJbnQiLCJwYXJzZUludCIsInByZXBhcmVQYXN0ZWRUZXh0IiwidGV4dCIsImhvbGRlciIsInN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyIsInNldHRpbmdzQ2xvbmUiLCJyZXBsYWNlIiwiY29udGFpbnMiLCJuZWVkbGUiLCJpbmRleE9mIiwiaXNJbkFycmF5IiwiYXJyYXkiLCJhcnIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJFcnJvciIsImRlY2ltYWxQbGFjZXMiLCJzcGxpdCIsImRlY2ltYWxQYXJ0IiwibGVuZ3RoIiwia2V5Q29kZU51bWJlciIsImV2ZW50Iiwid2hpY2giLCJjaGFyYWN0ZXIiLCJrZXkiLCJmcm9tQ2hhckNvZGUiLCJyZXN1bHQiLCJjaGVja0lmSW5SYW5nZSIsInBhcnNlZE1pblZhbHVlIiwicGFyc2VkTWF4VmFsdWUiLCJwYXJzZWRWYWx1ZSIsInBhcnNlU3RyIiwidGVzdE1pbk1heCIsImlzTmVnYXRpdmUiLCJudW1lcmljU3RyaW5nIiwiY2hlY2tFdmVyeXdoZXJlIiwiaXNOZWdhdGl2ZVN0cmljdCIsImNoYXJBdCIsImlzWmVyb09ySGFzTm9WYWx1ZSIsInRlc3QiLCJzZXRSYXdOZWdhdGl2ZVNpZ24iLCJyZXBsYWNlQ2hhckF0Iiwic3RyaW5nIiwiaW5kZXgiLCJuZXdDaGFyYWN0ZXIiLCJzdWJzdHIiLCJjbGFtcFRvUmFuZ2VMaW1pdHMiLCJzZXR0aW5ncyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmciLCJjYXJldFBvc2l0aW9uIiwibnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24iLCJSZWdFeHAiLCJudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCIsImZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJyYXdOdW1iZXJTdHJpbmciLCJjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUiLCJyYXdOdW1iZXJTdHJpbmdTaXplIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXgiLCJyYXdOdW1iZXJTdHJpbmdJbmRleCIsImNvdW50Q2hhckluVGV4dCIsImNoYXJDb3VudGVyIiwiY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uIiwiY2hhcmFjdGVyQ291bnQiLCJnZXRFbGVtZW50U2VsZWN0aW9uIiwidGhhdCIsInBvc2l0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJmb2N1cyIsInNlbGVjdCIsImRvY3VtZW50Iiwic2VsZWN0aW9uIiwiY3JlYXRlUmFuZ2UiLCJtb3ZlU3RhcnQiLCJlbmQiLCJzdGFydCIsInNlbGVjdGlvbkVuZCIsInNldEVsZW1lbnRTZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwibW92ZUVuZCIsInRocm93RXJyb3IiLCJtZXNzYWdlIiwid2FybmluZyIsInNob3dXYXJuaW5nIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QiLCIkdGhpcyIsIiQiLCJlYWNoIiwiYXV0b051bWVyaWMiLCJtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoIiwibGVmdE9yQWxsIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwidHJhaWxpbmdOZWdhdGl2ZSIsInNraXBMYXN0QXV0b1N0cmlwIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm1hdGNoIiwibnVtUmVnQXV0b1N0cmlwIiwiam9pbiIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwibmVnYXRpdmVTaWduQ2hhcmFjdGVyIiwibUludFBvcyIsInNsaWNlIiwibUludE5lZyIsImhhc0ZvY3VzIiwic3RyaXBSZWciLCJ0b2dnbGVOZWdhdGl2ZUJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImNvbnZlcnRUb051bWVyaWNTdHJpbmciLCJsYXN0SW5kZXhPZiIsInRlbXAiLCJhcmFiaWNUb0xhdGluTnVtYmVycyIsInRvTG9jYWxlIiwibG9jYWxlIiwiTnVtYmVyIiwibW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlIiwibW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlIiwiY2hlY2tFbXB0eSIsImlucHV0VmFsdWUiLCJzaWduT25FbXB0eSIsImFkZEdyb3VwU2VwYXJhdG9ycyIsInN0cmlwIiwiZW1wdHkiLCJpc1ZhbHVlTmVnYXRpdmUiLCJpc1plcm8iLCJkaWdpdGFsR3JvdXAiLCJzdWJzdHJpbmciLCJwb3NpdGl2ZVNpZ25DaGFyYWN0ZXIiLCJyYXdWYWx1ZSIsInRydW5jYXRlWmVyb3MiLCJyb3VuZGVkSW5wdXRWYWx1ZSIsInRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSIsInJlZ2V4Iiwicm91bmRWYWx1ZSIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwiaXZSb3VuZGVkIiwiZFBvcyIsImlucHV0VmFsdWVIYXNBRG90IiwidmRQb3MiLCJjRGVjIiwiemVyb3MiLCJyTGVuZ3RoIiwidFJvdW5kIiwib2RkIiwiaXZBcnJheSIsInRydW5jYXRlRGVjaW1hbCIsImlzUGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwibkwiLCJzZWFyY2giLCJ4YyIsInljIiwieE5lZyIsImNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uIiwibWluUGFyc2UiLCJtYXhQYXJzZSIsInZhbFBhcnNlIiwiZ2V0Q3VycmVudEVsZW1lbnQiLCJlbGVtZW50IiwiZ2V0QXV0b051bWVyaWNIb2xkZXIiLCJ1cGRhdGUiLCJkYXRhIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSIsIm9EZWMiLCJvUGFkIiwib0JyYWNrZXQiLCJvU2VwIiwib1NpZ24iLCJvU3VmZml4IiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3MiLCJ0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyIsInRyaW1tZWREZWNpbWFsUGFydCIsInNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UiLCJhY3Rpb24iLCJzdG9yZWROYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJkYXRlIiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SXRlbSIsIiR0aGF0IiwiZm9ybWF0dGVkIiwicHJvY2Vzc2VkIiwiZXZlbnRLZXlDb2RlIiwic2V0UmVhbCIsInBvcyIsIl9zZXRTZWxlY3Rpb24iLCJsZWZ0IiwicmlnaHQiLCJfZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInN0cmlwWmVyb3MiLCJuZXdWYWx1ZSIsImFOZWdSZWdBdXRvU3RyaXAiLCJwYXJ0cyIsIl9ub3JtYWxpemVQYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwiX3NldENhcmV0UG9zaXRpb24iLCJ0cmlnZ2VyIiwiY3VycmVuY3lTeW1ib2xMZW4iLCJoYXNOZWciLCJ2YWx1ZUxlbiIsInNpZ25Qb3NpdGlvbiIsIl9nZXRTaWduUG9zaXRpb24iLCJ2YWx1ZVBhcnRzQmVmb3JlUGFzdGUiLCJvbGRQYXJ0cyIsIm1vZGlmaWVkTGVmdFBhcnQiLCJfc2V0VmFsdWVQYXJ0cyIsImN0cmxLZXkiLCJtZXRhS2V5IiwidHlwZSIsInNoaWZ0S2V5IiwiX2NoZWNrUGFzdGUiLCJwcmV2ZW50RGVmYXVsdCIsIm5lZ0xlbiIsInN1ZmZpeFRleHRMZW4iLCJfZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiY2FyZXRGaXgiLCJfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uIiwidGhyb3dJbnB1dCIsIl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduIiwiZXZlbnRPckNoYXIiLCJldmVudENoYXJhY3RlciIsImV2ZW50TnVtYmVyIiwibGVmdExlbmd0aCIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJpbnB1dCIsImFuZHJvaWRTZWxlY3Rpb25TdGFydCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImFsbEZvcm1FbGVtZW50cyIsImFpSW5kZXgiLCJzY0luZGV4IiwiclN1Ym1pdHRlclR5cGVzIiwiclN1Ym1pdHRhYmxlIiwickNoZWNrYWJsZVR5cGUiLCJyTm9uQXV0b051bWVyaWNUeXBlcyIsImNvdW50IiwiZmllbGQiLCJsb2NhbE5hbWUiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJmb3JtRmllbGRzIiwic2VyaWFsaXplQXJyYXkiLCJzY0VsZW1lbnQiLCJ0ZXN0SW5wdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJvbkZvY3VzSW5BbmRNb3VzZUVudGVyIiwiaXMiLCJ0YXJnZXQiLCJyb3VuZGVkVmFsdWUiLCJ2YWx1ZU9uRm9jdXMiLCJsYXN0VmFsIiwib25FbXB0eSIsIm9uS2V5ZG93biIsIl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZSIsImluaXRpYWxWYWx1ZU9uS2V5ZG93biIsInJlYWRPbmx5IiwidHJpZ2dlckV2ZW50IiwiX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyIsIl9za2lwQWx3YXlzIiwiX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbiIsIl9mb3JtYXRWYWx1ZSIsIm9uS2V5cHJlc3MiLCJpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQiLCJfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbiIsIm9uSW5wdXQiLCJjaGFyQ29kZUF0IiwiYW5kcm9pZENoYXJFbnRlcmVkIiwiZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uIiwiaGFzRGVjaW1hbENoYXJhY3RlciIsIm9uS2V5dXAiLCJza2lwIiwiaXNPbkFuZHJvaWQiLCJvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsImNoYW5nZSIsIm9uUGFzdGUiLCJyYXdQYXN0ZWRUZXh0IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJpbml0aWFsRm9ybWF0dGVkVmFsdWUiLCJzZWxlY3Rpb25TaXplIiwiaXNBbGxJbnB1dFRleHRTZWxlY3RlZCIsImlzUGFzdGVOZWdhdGl2ZSIsInVudHJhbnNsYXRlZFBhc3RlZFRleHQiLCJwYXN0ZWRUZXh0IiwiY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmciLCJpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIiLCJpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlIiwiaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSIsImxlZnRQYXJ0Q29udGFpbmVkQURvdCIsImxlZnRQYXJ0IiwicmlnaHRQYXJ0IiwibGVmdEZvcm1hdHRlZFBhcnQiLCJyaWdodEZvcm1hdHRlZFBhcnQiLCJsYXN0R29vZEtub3duUmVzdWx0IiwicGFzdGVkVGV4dEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdFNpemUiLCJsZWZ0Rm9ybWF0dGVkUGFydDIiLCJyaWdodEZvcm1hdHRlZFBhcnQyIiwiaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQiLCJpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUiLCJzZWxlY3RlZFRleHQiLCJ2YWx1ZUhhc0JlZW5TZXQiLCJ2YWx1ZUhhc0JlZW5DbGFtcGVkIiwiZXJyb3IiLCJjbGFtcGVkVmFsdWUiLCJjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJvbkJsdXIiLCJvblN1Ym1pdCIsImNsb3Nlc3QiLCJvbiIsIiRzZXR0aW5ncyIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiY3VycmVudEVsZW1lbnRUYWciLCJmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkIiwic2V0VmFsdWUiLCJjdXJyZW50VmFsdWUiLCJ1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSIsInRvTnVtZXJpY1ZhbHVlIiwiYXR0ciIsIkluZmluaXR5IiwidG9TdHJpcCIsInRhZ0xpc3QiLCJjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24iLCJjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyIsIm1heGltdW1WYWx1ZUludGVnZXJQYXJ0IiwibWluaW11bVZhbHVlSW50ZWdlclBhcnQiLCJjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uIiwic2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlciIsImNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zIiwiYWxsTnVtYmVyc1JlZyIsIm5vQWxsTnVtYmVyc1JlZyIsImFOZWdSZWciLCJuZWdhdGl2ZVNpZ25SZWdQYXJ0IiwiYWxsb3dlZCIsInRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyIsImNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzIiwib3B0aW9ucyIsIm9sZE9wdGlvbnNDb252ZXJ0ZXIiLCJhU2VwIiwiblNlcCIsImRHcm91cCIsImFEZWMiLCJhbHREZWMiLCJhU2lnbiIsInBTaWduIiwicE5lZyIsImFTdWZmaXgiLCJvTGltaXRzIiwidk1heCIsInZNaW4iLCJtRGVjIiwiZURlYyIsInNjYWxlRGVjaW1hbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwicnVuT25jZSIsIm9wdGlvbiIsImdldEluaXRpYWxTZXR0aW5ncyIsImV4dGVuZCIsInRhZ0RhdGEiLCJOYU4iLCJtZXRob2RzIiwiaW5pdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJoYXNCZWVuUm91bmRlZCIsInRlbXBEZWNpbWFsIiwib25PZmYiLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldExvY2FsaXplZCIsImdldE51bWJlciIsImdldEZvcm1hdHRlZCIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJkZWZhdWx0cyIsImxhbmciLCJ2YWx1ZVN0cmluZyIsImF1dG9TdHJpcCIsImF1dG9VbmZvcm1hdCIsInVzZXJPcHRpb25zIiwic2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJ0ZXN0UG9zaXRpdmVJbnRlZ2VyIiwidGVzdE51bWVyaWNhbENoYXJhY3RlcnMiLCJ0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiIsInRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyIiwidk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyIsImF1dG9WYWxpZGF0ZSIsImlzVmFsaWQiLCJhcmFiaWNOdW1iZXJzIiwicmV0dXJuQU51bWJlciIsInBhcnNlRGVjaW1hbENoYXJhY3RlciIsInBhcnNlVGhvdXNhbmRTZXBhcmF0b3IiLCJyZXN1bHRBc051bWJlciIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJwYXJhbXMiLCJldnQiLCJFdmVudCIsIm1lIiwiJG1lIiwidW5kZWZpbmVkIiwiYXJndW1lbnRzIiwib3JpZ2luYWxWYWwiLCJudW1lcmljVmFsdWUiLCJmb3JtYXQiLCJ1bkZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7O0FBRUEsSUFBTUEsb0JBQW9CQyxPQUFPQyxFQUFQLENBQVVDLEdBQXBDOztBQUVBO0FBQ0EsSUFBSUMsbUJBQUo7QUFDQSxJQUFJQyxxQkFBSjtBQUNBLElBQUlDLHlCQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyxpQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBO0FBQ0E7OztBQUdBLElBQU1DLGlCQUFpQixDQUNuQixHQURtQixFQUVuQixTQUZtQixFQUduQixNQUhtQixFQUluQixNQUptQixFQUtuQixPQUxtQixFQU1uQixJQU5tQixFQU9uQixLQVBtQixFQVFuQixLQVJtQixFQVNuQixLQVRtQixFQVVuQixJQVZtQixFQVduQixJQVhtQixFQVluQixJQVptQixFQWFuQixJQWJtQixFQWNuQixJQWRtQixFQWVuQixJQWZtQixFQWdCbkIsSUFoQm1CLEVBaUJuQixJQWpCbUIsRUFrQm5CLEtBbEJtQixFQW1CbkIsS0FuQm1CLEVBb0JuQixPQXBCbUIsRUFxQm5CLElBckJtQixFQXNCbkIsUUF0Qm1CLEVBdUJuQixRQXZCbUIsRUF3Qm5CLEdBeEJtQixFQXlCbkIsR0F6Qm1CLEVBMEJuQixHQTFCbUIsRUEy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ZjtBQUNIOztBQUVELG1CQUFPbWYsSUFBSTFYLFdBQUosQ0FBZ0IsS0FBaEIsRUFBdUI4WCxZQUF2QixDQUFQO0FBQ0g7QUFDSixLQWxDRDtBQW1DSCxDQW5uSkEsQ0FBRDs7QUFxbkpBOzs7a0JBR2U7QUFDWEMsWUFBVXh0QixVQURDO0FBRVh5dEIsY0FBVXh0QixZQUZDO0FBR1hDLHNDQUhXO0FBSVhDLDhCQUpXO0FBS1hDLHNCQUxXLEVBS0Q7QUFDVkMsc0NBTlcsRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqICAgICAgICAgICAgICAgYXV0b051bWVyaWMuanNcclxuICpcclxuICogQHZlcnNpb24gICAgICAyLjAuMTJcclxuICogQGRhdGUgICAgICAgICAyMDE3LTA0LTA3IFVUQyAwNzowMFxyXG4gKlxyXG4gKiBAYXV0aG9yICAgICAgIEJvYiBLbm90aGVcclxuICogQGNvbnRyaWJ1dG9ycyBBbGV4YW5kcmUgQm9ubmVhdSwgU29rb2xvdiBZdXJhIGFuZCBvdGhlciBHaXRodWIgdXNlcnMsXHJcbiAqICAgICAgICAgICAgICAgY2YuIEFVVEhPUlMubWQuXHJcbiAqIEBjb3B5cmlnaHQgICAgMjAwOSBSb2JlcnQgSi4gS25vdGhlIGh0dHA6Ly93d3cuZGVjb3JwbGFuaXQuY29tL3BsdWdpbi9cclxuICogQHNpbmNlICAgICAgICAyMDA5LTA4LTA5XHJcbiAqXHJcbiAqIEBzdW1tYXJ5ICAgICAgYXV0b051bWVyaWMgaXMgYSBsaWJyYXJ5IHRoYXQgcHJvdmlkZXMgbGl2ZSBhcy15b3UtdHlwZVxyXG4gKiAgICAgICAgICAgICAgIGZvcm1hdHRpbmcgZm9yIGludGVybmF0aW9uYWwgbnVtYmVycyBhbmQgY3VycmVuY2llcy5cclxuICpcclxuICogICAgICAgICAgICAgICBOb3RlIDogU29tZSBmdW5jdGlvbnMgYXJlIGJvcnJvd2VkIGZyb20gYmlnLmpzXHJcbiAqIEBsaW5rICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xyXG4gKlxyXG4gKiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hdXRvTnVtZXJpYy9hdXRvTnVtZXJpY1xyXG4gKlxyXG4gKiBAbGljZW5zZSAgICAgIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKiBAbGluayAgICAgICAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4gKiBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuXHJcbi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIGRlZmluZSAqL1xyXG5cclxuY29uc3QgalF1ZXJ5T3JpZ2luYWxWYWwgPSBqUXVlcnkuZm4udmFsO1xyXG5cclxuLy8gRnVuY3Rpb25zIG5hbWVzIGZvciBFUzYgZXhwb3J0c1xyXG5sZXQgYXV0b0Zvcm1hdDtcclxubGV0IGF1dG9VbkZvcm1hdDtcclxubGV0IGdldERlZmF1bHRDb25maWc7XHJcbmxldCBnZXRMYW5ndWFnZXM7XHJcbmxldCB2YWxpZGF0ZTtcclxubGV0IGFyZVNldHRpbmdzVmFsaWQ7XHJcblxyXG4vLyBBdXRvTnVtZXJpYyBkZWZhdWx0IHNldHRpbmdzXHJcbi8qKlxyXG4gKiBMaXN0IG9mIGFsbG93ZWQgdGFnIG9uIHdoaWNoIGF1dG9OdW1lcmljIGNhbiBiZSB1c2VkLlxyXG4gKi9cclxuY29uc3QgYWxsb3dlZFRhZ0xpc3QgPSBbXHJcbiAgICAnYicsXHJcbiAgICAnY2FwdGlvbicsXHJcbiAgICAnY2l0ZScsXHJcbiAgICAnY29kZScsXHJcbiAgICAnY29uc3QnLFxyXG4gICAgJ2RkJyxcclxuICAgICdkZWwnLFxyXG4gICAgJ2RpdicsXHJcbiAgICAnZGZuJyxcclxuICAgICdkdCcsXHJcbiAgICAnZW0nLFxyXG4gICAgJ2gxJyxcclxuICAgICdoMicsXHJcbiAgICAnaDMnLFxyXG4gICAgJ2g0JyxcclxuICAgICdoNScsXHJcbiAgICAnaDYnLFxyXG4gICAgJ2lucycsXHJcbiAgICAna2RiJyxcclxuICAgICdsYWJlbCcsXHJcbiAgICAnbGknLFxyXG4gICAgJ29wdGlvbicsXHJcbiAgICAnb3V0cHV0JyxcclxuICAgICdwJyxcclxuICAgICdxJyxcclxuICAgICdzJyxcclxuICAgICdzYW1wbGUnLFxyXG4gICAgJ3NwYW4nLFxyXG4gICAgJ3N0cm9uZycsXHJcbiAgICAndGQnLFxyXG4gICAgJ3RoJyxcclxuICAgICd1JyxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nIG1ldGhvZDpcclxuICogLSBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgKGllLiBgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1jdXJyZW5jeS1zeW1ib2w9XCIg4oKsXCI+YClcclxuICogLSBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHMgKGllLiBgYU5JbnB1dC5hdXRvTnVtZXJpYygndXBkYXRlJywgeyBjdXJyZW5jeVN5bWJvbDogJyDigqwnIH0pO2ApXHJcbiAqIC0gVXNlIGpRdWVyeSdzIGAkLmV4dGVuZGAgbWV0aG9kIGZvciBnbG9iYWwgY2hhbmdlcyAtIGFsc28gYSBncmVhdCB3YXkgdG8gcGFzcyBBU1AuTkVUIGN1cnJlbnQgY3VsdHVyZSBzZXR0aW5nc1xyXG4gKi9cclxuY29uc3QgZGVmYXVsdFNldHRpbmdzID0ge1xyXG4gICAgLyogQWxsb3dlZCB0aG91c2FuZCBncm91cGluZyBzZXBhcmF0b3IgY2hhcmFjdGVycyA6XHJcbiAgICAgKiAnLCcgICAgICAvLyBDb21tYVxyXG4gICAgICogJy4nICAgICAgLy8gRG90XHJcbiAgICAgKiAnICcgICAgICAvLyBOb3JtYWwgc3BhY2VcclxuICAgICAqICdcXHUyMDA5JyAvLyBUaGluLXNwYWNlXHJcbiAgICAgKiAnXFx1MjAyZicgLy8gTmFycm93IG5vLWJyZWFrIHNwYWNlXHJcbiAgICAgKiAnXFx1MDBhMCcgLy8gTm8tYnJlYWsgc3BhY2VcclxuICAgICAqICcnICAgICAgIC8vIE5vIHNlcGFyYXRvclxyXG4gICAgICogXCInXCIgICAgICAvLyBBcG9zdHJvcGhlXHJcbiAgICAgKiAn2awnICAgICAgLy8gQXJhYmljIHRob3VzYW5kcyBzZXBhcmF0b3JcclxuICAgICAqICfLmScgICAgICAvLyBEb3QgYWJvdmVcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2VwXHJcbiAgICAgKi9cclxuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuXHJcbiAgICAvKiBSZW1vdmUgdGhlIHRob3VzYW5kIHNlcGFyYXRvciBvbiBmb2N1cywgY3VycmVuY3kgc3ltYm9sIGFuZCBzdWZmaXggb24gZm9jdXNcclxuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxyXG4gICAgICogb24gXCJmb2N1c2luXCIgaXQgYmVjb21lcyBcIjE5OTkuODhcIiBhbmQgYmFjayB0byBcIiQgMSw5OTkuODggc3VmZml4XCIgb24gZm9jdXMgb3V0LlxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG5TZXBcclxuICAgICAqL1xyXG4gICAgbm9TZXBhcmF0b3JPbkZvY3VzOiBmYWxzZSxcclxuXHJcbiAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XHJcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjJcIiwgcmVzdWx0cyBpbiA5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtoc1xyXG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyc1wiLCByZXN1bHRzIGluIDk5LDk5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtocyBzY2FsZWRcclxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcclxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiNFwiLCByZXN1bHRzIGluIDk5OTksOTk5OSw5OTk5IHVzZWQgaW4gc29tZSBBc2lhbiBjb3VudHJpZXNcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBkR3JvdXBcclxuICAgICAqL1xyXG4gICAgZGlnaXRhbEdyb3VwU3BhY2luZzogJzMnLFxyXG5cclxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVycyA6XHJcbiAgICAgKiAnLCcgOiBDb21tYVxyXG4gICAgICogJy4nIDogRG90XHJcbiAgICAgKiAnwrcnIDogTWlkZGxlLWRvdFxyXG4gICAgICogJ9mrJyA6IEFyYWJpYyBkZWNpbWFsIHNlcGFyYXRvclxyXG4gICAgICogJ+KOlicgOiBEZWNpbWFsIHNlcGFyYXRvciBrZXkgc3ltYm9sXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYURlY1xyXG4gICAgICovXHJcbiAgICBkZWNpbWFsQ2hhcmFjdGVyOiAnLicsXHJcblxyXG4gICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbiBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGBkZWNpbWFsQ2hhcmFjdGVyYCB3aGVuIHR5cGVkLlxyXG4gICAgICogVGhpcyBpcyB1c2VkIGJ5IGNvdW50cmllcyB0aGF0IHVzZSBhIGNvbW1hIFwiLFwiIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmVcclxuICAgICAqIGEgcGVyaW9kICdmdWxsIHN0b3AnIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlcnMgKEZyYW5jZSBvciBTcGFpbiBmb3IgaW5zdGFuY2UpLlxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFsdERlY1xyXG4gICAgICovXHJcbiAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6IG51bGwsXHJcblxyXG4gICAgLyogY3VycmVuY3lTeW1ib2wgPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxyXG4gICAgICogTXVzdCBiZSBpbiBxdW90ZXMgY3VycmVuY3lTeW1ib2w6IFwiJFwiXHJcbiAgICAgKiBzcGFjZSB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBjdXJyZW5jeVN5bWJvbDogJyQgJ1xyXG4gICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBjdXJyZW5jeVN5bWJvbDogJyAkJ1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFTaWduXHJcbiAgICAgKi9cclxuICAgIGN1cnJlbmN5U3ltYm9sOiAnJyxcclxuXHJcbiAgICAvKiBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHBsYWNlbWVudCBvZiBjdXJyZW5jeSBzaWduIGFzIGEgcD1wcmVmaXggb3Igcz1zdWZmaXhcclxuICAgICAqIGZvciBwcmVmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwicFwiIChkZWZhdWx0KVxyXG4gICAgICogZm9yIHN1ZmZpeCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBwU2lnblxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdwJyA9PiAncHJlZml4JywgZXRjLilcclxuICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcblxyXG4gICAgLyogUGxhY2VtZW50IG9mIG5lZ2F0aXZlL3Bvc2l0aXZlIHNpZ24gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbmN5U3ltYm9sIG9wdGlvbiBsPWxlZnQsIHI9cmlnaHQsIHA9cHJlZml4ICYgcz1zdWZmaXhcclxuICAgICAqIC0xLDIzNC41NiAgPT4gZGVmYXVsdCBubyBvcHRpb25zIHJlcXVpcmVkXHJcbiAgICAgKiAtJDEsMjM0LjU2ID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCJ9IG9yIHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcImxcIn1cclxuICAgICAqICQtMSwyMzQuNTYgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSAvLyBEZWZhdWx0IGlmIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGlzICdudWxsJyBhbmQgY3VycmVuY3lTeW1ib2wgaXMgbm90IGVtcHR5XHJcbiAgICAgKiAtMSwyMzQuNTYkID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwicFwifSAvLyBEZWZhdWx0IGlmIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGlzICdudWxsJyBhbmQgY3VycmVuY3lTeW1ib2wgaXMgbm90IGVtcHR5XHJcbiAgICAgKiAxLDIzNC41Ni0gID0+IHtuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XHJcbiAgICAgKiAkMSwyMzQuNTYtID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInNcIn1cclxuICAgICAqIDEsMjM0LjU2LSQgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wifVxyXG4gICAgICogMSwyMzQuNTYkLSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn1cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBwTmVnXHJcbiAgICAgKi9cclxuICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9wdGlvbnMgdG8gbW9yZSBleHBsaWNpdCBuYW1lcyAoJ3AnID0+ICdwcmVmaXgnLCBldGMuKVxyXG4gICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IG51bGwsXHJcblxyXG5cclxuICAgIC8qIEFsbG93IHRoZSBwb3NpdGl2ZSBzaWduIHN5bWJvbCBgK2AgdG8gYmUgZGlzcGxheWVkIGZvciBwb3NpdGl2ZSBudW1iZXJzLlxyXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBwb3NpdGl2ZSBzaWduIGlzIG5vdCBzaG93bi5cclxuICAgICAqIFRoZSBzaWduIHBsYWNlbWVudCBpcyBjb250cm9sbGVkIGJ5IHRoZSAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnIG9wdGlvbiwgbWltaWNraW5nIHRoZSBuZWdhdGl2ZSBzaWduIHBsYWNlbWVudCBydWxlcy5cclxuICAgICAqL1xyXG4gICAgc2hvd1Bvc2l0aXZlU2lnbjogZmFsc2UsXHJcblxyXG4gICAgLyogQWRkaXRpb25hbCBzdWZmaXhcclxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIHN1ZmZpeFRleHQ6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBzdWZmaXhUZXh0OiAnIGRvbGxhcnMnXHJcbiAgICAgKiBOdW1lcmljIGNoYXJhY3RlcnMgYW5kIG5lZ2F0aXZlIHNpZ24gbm90IGFsbG93ZWQnXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVN1ZmZpeFxyXG4gICAgICovXHJcbiAgICBzdWZmaXhUZXh0OiAnJyxcclxuXHJcbiAgICAvKiBPdmVycmlkZSBtaW4gbWF4IGxpbWl0c1xyXG4gICAgICogb3ZlcnJpZGVNaW5NYXhMaW1pdHM6IFwiY2VpbGluZ1wiIGFkaGVyZXMgdG8gbWF4aW11bVZhbHVlIGFuZCBpZ25vcmVzIG1pbmltdW1WYWx1ZSBzZXR0aW5nc1xyXG4gICAgICogb3ZlcnJpZGVNaW5NYXhMaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIG1pbmltdW1WYWx1ZSBhbmQgaWdub3JlcyBtYXhpbXVtVmFsdWUgc2V0dGluZ3NcclxuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBvTGltaXRzXHJcbiAgICAgKi9cclxuICAgIG92ZXJyaWRlTWluTWF4TGltaXRzOiBudWxsLFxyXG5cclxuICAgIC8qIE1heGltdW0gcG9zc2libGUgdmFsdWVcclxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcclxuICAgICAqIHZhbHVlIG11c3QgYmUgbGFyZ2VyIHRoYW4gbWluaW11bVZhbHVlXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdk1heFxyXG4gICAgICovXHJcbiAgICBtYXhpbXVtVmFsdWU6ICc5OTk5OTk5OTk5OTk5Ljk5JywgLy8gOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcclxuXHJcbiAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXhpbXVtVmFsdWVcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWluXHJcbiAgICAgKi9cclxuICAgIG1pbmltdW1WYWx1ZTogJy05OTk5OTk5OTk5OTk5Ljk5JywgLy8gLTkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXHJcblxyXG4gICAgLyogTWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgPSB1c2VkIHRvIG92ZXJyaWRlIGRlY2ltYWwgcGxhY2VzIHNldCBieSB0aGUgbWluaW11bVZhbHVlICYgbWF4aW11bVZhbHVlIHZhbHVlc1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG1EZWNcclxuICAgICAqL1xyXG4gICAgZGVjaW1hbFBsYWNlc092ZXJyaWRlOiBudWxsLFxyXG5cclxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxyXG4gICAgICoge2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM6IFwiNVwifSBhbmQgdGhlIGRlZmF1bHQgMiBkZWNpbWFsIHBsYWNlcyB3aXRoIGZvY3VzIFwiMSwwMDAuMTIzNDVcIiB3aXRob3V0IGZvY3VzIFwiMSwwMDAuMTJcIiB0aGUgcmVzdWx0cyBkZXBlbmRzIG9uIHRoZSByb3VuZGluZyBtZXRob2QgdXNlZFxyXG4gICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZURlY1xyXG4gICAgICovXHJcbiAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBudWxsLFxyXG5cclxuICAgIC8qIFRoZSBuZXh0IHRocmVlIG9wdGlvbnMgKHNjYWxlRGl2aXNvciwgc2NhbGVEZWNpbWFsUGxhY2VzICYgc2NhbGVTeW1ib2wpIGhhbmRsZSBzY2FsaW5nIG9mIHRoZSBpbnB1dCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzXHJcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBub24tc2NhbGVkIHZhbHVlIGlzIGhlbGQgaW4gZGF0YSBhbmQgaXQgaXMgYWR2aXNlZCB0aGF0IHlvdSB1c2UgdGhlIFwic2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZVwiIG9wdGlvbiB0byBlbnN1cmUgcmV0YWluaW5nIHRoZSB2YWx1ZVxyXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXHJcbiAgICAgKiBFeGFtcGxlOiB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBzZXQge3NjYWxlRGl2aXNvcjogJzEwMDAnLCBzY2FsZURlY2ltYWxQbGFjZXM6ICcxJywgc2NhbGVTeW1ib2w6ICcgSyd9XHJcbiAgICAgKiBFeGFtcGxlOiBmb2N1c2luIHZhbHVlIFwiMSwxMTEuMTFcIiBmb2N1c291dCB2YWx1ZSBcIjEuMSBLXCJcclxuICAgICAqL1xyXG5cclxuICAgIC8qIFRoZSBgc2NhbGVEaXZpc29yYCBkZWNpZGVzIHRoZSBvbiBmb2N1cyB2YWx1ZSBhbmQgcGxhY2VzIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IG9uIGZvY3Vzb3V0XHJcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cclxuICAgICAqIFRoZSBkaXZpc29yIHZhbHVlIC0gZG9lcyBub3QgbmVlZCB0byBiZSB3aG9sZSBudW1iZXIgYnV0IHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoXHJcbiAgICAgKiBUaGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZnVsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSAnaGlkZGVuJyBkZWNpbWFscy5cclxuICAgICAqL1xyXG4gICAgc2NhbGVEaXZpc29yOiBudWxsLFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgYHNjYWxlRGVjaW1hbFBsYWNlc2Agb3B0aW9uIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZSB3aGVuIG5vdCBpbiBmb2N1cyAtIGZvciB0aGlzIHRvIHdvcmssIGBzY2FsZWREaXZpc29yYCBtdXN0IG5vdCBiZSBgbnVsbGAuXHJcbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIDsgaWYgb21pdHRlZCB0aGUgZGVjaW1hbCBwbGFjZXMgd2lsbCBiZSB0aGUgc2FtZSB3aGVuIHRoZSBpbnB1dCBoYXMgdGhlIGZvY3VzLlxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNjYWxlRGVjaW1hbFxyXG4gICAgICovXHJcbiAgICBzY2FsZURlY2ltYWxQbGFjZXM6IG51bGwsXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBgc2NhbGVTeW1ib2xgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXHJcbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cclxuICAgICAqL1xyXG4gICAgc2NhbGVTeW1ib2w6IG51bGwsXHJcblxyXG4gICAgLyogU2V0IHRvIHRydWUgdG8gYWxsb3cgdGhlIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgdmFsdWUgdG8gYmUgc2F2ZWQgd2l0aCBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICogaWYgaWUgNiBvciA3IHRoZSB2YWx1ZSB3aWxsIGJlIHNhdmVkIGFzIGEgc2Vzc2lvbiBjb29raWVcclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3RvclxyXG4gICAgICovXHJcbiAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlOiBmYWxzZSxcclxuXHJcbiAgICAvKlxyXG4gICAgICogTWFuYWdlIGhvdyBhdXRvTnVtZXJpYyByZWFjdCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIHBhc3RlIGFuIGludmFsaWQgbnVtYmVyLlxyXG4gICAgICogLSAnZXJyb3InICAgIDogKFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IpIFRoZSBpbnB1dCB2YWx1ZSBpcyBub3QgY2hhbmdlZCBhbmQgYW4gZXJyb3IgaXMgb3V0cHV0IGluIHRoZSBjb25zb2xlLlxyXG4gICAgICogLSAnaWdub3JlJyAgIDogaWRlbSB0aGFuICdlcnJvcicsIGJ1dCBmYWlsIHNpbGVudGx5IHdpdGhvdXQgb3V0cHV0dGluZyBhbnkgZXJyb3Ivd2FybmluZyBpbiB0aGUgY29uc29sZS5cclxuICAgICAqIC0gJ2NsYW1wJyAgICA6IGlmIHRoZSBwYXN0ZWQgdmFsdWUgaXMgZWl0aGVyIHRvbyBzbWFsbCBvciB0b28gYmlnIHJlZ2FyZGluZyB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgcmFuZ2UsIHRoZW4gdGhlIHJlc3VsdCBpcyBjbGFtcGVkIHRvIHRob3NlIGxpbWl0cy5cclxuICAgICAqIC0gJ3RydW5jYXRlJyA6IGF1dG9OdW1lcmljIHdpbGwgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdW50aWwgZXZlcnl0aGluZyBpcyBwYXN0ZWQsIG9yIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQuXHJcbiAgICAgKiAgICAgICAgICAgICAgICBUaGUgbm9uLXBhc3RlZCBudW1iZXJzIGFyZSBkcm9wcGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWQgYXQgYWxsLlxyXG4gICAgICogLSAncmVwbGFjZScgIDogYXV0b051bWVyaWMgd2lsbCBmaXJzdCBpbnNlcnQgYXMgbWFueSBwYXN0ZWQgbnVtYmVycyBpdCBjYW4gYXQgdGhlIGluaXRpYWwgY2FyZXQvc2VsZWN0aW9uLCB0aGVuIGlmIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQsIGl0IHdpbGwgdHJ5XHJcbiAgICAgKiAgICAgICAgICAgICAgICB0byByZXBsYWNlIG9uZSBieSBvbmUgdGhlIHJlbWFpbmluZyBpbml0aWFsIG51bWJlcnMgKG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjYXJldCkgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFzdGVkIG51bWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSAxIDogQSBwYXN0ZSBjb250ZW50IHN0YXJ0aW5nIHdpdGggYSBuZWdhdGl2ZSBzaWduICctJyB3aWxsIGJlIGFjY2VwdGVkIGFueXdoZXJlIGluIHRoZSBpbnB1dCwgYW5kIHdpbGwgc2V0IHRoZSByZXN1bHRpbmcgdmFsdWUgYXMgYSBuZWdhdGl2ZSBudW1iZXJcclxuICAgICAqIE5vdGUgMiA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbnVtYmVyIHdpbGwgYmUgYWNjZXB0ZWQsIGV2ZW4gaWYgdGhlIHJlc3QgaXMgZ2liYmVyaXNoIChpZS4gJzEyM2Zvb2JhcjQ1NicpLlxyXG4gICAgICogICAgICAgICAgT25seSB0aGUgZmlyc3QgbnVtYmVyIHdpbGwgYmUgdXNlZCAoaGVyZSAnMTIzJykuXHJcbiAgICAgKiBOb3RlIDMgOiBUaGUgcGFzdGUgZXZlbnQgd29ya3Mgd2l0aCB0aGUgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIG9wdGlvbiB0b28uXHJcbiAgICAgKi9cclxuICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgdXNlIGB0cnVuY2F0ZWAgYXMgdGhlIGRlZmF1bHQgdmFsdWU/XHJcbiAgICBvbkludmFsaWRQYXN0ZTogJ2Vycm9yJyxcclxuXHJcbiAgICAvKiBtZXRob2QgdXNlZCBmb3Igcm91bmRpbmdcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwic1wiLCBSb3VuZC1IYWxmLURvd24gU3ltbWV0cmljIChsb3dlciBjYXNlIHMpXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJhXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiVVwiLCBSb3VuZCBVcCBcIlJvdW5kLUF3YXktRnJvbS1aZXJvXCJcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxyXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRlwiLCBSb3VuZCB0byBGbG9vciBcIlRvd2FyZCBOZWdhdGl2ZSBJbmZpbml0eVwiXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXHJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcclxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkQwNVwiIFJvdW5kcyBkb3duIHRvIG5leHQgLjA1XHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbVJvdW5kXHJcbiAgICAgKi9cclxuICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9wdGlvbnMgdG8gbW9yZSBleHBsaWNpdCBuYW1lcyAoJ1MnID0+ICdSb3VuZEhhbGZVcFN5bW1ldHJpYycsIGV0Yy4pXHJcbiAgICAvL1RPRE8gQWRkIGFuIGBhbi5yb3VuZGluZ01ldGhvZGAgb2JqZWN0IHRoYXQgZW51bSB0aG9zZSBvcHRpb25zIGNsZWFybHlcclxuICAgIHJvdW5kaW5nTWV0aG9kOiAnUycsXHJcblxyXG4gICAgLyogQWxsb3cgcGFkZGluZyB0aGUgZGVjaW1hbCBwbGFjZXMgd2l0aCB6ZXJvc1xyXG4gICAgICogYWxsb3dEZWNpbWFsUGFkZGluZzogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xyXG4gICAgICogYWxsb3dEZWNpbWFsUGFkZGluZzogZmFsc2UgLSBkb2VzIG5vdCBwYWQgd2l0aCB6ZXJvcy5cclxuICAgICAqIE5vdGU6IHNldHRpbmcgYWxsb3dEZWNpbWFsUGFkZGluZyB0byAnZmFsc2UnIHdpbGwgb3ZlcnJpZGUgdGhlICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogdGhhbmtzIHRvIEpvbmFzIEpvaGFuc3NvbiBmb3IgdGhlIHN1Z2dlc3Rpb25cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhUGFkXHJcbiAgICAgKi9cclxuICAgIGFsbG93RGVjaW1hbFBhZGRpbmc6IHRydWUsXHJcblxyXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXHJcbiAgICAgKiBUaG9zZSBicmFja2V0cyBhcmUgdmlzaWJsZSBvbmx5IHdoZW4gdGhlIGZpZWxkIGRvZXMgTk9UIGhhdmUgdGhlIGZvY3VzLlxyXG4gICAgICogVGhlIGxlZnQgYW5kIHJpZ2h0IHN5bWJvbHMgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgc2VwYXJhdGVkIGJ5IGEgY29tbWFcclxuICAgICAqIFRoaXMgb3B0aW9uIGNhbiBiZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlcyA6XHJcbiAgICAgKiBudWxsLCAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlLCB3aGljaCBkZWFjdGl2YXRlIHRoaXMgZmVhdHVyZVxyXG4gICAgICogJygsKScsXHJcbiAgICAgKiAnWyxdJyxcclxuICAgICAqICc8LD4nIG9yXHJcbiAgICAgKiAneyx9J1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG5CcmFja2V0XHJcbiAgICAgKi9cclxuICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9wdGlvbnMgdG8gbW9yZSBleHBsaWNpdCBuYW1lcyAoJygsKScgPT4gJ3BhcmVudGhlc2VzJywgZXRjLilcclxuICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiBudWxsLFxyXG5cclxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxyXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xyXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcInByZXNzXCIgLSBjdXJyZW5jeSBzaWduIGRpc3BsYXlzIG9uIGFueSBrZXkgYmVpbmcgcHJlc3NlZFxyXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcclxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRob3V0IGEgY3VycmVuY3kgc2lnblxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHdFbXB0eVxyXG4gICAgICovXHJcbiAgICBlbXB0eUlucHV0QmVoYXZpb3I6ICdmb2N1cycsXHJcblxyXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXHJcbiAgICAgKiBsZWFkaW5nWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAqIGxlYWRpbmdaZXJvOiBcImRlbnlcIiwgLSBhbGxvd3Mgb25seSBvbmUgbGVhZGluZyB6ZXJvIG9uIHZhbHVlcyBsZXNzIHRoYW4gb25lXHJcbiAgICAgKiBsZWFkaW5nWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBsWmVyb1xyXG4gICAgICovXHJcbiAgICBsZWFkaW5nWmVybzogJ2RlbnknLFxyXG5cclxuICAgIC8qIERldGVybWluZSBpZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIGZvcm1hdHRlZCBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cclxuICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYUZvcm1cclxuICAgICAqL1xyXG4gICAgZm9ybWF0T25QYWdlTG9hZDogdHJ1ZSxcclxuXHJcbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdCB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCwgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICogTm90ZSA6IElmIHRoZSBjdXJyZW5jeSBzeW1ib2wgaXMgYmV0d2VlbiB0aGUgbnVtZXJpYyB2YWx1ZSBhbmQgdGhlIG5lZ2F0aXZlIHNpZ24sIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNOdW1iZXJcclxuICAgICAqL1xyXG4gICAgc2VsZWN0TnVtYmVyT25seTogZmFsc2UsXHJcblxyXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xyXG4gICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICogZXhhbXBsZXM6XHJcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiBcIlwifVxyXG4gICAgICogdmFsdWU9MTIzNC41NiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6ICcxMjM0LjU2J31cclxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhbkRlZmF1bHRcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IG51bGwsXHJcblxyXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxyXG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxyXG4gICAgICogcmV2aWV3IHRoZSAndW5TZXQnIG1ldGhvZCBmb3Igb3RoZXIgZm9ybWF0c1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHVuU2V0T25TdWJtaXRcclxuICAgICAqL1xyXG4gICAgdW5mb3JtYXRPblN1Ym1pdDogZmFsc2UsXHJcblxyXG4gICAgLyogQWxsb3dzIHRoZSBvdXRwdXQgdG8gYmUgaW4gdGhlIGxvY2FsZSBmb3JtYXQgdmlhIHRoZSBcImdldFwiLCBcImdldFN0cmluZ1wiICYgXCJnZXRBcnJheVwiIG1ldGhvZHNcclxuICAgICAqIG51bGwgb3IgJ3N0cmluZycgPT4gJ25ubm4ubm4nIG9yICctbm5ubi5ubicgYXMgdGV4dCB0eXBlLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxyXG4gICAgICogJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxyXG4gICAgICogJywnIG9yICctLCcgICAgICA9PiAnbm5ubixubicgb3IgJy1ubm5uLG5uJ1xyXG4gICAgICogJy4tJyAgICAgICAgICAgICA9PiAnbm5ubi5ubicgb3IgJ25ubm4ubm4tJ1xyXG4gICAgICogJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG91dHB1dFR5cGVcclxuICAgICAqL1xyXG4gICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxyXG5cclxuICAgIC8qIERlZmluZXMgaWYgd2FybmluZ3Mgc2hvdWxkIGJlIHNob3duXHJcbiAgICAgKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxyXG4gICAgICogdHJ1ZSA9PiBhbGwgd2FybmluZyBhcmUgc2hvd25cclxuICAgICAqIGZhbHNlID0+IG5vIHdhcm5pbmdzIGFyZSBzaG93biwgb25seSB0aGUgdGhyb3duIGVycm9yc1xyXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRlYnVnXHJcbiAgICAgKi9cclxuICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBvcHRpb24gaXMgdGhlICdzdHJpY3QgbW9kZScgKGFrYSAnZGVidWcnIG1vZGUpLCB3aGljaCBhbGxvd3MgYXV0b051bWVyaWMgdG8gc3RyaWN0bHkgYW5hbHlzZSB0aGUgb3B0aW9ucyBwYXNzZWQsIGFuZCBmYWlscyBpZiBhbiB1bmtub3duIG9wdGlvbnMgaXMgdXNlZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxyXG4gICAgICogWW91IHNob3VsZCBzZXQgdGhhdCB0byAnVFJVRScgaWYgeW91IHdhbnQgdG8gbWFrZSBzdXJlIHlvdSBhcmUgb25seSB1c2luZyAncHVyZScgYXV0b051bWVyaWMgc2V0dGluZ3Mgb2JqZWN0cyBpbiB5b3VyIGNvZGUuXHJcbiAgICAgKiBJZiB5b3Ugc2VlIHVuY2F1Z2h0IGVycm9ycyBpbiB0aGUgY29uc29sZSBhbmQgeW91ciBjb2RlIHN0YXJ0cyB0byBmYWlsLCB0aGlzIG1lYW5zIHNvbWVob3cgdGhvc2Ugb3B0aW9ucyBnZXRzIGNvcnJ1cHRlZCBieSBhbm90aGVyIHByb2dyYW0uXHJcbiAgICAgKi9cclxuICAgIGZhaWxPblVua25vd25PcHRpb246IGZhbHNlLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxyXG4gKiAvL1RPRE8gUmVwbGFjZSBldmVyeSBjYWxsIHRvIHRoaXMgb2JqZWN0IHdpdGggYSBjYWxsIHRvIGBrZXlOYW1lYFxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxuY29uc3Qga2V5Q29kZSA9IHtcclxuICAgIEJhY2tzcGFjZTogICAgICA4LFxyXG4gICAgVGFiOiAgICAgICAgICAgIDksXHJcbiAgICBFbnRlcjogICAgICAgICAgMTMsXHJcbiAgICBTaGlmdDogICAgICAgICAgMTYsXHJcbiAgICBDdHJsOiAgICAgICAgICAgMTcsXHJcbiAgICBBbHQ6ICAgICAgICAgICAgMTgsXHJcbiAgICBQYXVzZUJyZWFrOiAgICAgMTksXHJcbiAgICBDYXBzTG9jazogICAgICAgMjAsXHJcbiAgICBFc2M6ICAgICAgICAgICAgMjcsXHJcbiAgICBTcGFjZTogICAgICAgICAgMzIsXHJcbiAgICBQYWdlVXA6ICAgICAgICAgMzMsXHJcbiAgICBQYWdlRG93bjogICAgICAgMzQsXHJcbiAgICBFbmQ6ICAgICAgICAgICAgMzUsXHJcbiAgICBIb21lOiAgICAgICAgICAgMzYsXHJcbiAgICBMZWZ0QXJyb3c6ICAgICAgMzcsXHJcbiAgICBVcEFycm93OiAgICAgICAgMzgsXHJcbiAgICBSaWdodEFycm93OiAgICAgMzksXHJcbiAgICBEb3duQXJyb3c6ICAgICAgNDAsXHJcbiAgICBJbnNlcnQ6ICAgICAgICAgNDUsXHJcbiAgICBEZWxldGU6ICAgICAgICAgNDYsXHJcbiAgICBudW0wOiAgICAgICAgICAgNDgsXHJcbiAgICBudW0xOiAgICAgICAgICAgNDksXHJcbiAgICBudW0yOiAgICAgICAgICAgNTAsXHJcbiAgICBudW0zOiAgICAgICAgICAgNTEsXHJcbiAgICBudW00OiAgICAgICAgICAgNTIsXHJcbiAgICBudW01OiAgICAgICAgICAgNTMsXHJcbiAgICBudW02OiAgICAgICAgICAgNTQsXHJcbiAgICBudW03OiAgICAgICAgICAgNTUsXHJcbiAgICBudW04OiAgICAgICAgICAgNTYsXHJcbiAgICBudW05OiAgICAgICAgICAgNTcsXHJcbiAgICBhOiAgICAgICAgICAgICAgNjUsXHJcbiAgICBiOiAgICAgICAgICAgICAgNjYsXHJcbiAgICBjOiAgICAgICAgICAgICAgNjcsXHJcbiAgICBkOiAgICAgICAgICAgICAgNjgsXHJcbiAgICBlOiAgICAgICAgICAgICAgNjksXHJcbiAgICBmOiAgICAgICAgICAgICAgNzAsXHJcbiAgICBnOiAgICAgICAgICAgICAgNzEsXHJcbiAgICBoOiAgICAgICAgICAgICAgNzIsXHJcbiAgICBpOiAgICAgICAgICAgICAgNzMsXHJcbiAgICBqOiAgICAgICAgICAgICAgNzQsXHJcbiAgICBrOiAgICAgICAgICAgICAgNzUsXHJcbiAgICBsOiAgICAgICAgICAgICAgNzYsXHJcbiAgICBtOiAgICAgICAgICAgICAgNzcsXHJcbiAgICBuOiAgICAgICAgICAgICAgNzgsXHJcbiAgICBvOiAgICAgICAgICAgICAgNzksXHJcbiAgICBwOiAgICAgICAgICAgICAgODAsXHJcbiAgICBxOiAgICAgICAgICAgICAgODEsXHJcbiAgICByOiAgICAgICAgICAgICAgODIsXHJcbiAgICBzOiAgICAgICAgICAgICAgODMsXHJcbiAgICB0OiAgICAgICAgICAgICAgODQsXHJcbiAgICB1OiAgICAgICAgICAgICAgODUsXHJcbiAgICB2OiAgICAgICAgICAgICAgODYsXHJcbiAgICB3OiAgICAgICAgICAgICAgODcsXHJcbiAgICB4OiAgICAgICAgICAgICAgODgsXHJcbiAgICB5OiAgICAgICAgICAgICAgODksXHJcbiAgICB6OiAgICAgICAgICAgICAgOTAsXHJcbiAgICBXaW5kb3dzOiAgICAgICAgOTEsXHJcbiAgICBSaWdodENsaWNrOiAgICAgOTMsXHJcbiAgICBudW1wYWQwOiAgICAgICAgOTYsXHJcbiAgICBudW1wYWQxOiAgICAgICAgOTcsXHJcbiAgICBudW1wYWQyOiAgICAgICAgOTgsXHJcbiAgICBudW1wYWQzOiAgICAgICAgOTksXHJcbiAgICBudW1wYWQ0OiAgICAgICAgMTAwLFxyXG4gICAgbnVtcGFkNTogICAgICAgIDEwMSxcclxuICAgIG51bXBhZDY6ICAgICAgICAxMDIsXHJcbiAgICBudW1wYWQ3OiAgICAgICAgMTAzLFxyXG4gICAgbnVtcGFkODogICAgICAgIDEwNCxcclxuICAgIG51bXBhZDk6ICAgICAgICAxMDUsXHJcbiAgICBNdWx0aXBseU51bXBhZDogMTA2LFxyXG4gICAgUGx1c051bXBhZDogICAgIDEwNyxcclxuICAgIE1pbnVzTnVtcGFkOiAgICAxMDksXHJcbiAgICBEb3ROdW1wYWQ6ICAgICAgMTEwLFxyXG4gICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcclxuICAgIEYxOiAgICAgICAgICAgICAxMTIsXHJcbiAgICBGMjogICAgICAgICAgICAgMTEzLFxyXG4gICAgRjM6ICAgICAgICAgICAgIDExNCxcclxuICAgIEY0OiAgICAgICAgICAgICAxMTUsXHJcbiAgICBGNTogICAgICAgICAgICAgMTE2LFxyXG4gICAgRjY6ICAgICAgICAgICAgIDExNyxcclxuICAgIEY3OiAgICAgICAgICAgICAxMTgsXHJcbiAgICBGODogICAgICAgICAgICAgMTE5LFxyXG4gICAgRjk6ICAgICAgICAgICAgIDEyMCxcclxuICAgIEYxMDogICAgICAgICAgICAxMjEsXHJcbiAgICBGMTE6ICAgICAgICAgICAgMTIyLFxyXG4gICAgRjEyOiAgICAgICAgICAgIDEyMyxcclxuICAgIE51bUxvY2s6ICAgICAgICAxNDQsXHJcbiAgICBTY3JvbGxMb2NrOiAgICAgMTQ1LFxyXG4gICAgTXlDb21wdXRlcjogICAgIDE4MixcclxuICAgIE15Q2FsY3VsYXRvcjogICAxODMsXHJcbiAgICBTZW1pY29sb246ICAgICAgMTg2LFxyXG4gICAgRXF1YWw6ICAgICAgICAgIDE4NyxcclxuICAgIENvbW1hOiAgICAgICAgICAxODgsXHJcbiAgICBIeXBoZW46ICAgICAgICAgMTg5LFxyXG4gICAgRG90OiAgICAgICAgICAgIDE5MCxcclxuICAgIFNsYXNoOiAgICAgICAgICAxOTEsXHJcbiAgICBCYWNrcXVvdGU6ICAgICAgMTkyLFxyXG4gICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcclxuICAgIEJhY2tzbGFzaDogICAgICAyMjAsXHJcbiAgICBSaWdodEJyYWNrZXQ6ICAgMjIxLFxyXG4gICAgUXVvdGU6ICAgICAgICAgIDIyMixcclxuICAgIENvbW1hbmQ6ICAgICAgICAyMjQsXHJcbiAgICBBbmRyb2lkRGVmYXVsdDogMjI5LCAvLyBBbmRyb2lkIENocm9tZSByZXR1cm5zIHRoZSBzYW1lIGtleWNvZGUgbnVtYmVyIDIyOSBmb3IgYWxsIGtleXMgcHJlc3NlZFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleSBuYW1lIChhcyBzZXQgaW4gS2V5Ym9hcmRFdmVudC5rZXkpLlxyXG4gKiBUaG9zZSBuYW1lcyBhcmUgbGlzdGVkIGhlcmUgOlxyXG4gKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xyXG4gKi9cclxuY29uc3Qga2V5TmFtZSA9IHtcclxuICAgIC8vIFNwZWNpYWwgdmFsdWVzXHJcbiAgICBVbmlkZW50aWZpZWQ6ICAgJ1VuaWRlbnRpZmllZCcsXHJcblxyXG4gICAgLy8gTW9kaWZpZXIga2V5c1xyXG4gICAgQWx0OiAgICAgICAgICAgICdBbHQnLFxyXG4gICAgQWx0R3I6ICAgICAgICAgICdBbHRHcmFwaCcsXHJcbiAgICBDYXBzTG9jazogICAgICAgJ0NhcHNMb2NrJywgLy8gVW5kZXIgQ2hyb21lLCBlLmtleSBpcyBlbXB0eSBmb3IgQ2Fwc0xvY2tcclxuICAgIEN0cmw6ICAgICAgICAgICAnQ29udHJvbCcsXHJcbiAgICBGbjogICAgICAgICAgICAgJ0ZuJyxcclxuICAgIEZuTG9jazogICAgICAgICAnRm5Mb2NrJyxcclxuICAgIEh5cGVyOiAgICAgICAgICAnSHlwZXInLCAvLyAnT1MnIHVuZGVyIEZpcmVmb3hcclxuICAgIE1ldGE6ICAgICAgICAgICAnTWV0YScsIC8vIFRoZSBXaW5kb3dzLCBDb21tYW5kIG9yIOKMmCBrZXkgLy8gJ09TJyB1bmRlciBGaXJlZm94IGFuZCBJRTlcclxuICAgIFdpbmRvd3M6ICAgICAgICAnTWV0YScsIC8vIFRoaXMgaXMgYSBub24tb2ZmaWNpYWwga2V5IG5hbWVcclxuICAgIENvbW1hbmQ6ICAgICAgICAnTWV0YScsIC8vIFRoaXMgaXMgYSBub24tb2ZmaWNpYWwga2V5IG5hbWVcclxuICAgIE51bUxvY2s6ICAgICAgICAnTnVtTG9jaycsXHJcbiAgICBTY3JvbGxMb2NrOiAgICAgJ1Njcm9sbExvY2snLFxyXG4gICAgU2hpZnQ6ICAgICAgICAgICdTaGlmdCcsXHJcbiAgICBTdXBlcjogICAgICAgICAgJ1N1cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XHJcbiAgICBTeW1ib2w6ICAgICAgICAgJ1N5bWJvbCcsXHJcbiAgICBTeW1ib2xMb2NrOiAgICAgJ1N5bWJvbExvY2snLFxyXG5cclxuICAgIC8vIFdoaXRlc3BhY2Uga2V5c1xyXG4gICAgRW50ZXI6ICAgICAgICAgICdFbnRlcicsXHJcbiAgICBUYWI6ICAgICAgICAgICAgJ1RhYicsXHJcbiAgICBTcGFjZTogICAgICAgICAgJyAnLCAvLyAnU3BhY2ViYXInIGZvciBGaXJlZm94IDwzNywgYW5kIElFOVxyXG5cclxuICAgIC8vIE5hdmlnYXRpb24ga2V5c1xyXG4gICAgRG93bkFycm93OiAgICAgICdBcnJvd0Rvd24nLCAvLyAnRG93bicgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgTGVmdEFycm93OiAgICAgICdBcnJvd0xlZnQnLCAvLyAnTGVmdCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgUmlnaHRBcnJvdzogICAgICdBcnJvd1JpZ2h0JywgLy8gJ1JpZ2h0JyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBVcEFycm93OiAgICAgICAgJ0Fycm93VXAnLCAvLyAnVXAnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEVuZDogICAgICAgICAgICAnRW5kJyxcclxuICAgIEhvbWU6ICAgICAgICAgICAnSG9tZScsXHJcbiAgICBQYWdlRG93bjogICAgICAgJ1BhZ2VEb3duJyxcclxuICAgIFBhZ2VVcDogICAgICAgICAnUGFnZVVwJyxcclxuXHJcbiAgICAvLyBFZGl0aW5nIGtleXNcclxuICAgIEJhY2tzcGFjZTogICAgICAnQmFja3NwYWNlJyxcclxuICAgIENsZWFyOiAgICAgICAgICAnQ2xlYXInLFxyXG4gICAgQ29weTogICAgICAgICAgICdDb3B5JyxcclxuICAgIENyU2VsOiAgICAgICAgICAnQ3JTZWwnLCAvLyAnQ3JzZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEN1dDogICAgICAgICAgICAnQ3V0JyxcclxuICAgIERlbGV0ZTogICAgICAgICAnRGVsZXRlJywgLy8gJ0RlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgRXJhc2VFb2Y6ICAgICAgICdFcmFzZUVvZicsXHJcbiAgICBFeFNlbDogICAgICAgICAgJ0V4U2VsJywgLy8gJ0V4c2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XHJcbiAgICBJbnNlcnQ6ICAgICAgICAgJ0luc2VydCcsXHJcbiAgICBQYXN0ZTogICAgICAgICAgJ1Bhc3RlJyxcclxuICAgIFJlZG86ICAgICAgICAgICAnUmVkbycsXHJcbiAgICBVbmRvOiAgICAgICAgICAgJ1VuZG8nLFxyXG5cclxuICAgIC8vIFVJIGtleXNcclxuICAgIEFjY2VwdDogICAgICAgICAnQWNjZXB0JyxcclxuICAgIEFnYWluOiAgICAgICAgICAnQWdhaW4nLFxyXG4gICAgQXR0bjogICAgICAgICAgICdBdHRuJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3gsIENocm9tZSwgYW5kIElFOSAoJ0thbmFNb2RlJyB3aGVuIHVzaW5nIHRoZSBKYXBhbmVzZSBrZXlib2FyZCBsYXlvdXQpXHJcbiAgICBDYW5jZWw6ICAgICAgICAgJ0NhbmNlbCcsXHJcbiAgICBDb250ZXh0TWVudTogICAgJ0NvbnRleHRNZW51JywgLy8gJ0FwcHMnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcclxuICAgIEVzYzogICAgICAgICAgICAnRXNjYXBlJywgLy8gJ0VzYycgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgRXhlY3V0ZTogICAgICAgICdFeGVjdXRlJyxcclxuICAgIEZpbmQ6ICAgICAgICAgICAnRmluZCcsXHJcbiAgICBGaW5pc2g6ICAgICAgICAgJ0ZpbmlzaCcsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94LCBDaHJvbWUsIGFuZCBJRTkgKCdLYXRha2FuYScgd2hlbiB1c2luZyB0aGUgSmFwYW5lc2Uga2V5Ym9hcmQgbGF5b3V0KVxyXG4gICAgSGVscDogICAgICAgICAgICdIZWxwJyxcclxuICAgIFBhdXNlOiAgICAgICAgICAnUGF1c2UnLFxyXG4gICAgUGxheTogICAgICAgICAgICdQbGF5JyxcclxuICAgIFByb3BzOiAgICAgICAgICAnUHJvcHMnLFxyXG4gICAgU2VsZWN0OiAgICAgICAgICdTZWxlY3QnLFxyXG4gICAgWm9vbUluOiAgICAgICAgICdab29tSW4nLFxyXG4gICAgWm9vbU91dDogICAgICAgICdab29tT3V0JyxcclxuXHJcbiAgICAvLyBEZXZpY2Uga2V5c1xyXG4gICAgQnJpZ2h0bmVzc0Rvd246ICdCcmlnaHRuZXNzRG93bicsXHJcbiAgICBCcmlnaHRuZXNzVXA6ICAgJ0JyaWdodG5lc3NVcCcsXHJcbiAgICBFamVjdDogICAgICAgICAgJ0VqZWN0JyxcclxuICAgIExvZ09mZjogICAgICAgICAnTG9nT2ZmJyxcclxuICAgIFBvd2VyOiAgICAgICAgICAnUG93ZXInLFxyXG4gICAgUG93ZXJPZmY6ICAgICAgICdQb3dlck9mZicsXHJcbiAgICBQcmludFNjcmVlbjogICAgJ1ByaW50U2NyZWVuJyxcclxuICAgIEhpYmVybmF0ZTogICAgICAnSGliZXJuYXRlJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zN1xyXG4gICAgU3RhbmRieTogICAgICAgICdTdGFuZGJ5JywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxyXG4gICAgV2FrZVVwOiAgICAgICAgICdXYWtlVXAnLFxyXG5cclxuICAgIC8vIElNRSBhbmQgY29tcG9zaXRpb24ga2V5c1xyXG4gICAgQ29tcG9zZTogICAgICAgICdDb21wb3NlJyxcclxuICAgIERlYWQ6ICAgICAgICAgICAnRGVhZCcsXHJcblxyXG4gICAgLy8gRnVuY3Rpb24ga2V5c1xyXG4gICAgRjE6ICAgICAgICAgICAgICdGMScsXHJcbiAgICBGMjogICAgICAgICAgICAgJ0YyJyxcclxuICAgIEYzOiAgICAgICAgICAgICAnRjMnLFxyXG4gICAgRjQ6ICAgICAgICAgICAgICdGNCcsXHJcbiAgICBGNTogICAgICAgICAgICAgJ0Y1JyxcclxuICAgIEY2OiAgICAgICAgICAgICAnRjYnLFxyXG4gICAgRjc6ICAgICAgICAgICAgICdGNycsXHJcbiAgICBGODogICAgICAgICAgICAgJ0Y4JyxcclxuICAgIEY5OiAgICAgICAgICAgICAnRjknLFxyXG4gICAgRjEwOiAgICAgICAgICAgICdGMTAnLFxyXG4gICAgRjExOiAgICAgICAgICAgICdGMTEnLFxyXG4gICAgRjEyOiAgICAgICAgICAgICdGMTInLFxyXG5cclxuICAgIC8vIERvY3VtZW50IGtleXNcclxuICAgIFByaW50OiAgICAgICAgICAnUHJpbnQnLFxyXG5cclxuICAgIC8vICdOb3JtYWwnIGtleXNcclxuICAgIG51bTA6ICAgICAgICAgICAnMCcsXHJcbiAgICBudW0xOiAgICAgICAgICAgJzEnLFxyXG4gICAgbnVtMjogICAgICAgICAgICcyJyxcclxuICAgIG51bTM6ICAgICAgICAgICAnMycsXHJcbiAgICBudW00OiAgICAgICAgICAgJzQnLFxyXG4gICAgbnVtNTogICAgICAgICAgICc1JyxcclxuICAgIG51bTY6ICAgICAgICAgICAnNicsXHJcbiAgICBudW03OiAgICAgICAgICAgJzcnLFxyXG4gICAgbnVtODogICAgICAgICAgICc4JyxcclxuICAgIG51bTk6ICAgICAgICAgICAnOScsXHJcbiAgICBudW1wYWQwOiAgICAgICAgJzAnLFxyXG4gICAgbnVtcGFkMTogICAgICAgICcxJyxcclxuICAgIG51bXBhZDI6ICAgICAgICAnMicsXHJcbiAgICBudW1wYWQzOiAgICAgICAgJzMnLFxyXG4gICAgbnVtcGFkNDogICAgICAgICc0JyxcclxuICAgIG51bXBhZDU6ICAgICAgICAnNScsXHJcbiAgICBudW1wYWQ2OiAgICAgICAgJzYnLFxyXG4gICAgbnVtcGFkNzogICAgICAgICc3JyxcclxuICAgIG51bXBhZDg6ICAgICAgICAnOCcsXHJcbiAgICBudW1wYWQ5OiAgICAgICAgJzknLFxyXG4gICAgYTogICAgICAgICAgICAgICdhJyxcclxuICAgIGI6ICAgICAgICAgICAgICAnYicsXHJcbiAgICBjOiAgICAgICAgICAgICAgJ2MnLFxyXG4gICAgZDogICAgICAgICAgICAgICdkJyxcclxuICAgIGU6ICAgICAgICAgICAgICAnZScsXHJcbiAgICBmOiAgICAgICAgICAgICAgJ2YnLFxyXG4gICAgZzogICAgICAgICAgICAgICdnJyxcclxuICAgIGg6ICAgICAgICAgICAgICAnaCcsXHJcbiAgICBpOiAgICAgICAgICAgICAgJ2knLFxyXG4gICAgajogICAgICAgICAgICAgICdqJyxcclxuICAgIGs6ICAgICAgICAgICAgICAnaycsXHJcbiAgICBsOiAgICAgICAgICAgICAgJ2wnLFxyXG4gICAgbTogICAgICAgICAgICAgICdtJyxcclxuICAgIG46ICAgICAgICAgICAgICAnbicsXHJcbiAgICBvOiAgICAgICAgICAgICAgJ28nLFxyXG4gICAgcDogICAgICAgICAgICAgICdwJyxcclxuICAgIHE6ICAgICAgICAgICAgICAncScsXHJcbiAgICByOiAgICAgICAgICAgICAgJ3InLFxyXG4gICAgczogICAgICAgICAgICAgICdzJyxcclxuICAgIHQ6ICAgICAgICAgICAgICAndCcsXHJcbiAgICB1OiAgICAgICAgICAgICAgJ3UnLFxyXG4gICAgdjogICAgICAgICAgICAgICd2JyxcclxuICAgIHc6ICAgICAgICAgICAgICAndycsXHJcbiAgICB4OiAgICAgICAgICAgICAgJ3gnLFxyXG4gICAgeTogICAgICAgICAgICAgICd5JyxcclxuICAgIHo6ICAgICAgICAgICAgICAneicsXHJcbiAgICBNdWx0aXBseU51bXBhZDogJyonLFxyXG4gICAgUGx1c051bXBhZDogICAgICcrJyxcclxuICAgIE1pbnVzTnVtcGFkOiAgICAnLScsXHJcbiAgICBEb3ROdW1wYWQ6ICAgICAgJy4nLFxyXG4gICAgU2xhc2hOdW1wYWQ6ICAgICcvJyxcclxuICAgIFNlbWljb2xvbjogICAgICAnOycsXHJcbiAgICBFcXVhbDogICAgICAgICAgJz0nLFxyXG4gICAgQ29tbWE6ICAgICAgICAgICcsJyxcclxuICAgIEh5cGhlbjogICAgICAgICAnLScsXHJcbiAgICBNaW51czogICAgICAgICAgJy0nLFxyXG4gICAgUGx1czogICAgICAgICAgICcrJyxcclxuICAgIERvdDogICAgICAgICAgICAnLicsXHJcbiAgICBTbGFzaDogICAgICAgICAgJy8nLFxyXG4gICAgQmFja3F1b3RlOiAgICAgICdgJyxcclxuICAgIExlZnRCcmFja2V0OiAgICAnWycsXHJcbiAgICBSaWdodEJyYWNrZXQ6ICAgJ10nLFxyXG4gICAgQmFja3NsYXNoOiAgICAgICdcXFxcJyxcclxuICAgIFF1b3RlOiAgICAgICAgICBcIidcIixcclxuICAgIE51bXBhZERvdDogICAgICAnLicsXHJcbiAgICBOdW1wYWREb3RBbHQ6ICAgJywnLCAvLyBNb2Rlcm4gYnJvd3NlcnMgYXV0b21hdGljYWxseSBhZGFwdCB0aGUgY2hhcmFjdGVyIHNlbnQgYnkgdGhpcyBrZXkgdG8gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IGxhbmd1YWdlXHJcbiAgICBOdW1wYWRNdWx0aXBseTogJyonLFxyXG4gICAgTnVtcGFkUGx1czogICAgICcrJyxcclxuICAgIE51bXBhZE1pbnVzOiAgICAnLScsXHJcbiAgICBOdW1wYWRTbGFzaDogICAgJy8nLFxyXG4gICAgTnVtcGFkRG90T2Jzb2xldGVCcm93c2VyczogICAgICAnRGVjaW1hbCcsXHJcbiAgICBOdW1wYWRNdWx0aXBseU9ic29sZXRlQnJvd3NlcnM6ICdNdWx0aXBseScsXHJcbiAgICBOdW1wYWRQbHVzT2Jzb2xldGVCcm93c2VyczogICAgICdBZGQnLFxyXG4gICAgTnVtcGFkTWludXNPYnNvbGV0ZUJyb3dzZXJzOiAgICAnU3VidHJhY3QnLFxyXG4gICAgTnVtcGFkU2xhc2hPYnNvbGV0ZUJyb3dzZXJzOiAgICAnRGl2aWRlJyxcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRNaW5pbXVtVmFsdWUgICAgID0gJy05OTk5OTk5OTk5OTkuOTknO1xyXG5jb25zdCBkZWZhdWx0TWF4aW11bVZhbHVlICAgICA9ICc5OTk5OTk5OTk5OTkuOTknO1xyXG5jb25zdCBkZWZhdWx0Um91bmRpbmdNZXRob2QgICA9ICdVJztcclxuY29uc3QgZGVmYXVsdExlYWRpbmdaZXJvICAgICAgPSAnZGVueSc7XHJcbmNvbnN0IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5ID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBQcmVkZWZpbmVkIG9wdGlvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBsYW5ndWFnZXNcclxuICovXHJcbmNvbnN0IGxhbmd1YWdlT3B0aW9uID0ge1xyXG4gICAgRnJlbmNoOiB7IC8vIEZyYW7Dp2Fpc1xyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgIDogJy4nLCAvLyBvciAnXFx1MjAyZidcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICA6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICA6ICdcXHUyMDJm4oKsJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICA6ICdzJyxcclxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgIDogZGVmYXVsdExlYWRpbmdaZXJvLFxyXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgTm9ydGhBbWVyaWNhbjoge1xyXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICA6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgIDogJyQnLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXHJcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgIH0sXHJcbiAgICBCcml0aXNoOiB7XHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnwqMnLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXHJcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgIH0sXHJcbiAgICBTd2lzczogeyAvLyBTdWlzc2VcclxuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgIDogYCdgLFxyXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICA6ICdcXHUyMDJmQ0hGJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3MnLFxyXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgIDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXHJcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNYXhpbXVtVmFsdWUsXHJcbiAgICB9LFxyXG4gICAgSmFwYW5lc2U6IHsgLy8g5pel5pys6KqeXHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnwqUnLFxyXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXHJcbiAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxyXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXHJcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcclxuICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcclxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgIH0sXHJcbiAgICBUdXJraXNoOiB7XHJcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXI6ICcsJyxcclxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6ICcuJyxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbDogJ+KAr+KCuicsXHJcbiAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6ICdzJyxcclxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5OiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcclxuICAgICAgICByb3VuZGluZ01ldGhvZDogZGVmYXVsdFJvdW5kaW5nTWV0aG9kLFxyXG4gICAgICAgIGxlYWRpbmdaZXJvOiBkZWZhdWx0TGVhZGluZ1plcm8sXHJcbiAgICAgICAgbWluaW11bVZhbHVlOiBkZWZhdWx0TWluaW11bVZhbHVlLFxyXG4gICAgICAgIG1heGltdW1WYWx1ZTogZGVmYXVsdE1heGltdW1WYWx1ZSxcclxuICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogJ3AnXHJcbiAgICB9XHJcbn07XHJcbmxhbmd1YWdlT3B0aW9uLlNwYW5pc2ggPSBsYW5ndWFnZU9wdGlvbi5GcmVuY2g7IC8vIEVzcGHDsW9sIChpZGVtIEZyZW5jaClcclxubGFuZ3VhZ2VPcHRpb24uQ2hpbmVzZSA9IGxhbmd1YWdlT3B0aW9uLkphcGFuZXNlOyAvLyDkuK3lm73oqp4gKENoaW5lc2UpXHJcblxyXG4vKipcclxuICogVU1EIHN0cnVjdHVyZVxyXG4gKi9cclxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcclxuICAgIC8vVE9ETyBUaGlzIHN1cmVseSBjYW4gYmUgaW1wcm92ZWQgYnkgbGV0dGluZyB3ZWJwYWNrIHRha2UgY2FyZSBvZiBnZW5lcmF0aW5nIHRoaXMgVU1EIHBhcnRcclxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcclxufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcbn0gZWxzZSB7XHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xyXG59XHJcbn0oJCA9PiB7XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyBudWxsXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIG51bGwsIEZBTFNFIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWRcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBGQUxTRSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIG51bGwgb3IgZW1wdHlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkKDApIHx8ICcnID09PSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBTdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHN0clxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnYm9vbGVhbic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nICd0cnVlJyBvciAnZmFsc2UnXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFueSBjYXNlcyBmb3IgdGhvc2Ugc3RyaW5ncy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVHJ1ZU9yRmFsc2VTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gbG93ZXJjYXNlVmFsdWUgPT09ICd0cnVlJyB8fCBsb3dlcmNhc2VWYWx1ZSA9PT0gJ2ZhbHNlJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc09iamVjdChyZWZlcmVuY2UpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHJlZmVyZW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XHJcbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QgYW5kIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5LW9iamVjdC10ZXN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgbnVtYmVyIChvciBhIG51bWJlciB3cml0dGVuIGFzIGEgc3RyaW5nKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc051bWJlcihuKSB7XHJcbiAgICAgICAgcmV0dXJuICFpc0FycmF5KG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciAoYW5kIG5vdCBhIGZsb2F0KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0ludChuKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiBwYXJzZUZsb2F0KG4pID09PSBwYXJzZUludChuLCAxMCkgJiYgIWlzTmFOKG4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBwYXN0ZWQgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR8WE1MfCp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByZXBhcmVQYXN0ZWRUZXh0KHRleHQsIGhvbGRlcikge1xyXG4gICAgICAgIHJldHVybiBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModGV4dCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUsIHRydWUpLnJlcGxhY2UoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzdHJpbmcgYHN0cmAgY29udGFpbnMgdGhlIHN0cmluZyBgbmVlZGxlYFxyXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcclxuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgIWlzU3RyaW5nKG5lZWRsZSkgfHwgc3RyID09PSAnJyB8fCBuZWVkbGUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgbmVlZGxlYCBpcyBpbiB0aGUgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG5lZWRsZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xyXG4gICAgICAgIGlmICghaXNBcnJheShhcnJheSkgfHwgYXJyYXkgPT09IFtdIHx8IGlzVW5kZWZpbmVkKG5lZWRsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBhcnJcclxuICAgICAqIEB0aHJvd3MgRXJyb3JcclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHsgLy8gTWFrZSBzdXJlIGFuIGFycmF5IGhhcyBhIGNsYXNzIGF0dHJpYnV0ZSBvZiBbb2JqZWN0IEFycmF5XVxyXG4gICAgICAgICAgICAvLyBUZXN0IHBhc3NlZCwgbm93IGNoZWNrIGlmIGlzIGFuIEFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICAvLyBmdW5jdGlvbiBoYXNEZWNpbWFscyhzdHIpIHtcclxuICAgIC8vICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcclxuICAgIC8vICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtpbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMoc3RyKSB7XHJcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxQYXJ0Lmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjb2RlIGZvciB0aGUga2V5IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE51bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24ga2V5Q29kZU51bWJlcihldmVudCkge1xyXG4gICAgICAgIC8vIGBldmVudC5rZXlDb2RlYCBhbmQgYGV2ZW50LndoaWNoYCBhcmUgZGVwcmVjYXRlZCwgYEtleWJvYXJkRXZlbnQua2V5YCAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KSBtdXN0IGJlIHVzZWQgbm93XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjaGFyYWN0ZXIgZnJvbSB0aGUgZXZlbnQga2V5IGNvZGUuXHJcbiAgICAgKiBAZXhhbXBsZSBjaGFyYWN0ZXIoNTApID0+ICcyJ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGFyYWN0ZXIoZXZlbnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmtleSA9PT0gJ3VuZGVmaW5lZCcgfHwgZXZlbnQua2V5ID09PSAnVW5pZGVudGlmaWVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlTnVtYmVyKGV2ZW50KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBvYnNvbGV0ZSBicm93c2VycyBsaWtlIElFIHRoYXQgcmV0dXJuIHRoZSBvbGQgbmFtZXNcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0RlY2ltYWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkRG90O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTXVsdGlwbHknOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkTXVsdGlwbHk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdBZGQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkUGx1cztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1N1YnRyYWN0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlOYW1lLk51bXBhZE1pbnVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnRGl2aWRlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlOYW1lLk51bXBhZFNsYXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnRGVsJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHdvcmthcm91bmQgZm9yIHRoZSBvYnNvbGV0ZSBicm93c2VyIElFMTEgd2hpY2ggb3V0cHV0IGEgJ0RlbGV0ZScga2V5IHdoZW4gdXNpbmcgdGhlIG51bXBhZCAnZG90JyBvbmUhIFRoaXMgZml4ZXMgaXNzdWUgIzQwMSAvL0ZJWE1FIMOgIHRlcm1pbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5Eb3Q7IC8vIGFzIG9mIHZlcnNpb24gMi4wLjggdGhlIGNoYXJhY3RlcigpIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIG9uIGtleXByZXNzIGV2ZW50LiBUaGUgJ0RlbCcgZG9lcyBub3QgdGhyb3cgdGhlIGtleXByZXNzIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmVudC5rZXk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHZhbHVlIChhIG51bWJlciBhcyBhIHN0cmluZykgaXMgd2l0aGluIHRoZSByYW5nZSBzZXQgaW4gdGhlIHNldHRpbmdzIGBtaW5pbXVtVmFsdWVgIGFuZCBgbWF4aW11bVZhbHVlYCwgRkFMU0Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZE1pblZhbHVlIFBhcnNlZCB2aWEgdGhlIGBwYXJzZVN0cigpYCBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZE1heFZhbHVlIFBhcnNlZCB2aWEgdGhlIGBwYXJzZVN0cigpYCBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrSWZJblJhbmdlKHZhbHVlLCBwYXJzZWRNaW5WYWx1ZSwgcGFyc2VkTWF4VmFsdWUpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlU3RyKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdGVzdE1pbk1heChwYXJzZWRNaW5WYWx1ZSwgcGFyc2VkVmFsdWUpID4gLTEgJiYgdGVzdE1pbk1heChwYXJzZWRNYXhWYWx1ZSwgcGFyc2VkVmFsdWUpIDwgMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBuZWdhdGl2ZSBzaWduIDpcclxuICAgICAqIC0gZXZlcnl3aGVyZSBpbiB0aGUgc3RyaW5nIChieSBkZWZhdWx0KSwgb3JcclxuICAgICAqIC0gb24gdGhlIGZpcnN0IGNoYXJhY3RlciBvbmx5IGlmIHRoZSBgY2hlY2tFdmVyeXdoZXJlYCBwYXJhbWV0ZXIgaXMgc2V0IHRvIGBmYWxzZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmcgQSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgYSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tFdmVyeXdoZXJlIElmIFRSVUUsIHRoZW4gdGhlIG5lZ2F0aXZlIHNpZ24gaXMgc2VhcmNoIGV2ZXJ5d2hlcmUgaW4gdGhlIG51bWVyaWMgc3RyaW5nICh0aGlzIGlzIG5lZWRlZCBmb3IgaW5zdGFuY2UgaWYgdGhlIHN0cmluZyBpcyAnMTIzNC41Ni0nKVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTmVnYXRpdmUobnVtZXJpY1N0cmluZywgY2hlY2tFdmVyeXdoZXJlID0gdHJ1ZSkge1xyXG4gICAgICAgIC8vVE9ETyBVc2UgdGhlIGBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXJgIGZyb20gdGhlIHNldHRpbmdzIGhlcmVcclxuICAgICAgICBpZiAoY2hlY2tFdmVyeXdoZXJlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyhudW1lcmljU3RyaW5nLCAnLScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmVTdHJpY3QobnVtZXJpY1N0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgbmVnYXRpdmUgc2lnbiBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyIChvbiB0aGUgZmFyIGxlZnQpLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJzEyMzQuNTYnKSAgICAgPT4gZmFsc2VcclxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJzEyMzQuNTYtJykgICAgPT4gZmFsc2VcclxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJy0xMjM0LjU2JykgICAgPT4gdHJ1ZVxyXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnLTEsMjM0LjU2IOKCrCcpID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZ1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTmVnYXRpdmVTdHJpY3QobnVtZXJpY1N0cmluZykge1xyXG4gICAgICAgIC8vVE9ETyBVc2luZyB0aGUgYG5lZ2F0aXZlU2lnbkNoYXJhY3RlcmAgZnJvbSB0aGUgc2V0dGluZ3MgaGVyZVxyXG4gICAgICAgIHJldHVybiBudW1lcmljU3RyaW5nLmNoYXJBdCgwKSA9PT0gJy0nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGZvcm1hdHRlZCBvciB1bmZvcm1hdHRlZCBudW1lcmljIHN0cmluZyByZXByZXNlbnQgdGhlIHZhbHVlIDAgKGllLiAnMCwwMCDigqwnKSwgb3IgaXMgZW1wdHkgKCcg4oKsJykuXHJcbiAgICAgKiBUaGlzIHdvcmtzIHNpbmNlIHdlIHRlc3QgaWYgdGhlcmUgYXJlIGFueSBudW1iZXJzIGZyb20gMSB0byA5IGluIHRoZSBzdHJpbmcuIElmIHRoZXJlIGlzIG5vbmUsIHRoZW4gdGhlIG51bWJlciBpcyB6ZXJvIChvciB0aGUgc3RyaW5nIGlzIGVtcHR5KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZ1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzWmVyb09ySGFzTm9WYWx1ZShudW1lcmljU3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICEoL1sxLTldL2cpLnRlc3QobnVtZXJpY1N0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIHZlcnNpb24gb2YgdGhlIHZhbHVlIChyZXByZXNlbnRlZCBhcyBhIHN0cmluZykgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0UmF3TmVnYXRpdmVTaWduKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc05lZ2F0aXZlU3RyaWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYC0ke3ZhbHVlfWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHBvc2l0aW9uIGBpbmRleGAgaW4gdGhlIHN0cmluZyBgc3RyaW5nYCBieSB0aGUgY2hhcmFjdGVyKHMpIGBuZXdDaGFyYWN0ZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7aW50fSBpbmRleFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0NoYXJhY3RlclxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNoYXJBdChzdHJpbmcsIGluZGV4LCBuZXdDaGFyYWN0ZXIpIHtcclxuICAgICAgICByZXR1cm4gYCR7c3RyaW5nLnN1YnN0cigwLCBpbmRleCl9JHtuZXdDaGFyYWN0ZXJ9JHtzdHJpbmcuc3Vic3RyKGluZGV4ICsgbmV3Q2hhcmFjdGVyLmxlbmd0aCl9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgY2xhbXBlZCB0byB0aGUgbmVhcmVzdCBtaW5pbXVtL21heGltdW0gdmFsdWUsIGFzIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2xhbXBUb1JhbmdlTGltaXRzKHZhbHVlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIC8vWFhYIFRoaXMgZnVuY3Rpb24gYWx3YXlzIGFzc3VtZSBgc2V0dGluZ3MubWluaW11bVZhbHVlYCBpcyBsb3dlciB0aGFuIGBzZXR0aW5ncy5tYXhpbXVtVmFsdWVgXHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgTWF0aC5taW4oc2V0dGluZ3MubWF4aW11bVZhbHVlLCB2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbnVtYmVyIG9yIGRvdCBjaGFyYWN0ZXJzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGNhcmV0LCBpbiBhIGZvcm1hdHRlZCBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZE51bWJlclN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb24gVGhpcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShmb3JtYXR0ZWROdW1iZXJTdHJpbmcsIGNhcmV0UG9zaXRpb24sIGRlY2ltYWxDaGFyYWN0ZXIpIHtcclxuICAgICAgICAvLyBIZXJlIHdlIGNvdW50IHRoZSBkb3QgYW5kIHJlcG9ydCBpdCBhcyBhIG51bWJlciBjaGFyYWN0ZXIgdG9vLCBzaW5jZSBpdCB3aWxsICdzdGF5JyBpbiB0aGUgSmF2YXNjcmlwdCBudW1iZXIgd2hlbiB1bmZvcm1hdHRlZFxyXG4gICAgICAgIGNvbnN0IG51bWJlckRvdE9yTmVnYXRpdmVTaWduID0gbmV3IFJlZ0V4cChgWzAtOSR7ZGVjaW1hbENoYXJhY3Rlcn0tXWApOyAvLyBObyBuZWVkIHRvIGVzY2FwZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaGVyZSwgc2luY2UgaXQncyBpbiBgW11gXHJcblxyXG4gICAgICAgIGxldCBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJldFBvc2l0aW9uOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gVGVzdCBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgbnVtYmVyLCBhIGRvdCBvciBhbiBoeXBoZW4uIElmIGl0IGlzLCBjb3VudCBpdCwgb3RoZXJ3aXNlIGlnbm9yZSBpdFxyXG4gICAgICAgICAgICBpZiAobnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24udGVzdChmb3JtYXR0ZWROdW1iZXJTdHJpbmdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXYWxrIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nYCBmcm9tIGxlZnQgdG8gcmlnaHQsIG9uZSBjaGFyIGJ5IG9uZSwgY291bnRpbmcgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleGAuXHJcbiAgICAgKiBJZiB0aGUgY2hhciBpcyBpbiB0aGUgYHJhd051bWJlclN0cmluZ2AgKHN0YXJ0aW5nIGF0IGluZGV4IDApLCB0aGVuIGByYXdOdW1iZXJTdHJpbmdJbmRleCsrYCwgYW5kIGNvbnRpbnVlIHVudGlsXHJcbiAgICAgKiB0aGVyZSBpcyBubyBtb3JlIGNoYXJhY3RlcnMgaW4gYHJhd051bWJlclN0cmluZ2ApIG9yIHRoYXQgYHJhd051bWJlclN0cmluZ0luZGV4ID09PSBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZWAuXHJcbiAgICAgKiBXaGVuIHlvdSBzdG9wLCB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YCBpcyB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGNhcmV0IHNob3VsZCBiZSBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIDEyMzQ1Njd8ODkuMDEgICA6IHBvc2l0aW9uIDcgKHJhd051bWJlclN0cmluZylcclxuICAgICAqIDEyMy40NTYuN3w4OSwwMSA6IHBvc2l0aW9uIDkgKGZvcm1hdHRlZE51bWJlclN0cmluZylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3TnVtYmVyU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcihyYXdOdW1iZXJTdHJpbmcsIGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlLCBmb3JtYXR0ZWROdW1iZXJTdHJpbmcsIGRlY2ltYWxDaGFyYWN0ZXIpIHtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplID0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nLmxlbmd0aDtcclxuICAgICAgICBjb25zdCByYXdOdW1iZXJTdHJpbmdTaXplID0gcmF3TnVtYmVyU3RyaW5nLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbGV0IGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xyXG4gICAgICAgIGxldCByYXdOdW1iZXJTdHJpbmdJbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCA8IGZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUgJiZcclxuICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4IDwgcmF3TnVtYmVyU3RyaW5nU2l6ZSAmJlxyXG4gICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXggPCBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZTtcclxuICAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKHJhd051bWJlclN0cmluZ1tyYXdOdW1iZXJTdHJpbmdJbmRleF0gPT09IGZvcm1hdHRlZE51bWJlclN0cmluZ1tmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleF0gfHxcclxuICAgICAgICAgICAgICAgIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSAnLicgJiYgZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSA9PT0gZGVjaW1hbENoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvdW50IHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpbiB0aGUgZ2l2ZW4gdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY291bnRDaGFySW5UZXh0KGNoYXJhY3RlciwgdGV4dCkge1xyXG4gICAgICAgIGxldCBjaGFyQ291bnRlciA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0W2ldID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJDb3VudGVyKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGFyQ291bnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIGNhcmV0IHBvc2l0aW9uLlxyXG4gICAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCB0aGUgcG9zaXRpb24gaXMgc3RhcnRpbmcgYXQgJzAnLCBub3QgMS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gY2hhcmFjdGVyQ291bnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjaGFyYWN0ZXJDb3VudCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChjaGFyYWN0ZXJDb3VudCwgY2hhcmFjdGVyQ291bnQgLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSB0aGF0XHJcbiAgICAgKiBAcmV0dXJucyB7e319XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3Rpb24odGhhdCkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge307XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgc2VsZWN0Lm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLXRoYXQudmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gc2VsZWN0LnRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHRoYXQuc2VsZWN0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3Igc2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSB0aGF0XHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRcclxuICAgICAqIEBwYXJhbSB7aW50fG51bGx9IGVuZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQsIHN0YXJ0LCBlbmQgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShlbmQpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGF0LmNyZWF0ZVRleHRSYW5nZSgpO1xyXG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcclxuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcclxuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XHJcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25FbmQgPSBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aHJvdyBlcnJvciBtZXNzYWdlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRoYXQgZGlzcGxheSBhIHdhcm5pbmcgbWVzc2FnZXMsIGFjY29yZGluZyB0byB0aGUgZGVidWcgbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd1dhcm5pbmcgSWYgRkFMU0UsIHRoZW4gdGhlIHdhcm5pbmcgbWVzc2FnZSBpcyBub3QgZGlzcGxheWVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgc2hvd1dhcm5pbmcgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHNob3dXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttZXNzYWdlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhdXRvTnVtZXJpYy1zcGVjaWZpYyBmdW5jdGlvbnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1biBhbnkgY2FsbGJhY2tzIGZvdW5kIGluIHRoZSBzZXR0aW5ncyBvYmplY3QuXHJcbiAgICAgKiBBbnkgcGFyYW1ldGVyIGNvdWxkIGJlIGEgY2FsbGJhY2s6XHJcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcclxuICAgICAqIC0gYSBuYW1lIG9mIGZ1bmN0aW9uLCBhdHRhY2hlZCB0byAkKHNlbGVjdG9yKS5hdXRvTnVtZXJpYy5mdW5jdGlvbk5hbWUoKXt9IC0gd2hpY2ggd2FzIGNhbGxlZCBwcmV2aW91c2x5XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCR0aGlzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIC8vIExvb3BzIHRocm91Z2ggdGhlIHNldHRpbmdzIG9iamVjdCAob3B0aW9uIGFycmF5KSB0byBmaW5kIHRoZSBmb2xsb3dpbmdcclxuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gdmFsKCR0aGlzLCBzZXR0aW5ncywgayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGxzIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBmcm9tIHRoZSBodG1sNSBkYXRhIGV4YW1wbGU6IGRhdGEtYS1zaWduPVwiZnVuY3Rpb25OYW1lXCJcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gJHRoaXMuYXV0b051bWVyaWNbdmFsXSgkdGhpcywgc2V0dGluZ3MsIGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUgdGhlIG1heGltdW0gZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgc2V0dGluZ3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWluaW11bVZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF4aW11bVZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKG1pbmltdW1WYWx1ZSwgbWF4aW11bVZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRlY2ltYWxQbGFjZXMobWluaW11bVZhbHVlKSwgZGVjaW1hbFBsYWNlcyhtYXhpbXVtVmFsdWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmlwIGFsbCB1bndhbnRlZCBub24tbnVtYmVyIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBUaGlzIGtlZXBzIHRoZSBudW1iZXJzLCB0aGUgbmVnYXRpdmUgc2lnbiBhcyB3ZWxsIGFzIHRoZSBjdXN0b20gZGVjaW1hbCBjaGFyYWN0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsZWZ0T3JBbGxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHMsIHNldHRpbmdzLCBsZWZ0T3JBbGwpIHtcclxuICAgICAgICAvL1RPRE8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgMTAgdGltZXMgKHNpYyEpIG9uIGVhY2gga2V5IGlucHV0LCBjb3VsZG4ndCB3ZSBsb3dlciB0aGF0IG51bWJlcj8gY2YuIGlzc3VlICMzMjVcclxuICAgICAgICAvL1RPRE8gUmVmYWN0b3IgdGhpcyB3aXRoIGBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKClgIGlmIHBvc3NpYmxlP1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbmN5IHNpZ25cclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCwgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V0dGluZ3Muc3VmZml4VGV4dCkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgc3VmZml4XHJcbiAgICAgICAgICAgIHdoaWxlIChjb250YWlucyhzLCBzZXR0aW5ncy5zdWZmaXhUZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdWZmaXhUZXh0LCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwLCAnJDEkMicpO1xyXG5cclxuICAgICAgICBpZiAoKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHxcclxuICAgICAgICAgICAgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmXHJcbiAgICAgICAgICAgIGlzTmVnYXRpdmUocykgJiZcclxuICAgICAgICAgICAgcyAhPT0gJycpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGVuIHJlcGxhY2UgYW55dGhpbmcgYWZ0ZXIgZGlnaXRzXHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCwgJyQxJyk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gcmVtb3ZlIGFueSB1bmludGVyZXN0aW5nIGNoYXJhY3RlcnNcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlLCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCBvbmx5IG51bWJlciBzdHJpbmdcclxuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xyXG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2tlZXAnKSB7XHJcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBuU2lnbiA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXHJcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxyXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcyA9IGAke25TaWdufSR7bW9kaWZpZWRJbnRlZ2VyUGFydH0ke2lzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KT8nJzpzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnR9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgobGVmdE9yQWxsICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnZGVueScpIHx8XHJcbiAgICAgICAgICAgICghc2V0dGluZ3MuaGFzRm9jdXMgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09ICdhbGxvdycpKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc3RyaXBSZWcsICckMSQyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgZm9jdXMgc3RhdGUuXHJcbiAgICAgKiBUaGUgZm9jdXMgc3RhdGUgaXMgJ3N0b3JlZCcgaW4gdGhlIHNldHRpbmdzIG9iamVjdCB1bmRlciB0aGUgYHNldHRpbmdzLmhhc0ZvY3VzYCBhdHRyaWJ1dGUuXHJcbiAgICAgKiAvL1RPRE8gVXNlIGFub3RoZXIgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgaW50ZXJuYWwgZGF0YSB0aGF0IGFyZSBub3Qgc2V0dGluZ3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHx8XHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncCcpKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBTcGxpdCB0aGUgZmlyc3QgYW5kIGxhc3QgYnJhY2tldCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzZXR0aW5ncyBpbml0aWFsaXphdGlvblxyXG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmhhc0ZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYnJhY2tldHNcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBzID0gZmlyc3RCcmFja2V0ICsgcyArIGxhc3RCcmFja2V0O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmhhc0ZvY3VzICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0LCBzaG91bGRuJ3Qgd2UgcmVwbGFjZSB0aGUgJy0nIHNpZ24gYXQgdGhlIHJpZ2h0IHBsYWNlP1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShmaXJzdEJyYWNrZXQsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGxhc3RCcmFja2V0LCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgbnVtYmVyIGFzIGEgbnVtZXJpYyBzdHJpbmcgdGhhdCBjYW4gYmUgdHlwZWNhc3QgdG8gYSBOdW1iZXIgdGhhdCBKYXZhc2NyaXB0IHdpbGwgdW5kZXJzdGFuZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybiB0aGUgZ2l2ZW4gc3RyaW5nIGJ5IHN0cmlwcGluZyB0aGUgY3VycmVuY3kgc2lnbiAoY3VycmVuY3lTeW1ib2wpLCB0aGUgZ3JvdXBpbmcgc2VwYXJhdG9ycyAoZGlnaXRhbEdyb3VwU3BhY2luZykgYW5kIGJ5IHJlcGxhY2luZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgKGRlY2ltYWxDaGFyYWN0ZXIpIGJ5IGEgZG90LlxyXG4gICAgICogTGFzdGx5LCBpdCBhbHNvIHB1dCB0aGUgbmVnYXRpdmUgc2lnbiBiYWNrIHRvIGl0cyBub3JtYWwgcG9zaXRpb24gaWYgbmVlZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udmVydFRvTnVtZXJpY1N0cmluZyhzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY3VycmVuY3kgc3ltYm9sXHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCwgJycpO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGdyb3VwaW5nIHNlcGFyYXRvcnMgKHRob3VzYW5kcyBzZXBhcmF0b3JzIHVzdWFsbHkpXHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGJ5IGEgZG90XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNb3ZlIHRoZSB0cmFpbGluZyBuZWdhdGl2ZSBzaWduIHRvIHRoZSByaWdodCBwb3NpdGlvbiwgaWYgYW55XHJcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUocykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICAgICAgcyA9ICctJyArIHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGFueSBhcmFiaWMgbnVtYmVycyB0byBsYXRpbiBvbmVzXHJcbiAgICAgICAgY29uc3QgdGVtcCA9IGFyYWJpY1RvTGF0aW5OdW1iZXJzKHMsIHRydWUsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCFpc05hTih0ZW1wKSkge1xyXG4gICAgICAgICAgICBzID0gdGVtcC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgSVNPIG51bWVyaWMgc3RyaW5nIHRvIHRoZSBsb2NhbGUgZGVjaW1hbCBhbmQgbWludXMgc2lnbiBwbGFjZW1lbnQuXHJcbiAgICAgKiBTZWUgdGhlIFwib3V0cHV0Rm9ybWF0XCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKGxvY2FsZSkgfHwgbG9jYWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIHN3aXRjaCAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJy4tJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzTmVnYXRpdmUodmFsdWUpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgICAgICBjYXNlICctLCc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcsLSc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzTmVnYXRpdmUocmVzdWx0KSA/IHJlc3VsdC5yZXBsYWNlKCctJywgJycpICsgJy0nIDogcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNhc2VcclxuICAgICAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICAgIGNhc2UgJy0uJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGdpdmVuIG91dHB1dEZvcm1hdCBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IHRoZSBuZWdhdGl2ZSBzaWduIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgb2YgdGhlIGdpdmVuIHN0cmluZyB2YWx1ZSB0byBhbiBoeXBoZW4gKC0pIGFuZCBhIGRvdCAoLikgaW4gb3JkZXIgdG8gbWFrZSB0aGF0IHZhbHVlICd0eXBlY2FzdGFibGUnIHRvIGEgcmVhbCBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnLScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybmVkIGJ5IGBnZXRgIGlzIG5vdCBmb3JtYXR0ZWQgd2l0aCBkZWNpbWFsc1xyXG4gICAgICAgICAgICBzICs9ICcwJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IHRoZSBuZWdhdGl2ZSBzaWduIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gdXNlIHRob3NlIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZShzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy4nLCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0byBjaGVjayBmb3IgZW1wdHkgdmFsdWVcclxuICAgICAqIC8vVE9ETyBNb2RpZnkgdGhpcyBmdW5jdGlvbiBzbyB0aGF0IGl0IHJldHVybiBlaXRoZXIgVFJVRSBvciBGQUxTRSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkuIFRoZW4gY3JlYXRlIGFub3RoZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBpbnB1dCB2YWx1ZSBpZiBpdCdzIG5vdCBlbXB0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcclxuICAgICAgICBpZiAoaW5wdXRWYWx1ZSA9PT0gJycgfHwgaW5wdXRWYWx1ZSA9PT0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpID8gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3Muc3VmZml4VGV4dCA6IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgdGhlIGlucHV0IHZhbHVlIGJ5IGFkZGluZyB0aGUgZ3JvdXAgc2VwYXJhdG9ycywgYXMgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEdyb3VwU2VwYXJhdG9ycyhpbnB1dFZhbHVlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdHJpcCkge1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGlucHV0VmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE8gVGhpcyBmdW5jdGlvbiBgYWRkR3JvdXBTZXBhcmF0b3JzKClgIGFkZCBncm91cCBzZXBhcmF0b3JzLiBBZGRpbmcgdGhlIG5lZ2F0aXZlIHNpZ24gYXMgd2VsbCBpcyBvdXQgb2YgaXRzIHNjb3BlLiBNb3ZlIHRoYXQgdG8gYW5vdGhlciBmdW5jdGlvbi5cclxuICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZShpbnB1dFZhbHVlKSkge1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gJy0nICsgaW5wdXRWYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVtcHR5ID0gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgaXNWYWx1ZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZShpbnB1dFZhbHVlKTtcclxuICAgICAgICBjb25zdCBpc1plcm8gPSBpc1plcm9Pckhhc05vVmFsdWUoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGlzVmFsdWVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwoZW1wdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcgPSBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgbGV0IGRpZ2l0YWxHcm91cDtcclxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSAnMic6XHJcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJzJzJzpcclxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoPzpcXGR7Mn0pezAsMn1cXGR7M30oPzooPzpcXGR7Mn0pezJ9XFxkezN9KSo/KSQvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJzQnOlxyXG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7NH0/KSspJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHszfT8pKykkLztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNwbGl0cyB0aGUgc3RyaW5nIGF0IHRoZSBkZWNpbWFsIHN0cmluZ1xyXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcclxuICAgICAgICAgICAgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gUmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0LnJlcGxhY2UoZGlnaXRhbEdyb3VwLCBgJDEke3NldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3J9JDJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSAhPT0gMCAmJiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgICAgIGRlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEpvaW5zIHRoZSB3aG9sZSBudW1iZXIgd2l0aCB0aGUgZGVjaW1hbCB2YWx1ZVxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQgKyBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIGl0J3MgYW4gaW50ZWdlclxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm8pIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsdWVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm8pIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIChzZXR0aW5ncy5yYXdWYWx1ZSA8IDAgfHwgaXNOZWdhdGl2ZVN0cmljdChpbnB1dFZhbHVlKSkpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChpbnB1dFZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZSArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdW5kZWRJbnB1dFZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZHxYTUx8c3RyaW5nfCp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgIGxldCByZWdleDtcclxuICAgICAgICBzd2l0Y2ggKHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB1bnRpbCB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXQgaXMgZW5jb3VudGVyZWRcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC4oPzpcXGQqWzEtOV0pPykwKiQvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIC8vIEFsbG93cyBwYWRkaW5nIHdoZW4gZGVjaW1hbFBsYWNlc092ZXJyaWRlIGVxdWFscyBvbmUgLSBsZWF2ZXMgb25lIHplcm8gdHJhaWxpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgbGVuZ3RoIHdoZW4gYWxsb3dEZWNpbWFsUGFkZGluZyBpcyBzZXQgdG8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXC5cXFxcZHske3RlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZX19KD86XFxcXGQqWzEtOV0pPykwKmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2ltYWwgcGxhY2VzLCB3ZSBkb24ndCBuZWVkIGEgZGVjaW1hbCBwb2ludCBhdCB0aGUgZW5kXHJcbiAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcclxuICAgICAgICBpZiAodGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZGVkSW5wdXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdW5kIHRoZSBpbnB1dCB2YWx1ZSB1c2luZyB0aGUgcm91bmRpbmcgbWV0aG9kIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIG11bHRpcGxlIHJvdW5kaW5nIG1ldGhvZHMuIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRob3NlLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgOiBUaGlzIGlzIGhhbmRsZWQgYXMgdGV4dCBzaW5jZSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmRWYWx1ZShpbnB1dFZhbHVlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZSA9PT0gJycpID8gJzAnIDogaW5wdXRWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ04wNScgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdDSEYnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnVTA1JyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0QwNScpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGgucm91bmQoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguY2VpbChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguZmxvb3IoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGlucHV0VmFsdWUsICcuJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnLjAwJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFZhbHVlLmxlbmd0aCAtIGlucHV0VmFsdWUuaW5kZXhPZignLicpIDwgMykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcwJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgbGV0IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZTtcclxuXHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdHJ1bmNhdGUgemVybyBtZXRob2RcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZykge1xyXG4gICAgICAgICAgICB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaW5wdXRWYWx1ZSAoaW5wdXQgVmFsdWUpIGlzIGEgbmVnYXRpdmUgdmFsdWVcclxuICAgICAgICBpZiAoaXNOZWdhdGl2ZVN0cmljdChpbnB1dFZhbHVlKSkge1xyXG4gICAgICAgICAgICBuU2lnbiA9ICctJztcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gdGhhdCB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBhIHplcm8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYSBkaWdpdCAodGhlbiBpdCBpcyBsaWtlbHkgdG8gYmUgYSBkb3QpXHJcbiAgICAgICAgaWYgKCFpbnB1dFZhbHVlLm1hdGNoKC9eXFxkLykpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICcwJyArIGlucHV0VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBlcXVhbCB0byB6ZXJvLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduXHJcbiAgICAgICAgaWYgKE51bWJlcihpbnB1dFZhbHVlKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBuU2lnbiA9ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJpbXMgbGVhZGluZyB6ZXJvJ3MgYXMgbmVlZGVkXHJcbiAgICAgICAgaWYgKChOdW1iZXIoaW5wdXRWYWx1ZSkgPiAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHx8IChpbnB1dFZhbHVlLmxlbmd0aCA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09ICdhbGxvdycpKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkUG9zID0gaW5wdXRWYWx1ZS5sYXN0SW5kZXhPZignLicpO1xyXG4gICAgICAgIGNvbnN0IGlucHV0VmFsdWVIYXNBRG90ID0gZFBvcyA9PT0gLTE7XHJcblxyXG4gICAgICAgIC8vIFZpcnR1YWwgZGVjaW1hbCBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IHZkUG9zID0gaW5wdXRWYWx1ZUhhc0FEb3QgPyBpbnB1dFZhbHVlLmxlbmd0aCAtIDEgOiBkUG9zO1xyXG5cclxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcclxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxyXG4gICAgICAgIGxldCBjRGVjID0gKGlucHV0VmFsdWUubGVuZ3RoIC0gMSkgLSB2ZFBvcztcclxuXHJcbiAgICAgICAgaWYgKGNEZWMgPD0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcGFkIHdpdGggemVyb3NcclxuICAgICAgICAgICAgaXZSb3VuZGVkID0gaW5wdXRWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKGNEZWMgPCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvcyA9ICcwMDAwMDAnO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNEZWMgPCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm9zLnN1YnN0cmluZygwLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgLSBjRGVjKTtcclxuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gemVyb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY0RlYyArPSB6ZXJvcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA+IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA9PT0gMCAmJiB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xyXG4gICAgICAgIGxldCByTGVuZ3RoO1xyXG4gICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xyXG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlICsgZFBvcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRSb3VuZCA9IE51bWJlcihpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IG9kZCA9IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xyXG4gICAgICAgIGxldCBpdkFycmF5ID0gaW5wdXRWYWx1ZS5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcclxuXHJcbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnUycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdhJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdhJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdCJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXHJcbiAgICAgICAgICAgICh0Um91bmQgPT09IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxyXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0MnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIHRvIGNlaWxpbmcgdG93YXJkIHBvc2l0aXZlIGluZmluaXRlXHJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnRicgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgdG8gZmxvb3IgdG93YXJkIG5lZ2F0aXZlIGluZmluaXRlXHJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cclxuICAgICAgICAgICAgLy8gUm91bmQgdXAgdGhlIGxhc3QgZGlnaXQgaWYgcmVxdWlyZWQsIGFuZCBjb250aW51ZSB1bnRpbCBubyBtb3JlIDkncyBhcmUgZm91bmRcclxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICtpdkFycmF5W2ldICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAnMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgc3RyaW5nLCBjb252ZXJ0aW5nIGFueSAxMCdzIHRvIDAnc1xyXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSByb3VuZGVkIHZhbHVlXHJcbiAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdkFycmF5LmpvaW4oJycpLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bhc3RlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVEZWNpbWFsKHMsIHNldHRpbmdzLCBpc1Bhc3RlKSB7XHJcbiAgICAgICAgcyA9IChpc1Bhc3RlKSA/IHJvdW5kVmFsdWUocywgc2V0dGluZ3MpIDogcztcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgJiYgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIGRlY2ltYWwgcGFydCB0byBzYXRpc2Z5aW5nIGxlbmd0aCBzaW5jZSB3ZSB3b3VsZCByb3VuZCBpdCBhbnl3YXlcclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0ICYmIGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGAke2ludGVnZXJQYXJ0fSR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke21vZGlmaWVkRGVjaW1hbFBhcnR9YDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGludGVnZXJQYXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIHBhcnNlIG1pbmltdW1WYWx1ZSwgbWF4aW11bVZhbHVlICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZS5cclxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogbWluaW11bVZhbHVlOiBcIjk5OTk5OTk5OTk5OTk5OS45OVwiIHJldHVybnMgdGhlIGZvbGxvd2luZyBcIntzOiAtMSwgZTogMTIsIGM6IEFycmF5WzE1XX1cIi5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzLy4gTWFueSB0aGFua3MgdG8gTWlrZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG4gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge3t9fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHt9OyAvLyBBIEJpZyBudW1iZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgbGV0IGU7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IG5MO1xyXG4gICAgICAgIGxldCBqO1xyXG5cclxuICAgICAgICAvLyBNaW51cyB6ZXJvP1xyXG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xyXG4gICAgICAgICAgICBuID0gJy0wJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBzaWduLiAxIHBvc2l0aXZlLCAtMSBuZWdhdGl2ZVxyXG4gICAgICAgIG4gPSBuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVTdHJpY3QobikpIHtcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHgucyA9IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHgucyA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGUgPSBuLmluZGV4T2YoJy4nKTtcclxuICAgICAgICBpZiAoZSA+IC0xKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nIGlmIG5vIGRlY2ltYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgICAgIC8vIEludGVnZXJcclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3NcclxuICAgICAgICBpID0gKG4uc2VhcmNoKC9bMS05XS9pKSA9PT0gLTEpID8gbi5sZW5ndGggOiBuLnNlYXJjaCgvWzEtOV0vaSk7XHJcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcclxuICAgICAgICBpZiAoaSA9PT0gbkwpIHtcclxuICAgICAgICAgICAgLy8gWmVyb1xyXG4gICAgICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgICAgICB4LmMgPSBbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXHJcbiAgICAgICAgICAgIGZvciAoaiA9IG5MIC0gMTsgbi5jaGFyQXQoaikgPT09ICcwJzsgaiAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBuTCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5MIC09IDE7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXHJcbiAgICAgICAgICAgIHguZSA9IGUgLSBpIC0gMTtcclxuICAgICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zXHJcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGkgPD0gbkw7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgZSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5ncy5cclxuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzLy4gTWFueSB0aGFua3MgdG8gTWlrZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geSBCaWcgbnVtYmVyIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geCBCaWcgbnVtYmVyIGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGVzdE1pbk1heCh5LCB4KSB7XHJcbiAgICAgICAgY29uc3QgeGMgPSB4LmM7XHJcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XHJcbiAgICAgICAgbGV0IGkgPSB4LnM7XHJcbiAgICAgICAgbGV0IGogPSB5LnM7XHJcbiAgICAgICAgbGV0IGsgPSB4LmU7XHJcbiAgICAgICAgbGV0IGwgPSB5LmU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICF5Y1swXT8wOi1qO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmIChpICE9PSBqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzXHJcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChrID4gbCBeIHhOZWcpPzE6LTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgPSAtMTtcclxuICAgICAgICBrID0geGMubGVuZ3RoO1xyXG4gICAgICAgIGwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdFxyXG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPT0geWNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeGNbaV0gPiB5Y1tpXSBeIHhOZWcpPzE6LTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGsgPT09IGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSAoayA+IGwgXiB4TmVnKT8xOi0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRoYXQgdGhlIG51bWJlciBzYXRpc2Z5IHRoZSBmb3JtYXQgY29uZGl0aW9uc1xyXG4gICAgICogYW5kIGxheXMgYmV0d2VlbiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgYW5kIHNldHRpbmdzLm1heGltdW1WYWx1ZVxyXG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcclxuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHZhbFBhcnNlID0gcGFyc2VTdHIocyk7XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5vdmVycmlkZU1pbk1heExpbWl0cykge1xyXG4gICAgICAgICAgICBjYXNlICdmbG9vcic6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlaWxpbmcnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhhbmtzIHRvIEFudGhvbnkgJiBFdmFuIENcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl8SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgKGFuZCB0aGVyZWZvcmUgaXMgYSBDU1Mgc2VsZWN0b3IpLCB0aGVuIHdlIG5lZWQgdG8gbW9kaWZ5IHRoaXMgc3RyaW5nIGluIG9yZGVyXHJcbiAgICAgICAgICogZm9yIGpRdWVyeSB0byBiZSBhYmxlIHRvIHBhcnNlIHRoZSBzZWxlY3RvciBjb3JyZWN0bHkuXHJcbiAgICAgICAgICogY2YuIGh0dHA6Ly9sZWFybi5qcXVlcnkuY29tL3VzaW5nLWpxdWVyeS1jb3JlL2ZhcS9ob3ctZG8taS1zZWxlY3QtYW4tZWxlbWVudC1ieS1hbi1pZC10aGF0LWhhcy1jaGFyYWN0ZXJzLXVzZWQtaW4tY3NzLW5vdGF0aW9uL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBibG9jayBpcyBhcHBhcmVudGx5IG5ldmVyIGVudGVyZWQuIFdlIHNob3VsZCByZW1vdmUgaXQgYWZ0ZXIgbWFraW5nIHN1cmUgdGhhdCdzIDEwMCUgdGhlIGNhc2VcclxuICAgICAgICAgICAgZWxlbWVudCA9IGAjJHtlbGVtZW50LnJlcGxhY2UoLyg6fFxcLnxcXFt8XXwsfD0pL2csICdcXFxcJDEnKX1gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICQoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGF0dGFjaCB0aGUgYXV0b051bWVyaWMgZmllbGQgcHJvcGVydGllcyB0byB0aGUgRE9NIGVsZW1lbnQgdmlhIGFuIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB1cGRhdGUgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCBkYXRhID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xyXG4gICAgICAgIGlmICh1cGRhdGUgfHwgKGlzVW5kZWZpbmVkKGhvbGRlcikgJiYgc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgIGhvbGRlciA9IG5ldyBBdXRvTnVtZXJpY0hvbGRlcigkdGhpcy5nZXQoMCksIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaG9sZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgJiBub1NlcGFyYXRvck9uRm9jdXMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZC5cclxuICAgICAqIFRob3NlIG9yaWdpbmFsIHNldHRpbmdzIGFyZSB1c2VkIGV4Y2x1c2l2ZWx5IGluIHRoZSBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5KHNldHRpbmdzKSB7XHJcbiAgICAgICAgLy9UT0RPIFJlbmFtZSB0aGUgb2xkIG9wdGlvbiBuYW1lcyB0byB0aGUgbmV3IG9uZXNcclxuICAgICAgICBzZXR0aW5ncy5vRGVjICAgICA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcclxuICAgICAgICBzZXR0aW5ncy5vUGFkICAgICA9IHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmc7XHJcbiAgICAgICAgc2V0dGluZ3Mub0JyYWNrZXQgPSBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjtcclxuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3I7XHJcbiAgICAgICAgc2V0dGluZ3Mub1NpZ24gICAgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcclxuICAgICAgICBzZXR0aW5ncy5vU3VmZml4ICA9IHNldHRpbmdzLnN1ZmZpeFRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgICYgYG5vU2VwYXJhdG9yT25Gb2N1c2Agb3B0aW9ucyBhcmUgYmVpbmcgdXNlZC5cclxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBRdWlya3Ntb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcclxuICAgICAgICBjb25zdCBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xyXG4gICAgICAgIGxldCBjID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBjID0gY2FbaV07XHJcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBNb2Rlcm5penIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0b3JhZ2VUZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xyXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHByb3Blcmx5IGZvcm1hdHMgdGhlIHN0cmluZyB0byBhIG51bWVyaWMgd2hlbiBsZWFkaW5nWmVybyBkb2VzIG5vdCAna2VlcCcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgaXMgdGhlIHZhbHVlIGlzIGFscmVhZHkgZW1wdHkuIFRoaXMgcHJldmVudCBjb252ZXJ0aW5nIHRoYXQgdmFsdWUgdG8gJzAnLlxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuICcwJyBpZiB0aGUgdmFsdWUgaXMgemVyb1xyXG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcwJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB7XHJcbiAgICAgICAgICAgIC8vIFRyaW0gbGVhZGluZyB6ZXJvJ3MgLSBsZWF2ZXMgb25lIHplcm8gdG8gdGhlIGxlZnQgb2YgdGhlIGRlY2ltYWwgcG9pbnRcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKC0pPzArKD89XFxkKS9nLCckMScpO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIHJlbW92ZSB0aGlzIGZyb20gdGhhdCBmdW5jdGlvbiBhbmQgdXNlIGB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcygpYCBpbnN0ZWFkLiBBbHNvIGNyZWF0ZSBhIG5ldyBgdHJhaWxpbmdaZXJvYCBvcHRpb24uXHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyh2YWx1ZSwgJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJpbXMgdHJhaWxpbmcgemVyb3MgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnRcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcLlswLTldKj8pMCskLywgJyQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RyaXBzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcLiQvLCAnJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0aGUgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZ1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyaW1QYWRkZWRaZXJvc0Zyb21EZWNpbWFsUGxhY2VzKG51bWVyaWNTdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IG51bWVyaWNTdHJpbmcuc3BsaXQoJy4nKTtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZWdlclBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0cmltbWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5yZXBsYWNlKC8wKyQvZywgJycpO1xyXG5cclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGlmICh0cmltbWVkRGVjaW1hbFBhcnQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGludGVnZXJQYXJ0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGAke2ludGVnZXJQYXJ0fS4ke3RyaW1tZWREZWNpbWFsUGFydH1gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgb3IgcmVtb3ZlcyBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIHdoYXQgdGhlIGJyb3dzZXIgaXMgc3VwcG9ydGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZWxlbWVudCwgc2V0dGluZ3MsIGFjdGlvbikge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZE5hbWUgPSAoZWxlbWVudC5uYW1lICE9PSAnJyAmJiAhaXNVbmRlZmluZWQoZWxlbWVudC5uYW1lKSkgP2BBVVRPXyR7ZGVjb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQubmFtZSl9YCA6YEFVVE9fJHtlbGVtZW50LmlkfWA7XHJcbiAgICAgICAgICAgIGxldCBkYXRlO1xyXG4gICAgICAgICAgICBsZXQgZXhwaXJlcztcclxuXHJcbiAgICAgICAgICAgIC8vIFNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcclxuICAgICAgICAgICAgaWYgKHN0b3JhZ2VUZXN0KCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKC0xICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyBOb3RlIDogYHRvR01UU3RyaW5nKClgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgKGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvR01UU3RyaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIEF1dG9OdW1lcmljSG9sZGVyIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGFzcyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3RydWN0b3IodGhhdCwgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xyXG4gICAgICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcclxuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIHRoZSB2YWx1ZSBhbmQgdGhlIHNlbGVjdGlvbiB2YWx1ZXMgaW5zaWRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QuXHJcbiAgICAgICAgICogVGhpcyBrZWVwcyB0cmFja3Mgb2YgdGhlIGlucHV0IHZhbHVlLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgICAgICAgKiBUaGlzIGFsc28gcmVzZXRzIHRoZSAncHJvY2Vzc2VkJyBhbmQgJ2Zvcm1hdHRlZCcgc3RhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlIDogVGhvc2UgdHdvIGNhbiBjaGFuZ2UgYmV0d2VlbiB0aGUga2V5ZG93biwga2V5cHJlc3MgYW5kIGtleXVwIGV2ZW50cywgdGhhdCdzIHdoeVxyXG4gICAgICAgICAqICAgICAgICB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIHRoZSBrZXljb2RlIG9mIHRoZSBrZXkgdGhhdCB0cmlnZ2VyZWQgdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAgICAgICAqIE5vdGUgOiBlLndoaWNoIGlzIHNvbWV0aW1lcyBkaWZmZXJlbnQgdGhhbiBlLmtleUNvZGUgZHVyaW5nIHRoZSBrZXlwcmVzcyBldmVudCwgd2hlbiBlbnRlcmluZyBhIHByaW50YWJsZSBjaGFyYWN0ZXIga2V5IChpZS4gJ3QnKS4gYGUud2hpY2hgIGVxdWFscyAwIGZvciBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvL1RPRE8gU3dpdGNoIHRvIHRoZSBub24tZGVwcmVjYXRlZCBlLmtleSBhdHRyaWJ1dGUsIGluc3RlYWQgb2YgaW5jb25zaXN0YW50IGUud2hpY2ggYW5kIGUua2V5Q29kZS5cclxuICAgICAgICAgKiBlLmtleSBkZXNjcmliZSB0aGUga2V5IG5hbWUgdXNlZCB0byB0cmlnZ2VyIHRoZSBldmVudC5cclxuICAgICAgICAgKiBlLmtleUNvZGUgYmVpbmcgZGVwcmVjYXRlZCA6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleUNvZGVcclxuICAgICAgICAgKiBIb3cgZS5rZXkgd29ya3MgOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcclxuICAgICAgICAgKiBUaGUga2V5IGxpc3QgaXMgZGVzY3JpYmVkIGhlcmVcclxuICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyRXZlbnRLZXljb2RlKGUpIHtcclxuICAgICAgICAgICAgLy8gTm90ZTogdGhlIGtleXByZXNzIGV2ZW50IG92ZXJ3cml0ZXMgbWVhbmluZ2Z1bCB2YWx1ZSBvZiBlLmtleUNvZGUsIGhlbmNlIHdlIGRvIG5vdCB1cGRhdGUgdGhhdCB2YWx1ZSBvbiAna2V5cHJlc3MnXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID0ga2V5Q29kZU51bWJlcihlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgdGV4dCBzZWxlY3Rpb24gaW5zaWRlIHRoZSBpbnB1dCB3aXRoIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0XHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCwgc2V0UmVhbCkge1xyXG4gICAgICAgICAgICAvL1RPRE8gTW9kaWZ5IHNldFJlYWwgdG8gYmUgbW9yZSBleHBsaWNpdCAoYW5kIGEgYm9vbGVhbilcclxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heChzdGFydCwgMCk7XHJcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7IC8vVE9ETyBSZXBsYWNlIGB0aGlzLnRoYXQudmFsdWUubGVuZ3RoYCB3aXRoIGB0aGlzLnZhbHVlLmxlbmd0aGBcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgICAgIGVuZCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogZW5kIC0gc3RhcnQsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2V0UmVhbCkgfHwgc2V0UmVhbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGluc2lkZSB0aGUgaW5wdXQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHBvc1xyXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9zZXRDYXJldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xyXG4gICAgICAgICAgICAvL1RPRE8gTW9kaWZ5IHNldFJlYWwgdG8gYmUgbW9yZSBleHBsaWNpdCAoYW5kIGEgYm9vbGVhbilcclxuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxyXG4gICAgICAgICAqIFRob3NlIHBhcnRzIGFyZSBsZWZ0ICd1bnRvdWNoZWQnLCBpZS4gZm9ybWF0dGVkIGJ5IGF1dG9OdW1lcmljLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdmFsdWUuc3Vic3RyaW5nKHRoaXMuc2VsZWN0aW9uLmVuZCwgdmFsdWUubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBwYXJ0cyBsb2NhdGVkIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb24uXHJcbiAgICAgICAgICogVGhvc2UgcGFydHMgYXJlIHVuZm9ybWF0dGVkIChzdHJpcHBlZCkgb2YgYW55IG5vbi1udW1iZXJzIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX0gVGhlIHBhcnRzIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLCB1bmZvcm1hdHRlZC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcclxuICAgICAgICAgICAgbGV0IHN0cmlwWmVyb3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSHlwaGVuICYmIE51bWJlcihsZWZ0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlZnQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lLCBzdHJpcFplcm9zKTtcclxuICAgICAgICAgICAgcmlnaHQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocmlnaHQsIHRoaXMuc2V0dGluZ3NDbG9uZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZShsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCA9PT0gJy0nKSA/ICcnIDogcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdHJpcCBwYXJ0cyBmcm9tIGV4Y2VzcyBjaGFyYWN0ZXJzIGFuZCBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcclxuICAgICAgICAgKiBAcmV0dXJucyB7WyosKl19XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfbm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGNoYW5naW5nIHRoZSBzaWduIGFuZCBsZWZ0IGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgemVybyAtIHByZXZlbnRzIHN0cmlwcGluZyB0aGUgbGVhZGluZyB6ZXJvc1xyXG4gICAgICAgICAgICBsZXQgc3RyaXBaZXJvcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpcFplcm9zID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVmdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCBzZXR0aW5nc0Nsb25lLCBzdHJpcFplcm9zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBkZWNpbWFsQ2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHJpZ2h0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5sZWFkaW5nWmVybyA9PT0gJ2RlbnknICYmXHJcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtMCB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW1wYWQwKSAmJlxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGxlZnQpID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAhY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSAgJiYgcmlnaHQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZShsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XHJcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJ9YCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvbi4gLy9UT0RPIFdoYXQgYWJvdXQgdGhlIGN1cnNvciBzZWxlY3Rpb24/XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodFxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIGlzUGFzdGUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnRzWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBpc1Bhc3RlKTtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBDaGVjayBpZiB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGhhcmQtY29kZWQgJywnIHdpdGggc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IChzZXR0aW5nc0Nsb25lLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSA/ICcwJyA6ICcnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh0ZXN0VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2hlbiB0aGUgdXNlciBlbnRlciBhICcwJyBvbiB0aGUgZmFyIGxlZnQgd2l0aCBhIGxlYWRpbmcgemVybyBvcHRpb24gc2V0IHRvICdkZW55JywgdGhhdCB0aGUgY2FyZXQgZG9lcyBub3QgbW92ZXMgc2luY2UgdGhlIGlucHV0IGlzIGRyb3BwZWQgKGZpeCBpc3N1ZSAjMjgzKVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAxICYmIHBhcnRzWzBdID09PSAnMCcgJiYgc2V0dGluZ3NDbG9uZS5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZW50ZXIgYDBgLCB0aGVuIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgaXQgKEZpeCBpc3N1ZSAjMjk5KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1sxXSA9PT0gJycgfHwgcGFydHNbMF0gPT09ICcwJyAmJiBwYXJ0c1sxXSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYF9leHBhbmRTZWxlY3Rpb25PblNpZ24oKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gU2lnbiBwb3NpdGlvbiBvZiBhIGZvcm1hdHRlZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2dldFNpZ25Qb3NpdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2wgPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sO1xyXG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IGN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiB0aGF0LnZhbHVlICYmIHRoYXQudmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGN1cnJlbmN5U3ltYm9sTGVuICsgMV0gOiBbMCwgY3VycmVuY3lTeW1ib2xMZW5dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGF0LnZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBjdXJyZW5jeVN5bWJvbExlbiwgdmFsdWVMZW5dO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cclxuICAgICAgICAgKiBQcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcclxuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4gb25seSlcclxuICAgICAgICAgICAgLy9UT0RPIFVzZSBhcnJheSBkZXN0cnVjdHVyaW5nIGhlcmUgdG8gc2V0IHNpZ25Qb3NpdGlvbiB0byBtb3JlIGV4cGxpY2l0IHZhcmlhYmxlc1xyXG4gICAgICAgICAgICBjb25zdCBzaWduUG9zaXRpb24gPSB0aGlzLl9nZXRTaWduUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblsxXSAmJiBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdLCBzZXRSZWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oc2lnblBvc2l0aW9uWzFdLCBzZWxlY3Rpb24uZW5kLCBzZXRSZWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2Ugc2VsZWN0IHdpdGggd2hvbGUgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9jaGVja1Bhc3RlKCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN0cmlwIHRoZSBwYXN0ZWQgdmFsdWUgZmlyc3RcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvbGRQYXJ0cy5qb2luKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzLlxyXG4gICAgICAgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBUUlVFLCB0aGVuIGZ1cnRoZXIgcHJvY2Vzc2luZyBpcyBub3QgcGVyZm9ybWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3NraXBBbHdheXMoZSkge1xyXG4gICAgICAgICAgICAvLyBDYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcclxuICAgICAgICAgICAgaWYgKCgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS50eXBlID09PSAna2V5dXAnICYmICFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHx8IChlLnNoaWZ0S2V5ICYmIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNb3ZlIHRoaXMgdGVzdCBpbnNpZGUgdGhlIGBvbktleXVwYCBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNraXAgYWxsIGZ1bmN0aW9uIGtleXMgKEYxLUYxMiksIFdpbmRvd3Mga2V5cywgdGFiIGFuZCBvdGhlciBzcGVjaWFsIGtleXNcclxuICAgICAgICAgICAgaWYgKCh0aGlzLmV2ZW50S2V5Q29kZSA+PSBrZXlDb2RlLkYxICYmIHRoaXMuZXZlbnRLZXlDb2RlIDw9IGtleUNvZGUuRjEyKSB8fFxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5UYWIgJiYgdGhpcy5ldmVudEtleUNvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gYGUud2hpY2hgIGlzIHNvbWV0aW1lcyBkaWZmZXJlbnQgdGhhbiBgdGhpcy5ldmVudEtleUNvZGVgIGR1cmluZyB0aGUga2V5cHJlc3MgZXZlbnQgd2hlbiBlbnRlcmluZyBhIHByaW50YWJsZSBjaGFyYWN0ZXIga2V5IChpZS4gJ3QnKS4gQWxzbywgYGUud2hpY2hgIGVxdWFscyAwIGZvciBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxyXG4gICAgICAgICAgICAgICAgKGUud2hpY2ggPT09IDAgfHwgZS53aGljaCA9PT0gdGhpcy5ldmVudEtleUNvZGUpKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuTnVtTG9jayB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuU2Nyb2xsTG9jayB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0IHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5Db21tYW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYSBcIlNlbGVjdCBhbGxcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAoY3RybCArIGEpXHJcbiAgICAgICAgICAgIGlmICgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VsZWN0TnVtYmVyT25seSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpcyB1c2VkIGhlcmUgdG8gcHJldmVudCB0aGUgYnJvd3NlciB0byBmaXJzdCBzZWxlY3QgYWxsIHRoZSBpbnB1dCB0ZXh0IChpbmNsdWRpbmcgdGhlIGN1cnJlbmN5IHNpZ24pLCBvdGhlcndpc2Ugd2Ugd291bGQgc2VlIHRoYXQgd2hvbGUgc2VsZWN0aW9uIGZpcnN0IGluIGEgZmxhc2gsIHRoZW4gdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIG51bWJlciBwYXJ0IHdpdGhvdXQgdGhlIGN1cnJlbmN5IHNpZ24uXHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTGVuID0gdGhpcy50aGF0LnZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghaXNOZWdhdGl2ZSh0aGlzLnRoYXQudmFsdWUpKT8wOjE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4VGV4dExlbiA9IHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBjdXJyZW5jeVN5bWJvbExlbiA+IDApP2N1cnJlbmN5U3ltYm9sTGVuICsgMTpjdXJyZW5jeVN5bWJvbExlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBzdWZmaXhUZXh0TGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKHN1ZmZpeFRleHRMZW4gKyBjdXJyZW5jeVN5bWJvbExlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoY3VycmVuY3lTeW1ib2xMZW4gPiAwKT92YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIG5lZ0xlbiArIHN1ZmZpeFRleHRMZW4pOnZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sTGVuICsgc3VmZml4VGV4dExlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgXCJDb3B5XCIsIFwiUGFzdGVcIiBvciBcIkN1dFwiIGtleWJvYXJkIHNob3J0Y3V0IGlzIGRldGVjdGVkIChyZXNwZWN0aXZlbHkgJ2N0cmwgKyBjJywgJ2N0cmwgKyB2JyBvciAnY3RybCArIHgnKVxyXG4gICAgICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5jIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLnYgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUueCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUudiB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXN0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSnVtcCBvdmVyIHRob3VzYW5kIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAvL1RPRE8gTW92ZSB0aGlzIHRlc3QgaW5zaWRlIHRoZSBgb25LZXlkb3duYCBoYW5kbGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmICFlLnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMikgPT09IHRoaXMuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnRoYXQudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSkgPT09IHRoaXMuc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuUGFnZURvd24gJiYgdGhpcy5ldmVudEtleUNvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnMgd2hlbiB0aGUgbWludXMgc2lnbiBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIG51bWVyaWMgY2hhcmFjdGVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0IFRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHQgVGhlIHBhcnQgb24gdGhlIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cclxuICAgICAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpICYmIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5sZW5ndGggLSBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSAmJiBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpICsgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUobGVmdCkgJiYgdGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQpID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1lcmdlIHRoZSB0d28gZm9sbG93aW5nICdpZicgYmxvY2tzIGludG8gb25lIGBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7YCBhbmQgYSBzd2l0Y2ggb24gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudFxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAtIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2VzcyB0aGUgZGVsZXRpb24gb2YgY2hhcmFjdGVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxlZnQ7XHJcbiAgICAgICAgICAgIGxldCByaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCgoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNOZWdhdGl2ZSh0aGlzLnZhbHVlKSkgeyAvL1RPRE8gQ2hhbmdlIGB0aGlzLnZhbHVlYCB0byBgdGhpcy50aGF0LnZhbHVlYD9cclxuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbihbbGVmdCwgcmlnaHRdKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBkZWNpZGVzIGlmIHRoZSBrZXkgcHJlc3NlZCBzaG91bGQgYmUgZHJvcHBlZCBvciBhY2NlcHRlZCwgYW5kIG1vZGlmeSB0aGUgdmFsdWUgJ29uLXRoZS1mbHknIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqIFJldHVybnMgVFJVRSBpZiB0aGUga2V5Y29kZSBpcyBhbGxvd2VkLlxyXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb25zIGFsc28gbW9kaWZ5IHRoZSB2YWx1ZSBvbi10aGUtZmx5LiAvL0ZJWE1FIFRoaXMgc2hvdWxkIHVzZSBhbm90aGVyIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHNlcGFyYXRlIHRoZSB0ZXN0IGFuZCB0aGUgbW9kaWZpY2F0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fHN0cmluZ30gZXZlbnRPckNoYXIgVGhlIGV2ZW50IG9iamVjdCwgb3IgdGhlIGNoYXJhY3RlciBlbnRlcmVkIChmcm9tIGFuIGFuZHJvaWQgZGV2aWNlKVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKGV2ZW50T3JDaGFyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZXZlbnRDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhldmVudE9yQ2hhcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQgYnJvd3NlcnNcclxuICAgICAgICAgICAgICAgIGV2ZW50Q2hhcmFjdGVyID0gZXZlbnRPckNoYXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgYnJvd3NlcnNcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlYWwgY2hhcmFjdGVyIHRoYXQgaGFzIGJlZW4gZW50ZXJlZCAoaWUuICdhJyBpbnN0ZWFkIG9mIHRoZSBrZXkgY29kZSlcclxuICAgICAgICAgICAgICAgIGV2ZW50Q2hhcmFjdGVyID0gY2hhcmFjdGVyKGV2ZW50T3JDaGFyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBubyBkZWNpbWFsIHBhcnQgYWxsb3dlZFxyXG4gICAgICAgICAgICBpZiAoZXZlbnRDaGFyYWN0ZXIgPT09IHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICYmIGV2ZW50Q2hhcmFjdGVyID09PSBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgfHxcclxuICAgICAgICAgICAgICAgICgoZXZlbnRDaGFyYWN0ZXIgPT09ICcuJyB8fCBldmVudENoYXJhY3RlciA9PT0gJywnKSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5Eb3ROdW1wYWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUuZGVjaW1hbFBsYWNlc092ZXJyaWRlIHx8ICFzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIG5lZ2F0aXZlU2lnbkNoYXJhY3RlciBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyLCByaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbWludXMgaWYgbm90IGFsbG93ZWRcclxuICAgICAgICAgICAgaWYgKChldmVudENoYXJhY3RlciA9PT0gJy0nIHx8IGV2ZW50Q2hhcmFjdGVyID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbnVtYmVyIHNpZ24sIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlU3RyaWN0KGxlZnQpIHx8IGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoZXZlbnRDaGFyYWN0ZXIgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQgOiBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIG51bWJlciBzaWduLCByZW1vdmUgcGFydCBpZiBzaG91bGRcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChldmVudENoYXJhY3RlciA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdCA6IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB0cmllcyB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzIHNpZ25cclxuICAgICAgICAgICAgY29uc3QgZXZlbnROdW1iZXIgPSBOdW1iZXIoZXZlbnRDaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnROdW1iZXIgPj0gMCAmJiBldmVudE51bWJlciA8PSA5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgbGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm1heGltdW1WYWx1ZSA8PSAwICYmIHNldHRpbmdzQ2xvbmUubWluaW11bVZhbHVlIDwgc2V0dGluZ3NDbG9uZS5tYXhpbXVtVmFsdWUgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAmJiBldmVudENoYXJhY3RlciAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBldmVudENoYXJhY3RlciwgcmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2Zvcm1hdFZhbHVlKGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vIGdyb3VwaW5nIHNlcGFyYXRvciBhbmQgbm8gY3VycmVuY3kgc2lnblxyXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciAgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnICAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yKSkpICYmXHJcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgW3N1YlBhcnRzXSA9IGxlZnRMZW5ndGguc3BsaXQoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUoc3ViUGFydHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgblNpZ24gPSAnLSc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnRQb3MgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5TaWduICsgbGVmdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhZGRHcm91cFNlcGFyYXRvcnModGhpcy52YWx1ZSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgcmVnZXhwIHdoaWNoIHNlYXJjaGVzIGZvciBjdXJzb3IgcG9zaXRpb24gZnJvbSB1bmZvcm1hdHRlZCBsZWZ0IHBhcnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBclswXSA9PT0gJy0nICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBci5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnblBhcnRzID0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5zcGxpdCgnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVDaHIgPSBbJ1xcXFwnLCAnXicsICckJywgJy4nLCAnfCcsICc/JywgJyonLCAnKycsICcoJywgJyknLCAnWyddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFBhcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2lnblBhcnRzLCAoaSwgbWluaVBhcnRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaVBhcnRzID0gc2lnblBhcnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkobWluaVBhcnRzLCBlc2NhcGVDaHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCdcXFxcJyArIG1pbmlQYXJ0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2gobWluaVBhcnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZnRBcltpXS5tYXRjaCgnXFxcXGQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBvc2l0aXZlIHNpZ24gaXMgc2hvd24sIGNhbGN1bGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gYWNjb3JkaW5nbHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5zaG93UG9zaXRpdmVTaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBuZXdMZWZ0LmlucHV0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKG5ld0xlZnQuaW5wdXQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSA9PT0gMSkgPyBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArIDEgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgbmV3TGVmdC5pbnB1dC5jaGFyQXQoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpID09PSBzZXR0aW5nc0Nsb25lLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGJlZm9yZSB0aGUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKChwb3NpdGlvbiA9PT0gMCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgJiYgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGFmdGVyIHByZWZpeCBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBTaG91bGQgdGhlIHRlc3QgYmUgJ2lzTmVnYXRpdmUnIGluc3RlYWQgb2YgJ2lzTmVnYXRpdmVTdHJpY3QnIGluIG9yZGVyIHRvIHNlYXJjaCBmb3IgJy0nIGV2ZXJ5d2hlcmUgaW4gdGhlIHN0cmluZz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgKGlzTmVnYXRpdmVTdHJpY3QodmFsdWUpID8gMSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgJiYgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHNpZ24gYXMgYSBzdWZmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0IGhhcyBjaGFuZ2VkLiBUaGlzIHByZXZlbnRzIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLCBpZiBhbnkuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy50aGF0LnZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdGhpcy50aGF0LnZhbHVlICYmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW0wIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bXBhZDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGFuIEFuZHJvaWQgYnJvd3NlciBpcyBkZXRlY3RlZCwgZml4IHRoZSBjYXJldCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIGRvZXMgbm90IGZpeCBhbGwgYW5kcm9pZCBicm93c2Vycywgb25seSBBbmRyb2lkIENocm9tZSBjdXJyZW50bHkuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGR1ZSB0byB0aGUgZmFjdCB0aG9zZSBwcm92aWRlIGRpZmZlcmVudCBvcmRlciBvZiBldmVudHMgYW5kL29yIGtleWNvZGVzIHRocm93biAodGhpcyBpcyBhIHJlYWwgbWVzcyA6fCkuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHNldHRpbmdzQ2xvbmUuYW5kcm9pZFNlbGVjdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlOyAvL1RPRE8gUmVuYW1lIGB0aGlzLmZvcm1hdHRlZGAgdG8gYHRoaXMuX2Zvcm1hdEV4ZWN1dGVkYCwgc2luY2UgaXQncyBwb3NzaWJsZSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gZm9ybWF0IGFueXRoaW5nIChpbiB0aGUgY2FzZSB3aGVyZSB0aGUga2V5Y29kZSBpcyBkcm9wcGVkIGZvciBpbnN0YW5jZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cclxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXHJcbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBnZXRBcnJheUJlaGF2aW9yIC0gSWYgc2V0IHRvIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBiZWhhdmUgbGlrZSBgZ2V0QXJyYXkoKWAsIG90aGVyd2lzZSBpZiBzZXQgdG8gRkFMU0UsIGl0IGJlaGF2ZSBsaWtlIGBnZXRTdHJpbmcoKWBcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0U3RyaW5nT3JBcnJheShnZXRBcnJheUJlaGF2aW9yID0gdHJ1ZSwgdGhhdCkge1xyXG4gICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhhdCk7XHJcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcclxuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcclxuICAgICAgICBjb25zdCBhaUluZGV4ID0gW107XHJcblxyXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxyXG4gICAgICAgIGNvbnN0IHNjSW5kZXggPSBbXTtcclxuXHJcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XHJcbiAgICAgICAgY29uc3QgclN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pO1xyXG5cclxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXHJcbiAgICAgICAgY29uc3QgclN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xyXG5cclxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXHJcbiAgICAgICAgY29uc3QgckNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcclxuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xyXG5cclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG5cclxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXHJcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gaW5kZXggb2YgYWxsIGlucHV0cyB0YWdzIGV4Y2VwdCBjaGVja2JveFxyXG4gICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiAoZmllbGQudHlwZSA9PT0gJycgfHwgZmllbGQudHlwZSA9PT0gJ3RleHQnIHx8IGZpZWxkLnR5cGUgPT09ICdoaWRkZW4nIHx8IGZpZWxkLnR5cGUgPT09ICd0ZWwnKSkge1xyXG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplQXJyYXkoKTtcclxuXHJcbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9IHNjSW5kZXguaW5kZXhPZihpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXROYW1lLCBpbnB1dFZhbHVlXSA9IGZvcm1QYXJ0c1tpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gc2NJbmRleC5pbmRleE9mKGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSB2YWxpZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3VzaW4nIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpIHtcclxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xyXG5cclxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXNpbicgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgISR0aGlzLmlzKCc6Zm9jdXMnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChlLnRhcmdldC52YWx1ZSwgc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2xlYW4gdGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gcmF3VmFsdWVcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhlLnRhcmdldC52YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKHJlc3VsdCwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHJlc3VsdCwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJy0nICsgcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcm91bmRlZFZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cztcclxuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVmFsdWUoc2V0dGluZ3MucmF3VmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIGFkZEdyb3VwU2VwYXJhdG9ycyhyb3VuZGVkVmFsdWUsIHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3Mub0RlYyk7XHJcbiAgICAgICAgICAgICAgICByb3VuZGVkVmFsdWUgPSByb3VuZFZhbHVlKHNldHRpbmdzLnJhd1ZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCBhZGRHcm91cFNlcGFyYXRvcnMocm91bmRlZFZhbHVlLCBzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgPSAnJztcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnN1ZmZpeFRleHQgPSAnJztcclxuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVmFsdWUoc2V0dGluZ3MucmF3VmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIGFkZEdyb3VwU2VwYXJhdG9ycyhyb3VuZGVkVmFsdWUsIHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSBzZXR0aW5ncy5yYXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgcmF3VmFsdWVcclxuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBzZW5kIGEgJ25hdGl2ZScgY2hhbmdlIGV2ZW50IHdoZW4gYmx1cnJpbmcgdGhlIGlucHV0LCB3ZSBuZWVkIHRvIGZpcnN0IHN0b3JlIHRoZSBpbml0aWFsIGlucHV0IHZhbHVlIG9uIGZvY3VzLlxyXG4gICAgICAgICAgICBob2xkZXIudmFsdWVPbkZvY3VzID0gZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gaG9sZGVyLnZhbHVlT25Gb2N1cztcclxuICAgICAgICAgICAgY29uc3Qgb25FbXB0eSA9IGNoZWNrRW1wdHkoaG9sZGVyLnZhbHVlT25Gb2N1cywgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoKG9uRW1wdHkgIT09IG51bGwgJiYgb25FbXB0eSAhPT0gJycpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgb25FbXB0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob25FbXB0eSA9PT0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2tleWRvd24nIGV2ZW50cy5cclxuICAgICAqIFRoZSB1c2VyIGp1c3Qgc3RhcnRlZCBwdXNoaW5nIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgOlxyXG4gICAgICogQnkgZGVmYXVsdCBhICdub3JtYWwnIGlucHV0IG91dHB1dCB0aG9zZSBldmVudHMgaW4gdGhlIHJpZ2h0IG9yZGVyIHdoZW4gaW5wdXR0aW5nIGEgY2hhcmFjdGVyIGtleSAoaWUuICdhJykgOlxyXG4gICAgICogLSBrZXlkb3duXHJcbiAgICAgKiAtIGtleXByZXNzXHJcbiAgICAgKiAtIGlucHV0XHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKlxyXG4gICAgICogLi4ud2hlbiBpbnB1dHRpbmcgYSBtb2RpZmllciBrZXkgKGllLiAnY3RybCcpIDpcclxuICAgICAqIC0ga2V5ZG93blxyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICpcclxuICAgICAqIElmICdkZWxldGUnIG9yICdiYWNrc3BhY2UnIGlzIGVudGVyZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcclxuICAgICAqIC0ga2V5ZG93blxyXG4gICAgICogLSBpbnB1dFxyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICpcclxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxyXG4gICAgICogLSBrZXlkb3duXHJcbiAgICAgKiAtIGtleXByZXNzXHJcbiAgICAgKiAtIGtleXVwXHJcbiAgICAgKlxyXG4gICAgICogSWYgJ2VudGVyJyBpcyBlbnRlcmVkIGFuZCB0aGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxyXG4gICAgICogLSBrZXlkb3duXHJcbiAgICAgKiAtIGtleXByZXNzXHJcbiAgICAgKiAtIGNoYW5nZVxyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICpcclxuICAgICAqIFdoZW4gYSBwYXN0ZSBpcyBkb25lLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XHJcbiAgICAgKiAtIGlucHV0IChpZiBwYXN0ZSBpcyBkb25lIHdpdGggdGhlIG1vdXNlKVxyXG4gICAgICpcclxuICAgICAqIC0ga2V5ZG93biAoaWYgcGFzdGUgaXMgZG9uZSB3aXRoIGN0cmwrdilcclxuICAgICAqIC0ga2V5ZG93blxyXG4gICAgICogLSBpbnB1dFxyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICogLSBrZXl1cFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbktleWRvd24oaG9sZGVyLCBlKSB7XHJcbiAgICAgICAgLy9UT0RPIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmUgdGhlIGVsZW1lbnQgdmFsdWUgKGVpdGhlciBieSB1c2luZyBgZS50YXJnZXQudmFsdWVgIHdoZW4gdGhlIGVsZW1lbnQgaXMgYW4gPGlucHV0Piwgb3IgYnkgdXNpbmcgYGVsZW1lbnQudGV4dENvbnRlbnRgIHdoZW4gdGhlIGVsZW1lbnQgYXMgaXRzIGBjb250ZW50ZWRpdGFibGVgIHNldCB0byB0cnVlKVxyXG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUoZSk7XHJcbiAgICAgICAgaG9sZGVyLmluaXRpYWxWYWx1ZU9uS2V5ZG93biA9IGUudGFyZ2V0LnZhbHVlOyAvLyBUaGlzIGlzIG5lZWRlZCBpbiBgb25LZXl1cCgpYCB0byBjaGVjayBpZiB0aGUgdmFsdWUgYXMgY2hhbmdlZCBkdXJpbmcgdGhlIGtleSBwcmVzc1xyXG5cclxuICAgICAgICBpZiAoaG9sZGVyLnRoYXQucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgXCJlbnRlclwiIGtleSB0aHJvd3MgYSBgY2hhbmdlYCBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGBmb2N1c2AgZXZlbnRcclxuICAgICAgICBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5FbnRlciAmJiBob2xkZXIudmFsdWVPbkZvY3VzICE9PSBlLnRhcmdldC52YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2NoYW5nZScsIGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMoZSk7XHJcblxyXG4gICAgICAgIGlmIChob2xkZXIuX3NraXBBbHdheXMoZSkpIHtcclxuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUga2V5IGlzIGEgZGVsZXRlL2JhY2tzcGFjZSBrZXlcclxuICAgICAgICBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpIHtcclxuICAgICAgICAgICAgaG9sZGVyLl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKTsgLy8gQmVjYXVzZSBiYWNrc3BhY2UgYW5kIGRlbGV0ZSBvbmx5IHRyaWdnZXJzIGtleWRvd24gYW5kIGtleXVwIGV2ZW50cywgbm90IGtleXByZXNzXHJcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFZhbHVlKGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYW5kIG9ubHkgaWYgdGhlIHJlc3VsdGluZyB2YWx1ZSBoYXMgY2hhbmdlZCBhZnRlciB0aGF0IGJhY2tzcGFjZS9kZWxldGUsIHRoZW4gd2UgaGF2ZSB0byBzZW5kIGFuICdpbnB1dCcgZXZlbnQgbGlrZSBicm93c2VycyBub3JtYWxseSBkby5cclxuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIGlucHV0IGV2ZW50IHdoZW4gYSBjaGFyYWN0ZXIgZGVsZXRpb24gaXMgZGV0ZWN0ZWRcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGRlbGV0ZSBhIHNlY29uZCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7IC8vVE9ETyBJcyB0aGlzIGxpbmUgbmVlZGVkP1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXByZXNzJyBldmVudHMuXHJcbiAgICAgKiBUaGUgdXNlciBpcyBzdGlsbCBwcmVzc2luZyB0aGUga2V5LCB3aGljaCB3aWxsIG91dHB1dCBhIGNoYXJhY3RlciAoaWUuICcyJykgY29udGludW91c2x5IHVudGlsIGl0IHJlbGVhc2VzIHRoZSBrZXkuXHJcbiAgICAgKiBOb3RlOiAna2V5cHJlc3MnIGV2ZW50cyBhcmUgbm90IHNlbnQgZm9yIGRlbGV0ZSBrZXlzIGxpa2UgQmFja3NwYWNlL0RlbGV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25LZXlwcmVzcyhob2xkZXIsIGUpIHtcclxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVhbCBjaGFyYWN0ZXIgdGhhdCBoYXMgYmVlbiBlbnRlcmVkIChpZS4gJ2EnIGluc3RlYWQgb2YgdGhlIGtleSBjb2RlKVxyXG4gICAgICAgIGNvbnN0IGV2ZW50Q2hhcmFjdGVyID0gY2hhcmFjdGVyKGUpO1xyXG5cclxuICAgICAgICAvLyBGaXJlZm94IGdlbmVyYXRlIGEgJ2tleXByZXNzJyBldmVudCAoZS5rZXlDb2RlID09PSAwKSBmb3IgdGhlIGtleXMgdGhhdCBkbyBub3QgcHJpbnQgYSBjaGFyYWN0ZXIgKGllLiAnSW5zZXJ0JywgJ0RlbGV0ZScsICdGbicga2V5cywgJ1BhZ2VVcCcsICdQYWdlRG93bicgZXRjLikuICdTaGlmdCcgb24gdGhlIG90aGVyIGhhbmQgZG9lcyBub3QgZ2VuZXJhdGUgYSBrZXlwcmVzcyBldmVudC5cclxuICAgICAgICBpZiAoZXZlbnRDaGFyYWN0ZXIgPT09IGtleU5hbWUuSW5zZXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XHJcbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMoZSk7XHJcblxyXG4gICAgICAgIGlmIChob2xkZXIuX3NraXBBbHdheXMoZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQgPSBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oZSk7XHJcbiAgICAgICAgaWYgKGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFZhbHVlKGUpO1xyXG4gICAgICAgICAgICBpZiAoKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBhIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gLi4uYW5kIGltbWVkaWF0ZWx5IHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gYWRkIGEgc2Vjb25kIGNoYXJhY3RlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChldmVudENoYXJhY3RlciA9PT0gaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgfHwgZXZlbnRDaGFyYWN0ZXIgPT09IGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLnN0YXJ0ID09PSBnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5lbmQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IGUudGFyZ2V0LnZhbHVlLmluZGV4T2YoaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5zdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgcG9zaXRpb24sIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdpbnB1dCcgZXZlbnRzLlxyXG4gICAgICogYWRkZWQgdG8gc3VwcG9ydCBhbmRyb2lkIGRldmljZXMgd2l0aCBtb2JpbGUgY2hyb21lIGJyb3dzZXJzIGFuZCBvdGhlcnNcclxuICAgICAqIEhhcyB0aGUgcG90ZW50aWFsIHRvIHJlcGxhY2UgdGhlIGtleXByZXNzIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbklucHV0KGhvbGRlciwgZSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XHJcblxyXG4gICAgICAgIC8vIEZpeCB0aGUgY2FyZXQgcG9zaXRpb24gb24ga2V5dXAgaW4gdGhlIGBfZm9ybWF0VmFsdWUoKWAgZnVuY3Rpb25cclxuICAgICAgICBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQW5kcm9pZERlZmF1bHQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGtleUNvZGUgaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgQW5kcm9pZCBDaHJvbWUgb25lICh3aGljaCBpcyBhbHdheXMgZXF1YWwgdG8gYGtleUNvZGUuQW5kcm9pZERlZmF1bHRgKVxyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gaG9sZGVyLmxhc3RWYWwubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCA+PSBob2xkZXIubGFzdFZhbC5sZW5ndGggLSBob2xkZXIuc2VsZWN0aW9uLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBrZXljb2RlIG9mIHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgZW50ZXJlZCwgYW5kIG92ZXJ3cml0ZSB0aGUgZmF1bHR5IGBldmVudEtleUNvZGVgIGluZm8gd2l0aCBpdFxyXG4gICAgICAgICAgICAgICAgaG9sZGVyLmV2ZW50S2V5Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaG9sZGVyLnNlbGVjdGlvbi5zdGFydCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgYWN0dWFsIGNoYXJhY3RlciBlbnRlcmVkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmRyb2lkQ2hhckVudGVyZWQgPSB2YWx1ZS5jaGFyQXQoaG9sZGVyLnNlbGVjdGlvbi5zdGFydCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIGNoYXJhY3RlciBzaG91bGQgYmUgaW5zZXJ0ZWQsIGFuZCBpZiBzbywgZG8gaW5zZXJ0IGl0IGludG8gdGhlIGN1cnJlbnQgZWxlbWVudCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gaG9sZGVyLl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKGFuZHJvaWRDaGFyRW50ZXJlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93ZWQgY2hhcmFjdGVyIGVudGVyZWQgKG51bWJlciwgZGVjaW1hbCBvciBwbHVzL21pbnVzIHNpZ24pXHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgbmV3IGNhcmV0IHBvc2l0aW9uLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2Ugb24ga2V5dXAsIGBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUoKWAgY2FwdHVyZXMgdGhlIG9sZCBjYXJldCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBDaGVjayBpZiB0aGlzIGlzIGFuIEFuZHJvaWQgYnVnIG9yIGFuIGF1dG9OdW1lcmljIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgPSBob2xkZXIuc2VsZWN0aW9uLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPSBlLnRhcmdldC52YWx1ZS5pbmRleE9mKGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNEZWNpbWFsQ2hhcmFjdGVyID0gZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uID09PSAtMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgY2FyZXQgdG8gdGhlIHJpZ2h0IGlmIHRoZSBgYW5kcm9pZENoYXJFbnRlcmVkYCBpcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgb3IgaWYgaXQncyBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5kcm9pZENoYXJFbnRlcmVkID09PSBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaGFzRGVjaW1hbENoYXJhY3RlciAmJiBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPCBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5ncy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgPSBob2xkZXIuc2VsZWN0aW9uLnN0YXJ0ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC52YWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gdGhlIGNhcmV0IHJpZ2h0IG5vdyBiZWZvcmUgdGhlICdrZXl1cCcgZXZlbnQgaW4gb3JkZXIgdG8gcHJldmVudCB0aGUgY2FyZXQgZnJvbSBqdW1waW5nIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuYW5kcm9pZFNlbGVjdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVudGVyZWQgY2hhcmFjdGVyIGlzIG5vdCBhbGxvd2VkIDsgb3ZlcndyaXRlIHRoZSBuZXcgaW52YWxpZCB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyB2YWxpZCBvbmUsIGFuZCBzZXQgYmFjayB0aGUgY2FyZXQvc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQudmFsdWUgPSBob2xkZXIubGFzdFZhbDtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBob2xkZXIuc2VsZWN0aW9uLnN0YXJ0LCBob2xkZXIuc2VsZWN0aW9uLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IGhvbGRlci5zZWxlY3Rpb24uc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvL0ZJWE1FIEhvdyBkb2VzIHRoYXQgYWZmZWN0cyB0aGUgbm9ybWFsIHRyaWdnZXIgb2YgdGhlIGlucHV0IGV2ZW50P1xyXG5cclxuICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENoYXJhY3RlciBkZWxldGVkXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gV2hhdCBhYm91dCB0aGUgYERlbGV0ZWAga2V5P1xyXG4gICAgICAgICAgICAgICAgaG9sZGVyLmV2ZW50S2V5Q29kZSA9IGtleUNvZGUuQmFja3NwYWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXVwJyBldmVudHMuXHJcbiAgICAgKiBUaGUgdXNlciBqdXN0IHJlbGVhc2VkIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uS2V5dXAoaG9sZGVyLCBzZXR0aW5ncywgZSkge1xyXG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKGUpO1xyXG5cclxuICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLl9za2lwQWx3YXlzKGUpO1xyXG4gICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xyXG4gICAgICAgIGNvbnN0IGlzT25BbmRyb2lkID0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ICE9PSBudWxsO1xyXG4gICAgICAgIGlmIChza2lwICYmICFpc09uQW5kcm9pZCB8fCBlLnRhcmdldC52YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuVGFiKSB7XHJcbiAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSB8fFxyXG4gICAgICAgICAgICAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJykpIHtcclxuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXHJcbiAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xyXG4gICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKGUudGFyZ2V0LCBzZXR0aW5ncywgJ3NldCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFob2xkZXIuZm9ybWF0dGVkKSB7XHJcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3MgZXZlbnQgY2hhaW4sIGFuIGV2ZW50IGlzIHNlbnQgdG8gYWxlcnQgdGhhdCBhIGZvcm1hdHRpbmcgaGFzIGJlZW4gZG9uZSAoY2YuIElzc3VlICMxODcpXHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIuaW5pdGlhbFZhbHVlT25LZXlkb3duKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnYXV0b051bWVyaWM6Zm9ybWF0dGVkJywgZS50YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c291dCcgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpIHtcclxuICAgICAgICBpZiAoISR0aGlzLmlzKCc6Zm9jdXMnKSkge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9IHNldHRpbmdzLm9TZXA7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9IHNldHRpbmdzLm9TaWduO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9IHNldHRpbmdzLm9TdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5vRGVjO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZyA9IHNldHRpbmdzLm9QYWQ7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9IHNldHRpbmdzLm9CcmFja2V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpID09PSBudWxsICYmIG1pblRlc3QgJiYgbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpID8gTnVtYmVyKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgOiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJzAnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSgnMCcsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGdyb3VwZWRWYWx1ZSA9IGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IChzZXR0aW5ncy5zY2FsZVN5bWJvbCkgPyBncm91cGVkVmFsdWUgKyBzZXR0aW5ncy5zY2FsZVN5bWJvbCA6IGdyb3VwZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIGdyb3VwZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhvbGRlci52YWx1ZU9uRm9jdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAncGFzdGUnIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvblBhc3RlKCR0aGlzLCBob2xkZXIsIGUpIHtcclxuICAgICAgICAvL1RPRE8gVXNpbmcgY3RybCt6IGFmdGVyIGEgcGFzdGUgc2hvdWxkIGNhbmNlbCBpdCAtPiBIb3cgd291bGQgdGhhdCBhZmZlY3Qgb3RoZXIgZnJhbWV3b3Jrcy9jb21wb25lbnQgYnVpbHQgd2l0aCB0aGF0IGZlYXR1cmUgaW4gbWluZCB0aG91Z2g/XHJcbiAgICAgICAgLy9GSVhNRSBXaGVuIHBhc3RpbmcgJzAwMCcgb24gYSB0aG91c2FuZCBncm91cCBzZWxlY3Rpb24sIHRoZSB3aG9sZSBzZWxlY3Rpb24gZ2V0cyBkZWxldGVkLCBhbmQgb25seSBvbmUgJzAnIGlzIHBhc3RlZCAoY2YuIGlzc3VlICMzMDIpXHJcbiAgICAgICAgLy8gVGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBkZWZhdWx0LCBzaW5jZSBvdGhlcndpc2UgdGhlIHVzZXIgd291bGQgYmUgYWJsZSB0byBwYXN0ZSBpbnZhbGlkIGNoYXJhY3RlcnMgaW50byB0aGUgaW5wdXRcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGxldCByYXdQYXN0ZWRUZXh0ID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcclxuXHJcbiAgICAgICAgLy8gMC4gU3BlY2lhbCBjYXNlIGlmIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCBhbGwgdGhlIGlucHV0IHRleHQgYmVmb3JlIHBhc3RpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsRm9ybWF0dGVkVmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uRW5kIHx8IDA7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU2l6ZSA9IHNlbGVjdGlvbkVuZCAtIHNlbGVjdGlvblN0YXJ0O1xyXG4gICAgICAgIGxldCBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3Rpb25TaXplID09PSBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIHBhc3RlIGhhcyBhIG5lZ2F0aXZlIHNpZ24gKG9ubHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyKSwgYW5kIHN0b3JlIHRoYXQgaW5mb3JtYXRpb24gZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgIGNvbnN0IGlzUGFzdGVOZWdhdGl2ZSA9IGlzTmVnYXRpdmVTdHJpY3QocmF3UGFzdGVkVGV4dCk7XHJcbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAvLyAxYS4gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGZyb20gdGhlIHBhc3RlZCB0ZXh0XHJcbiAgICAgICAgICAgIHJhd1Bhc3RlZFRleHQgPSByYXdQYXN0ZWRUZXh0LnNsaWNlKDEsIHJhd1Bhc3RlZFRleHQubGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIuIFN0cmlwIGFsbCB0aG91c2FuZCBzZXBhcmF0b3JzLCBicmFja2V0cyBhbmQgY3VycmVuY3kgc2lnbiwgYW5kIGNvbnZlcnQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIGEgZG90XHJcbiAgICAgICAgY29uc3QgdW50cmFuc2xhdGVkUGFzdGVkVGV4dCA9IHByZXBhcmVQYXN0ZWRUZXh0KHJhd1Bhc3RlZFRleHQsIGhvbGRlcik7XHJcblxyXG4gICAgICAgIGxldCBwYXN0ZWRUZXh0O1xyXG4gICAgICAgIGlmICh1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0ID09PSAnLicpIHtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIDogSWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFzdGUgYSBzaW5nbGUgZGVjaW1hbCBjaGFyYWN0ZXIgKHRoYXQgaGFzIGJlZW4gdHJhbnNsYXRlZCB0byAnLicgYWxyZWFkeSlcclxuICAgICAgICAgICAgcGFzdGVkVGV4dCA9ICcuJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWwgY2FzZVxyXG4gICAgICAgICAgICAvLyBBbGxvdyBwYXN0aW5nIGFyYWJpYyBudW1iZXJzXHJcbiAgICAgICAgICAgIHBhc3RlZFRleHQgPSBhcmFiaWNUb0xhdGluTnVtYmVycyh1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0LCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDMuIFRlc3QgaWYgdGhlIHBhc3RlIGlzIHZhbGlkIChvbmx5IGhhcyBudW1iZXJzIGFuZCBldmVudHVhbGx5IGEgZGVjaW1hbCBjaGFyYWN0ZXIpLiBJZiBpdCdzIG5vdCB2YWxpZCwgc3RvcCBoZXJlLlxyXG4gICAgICAgIGlmIChwYXN0ZWRUZXh0ICE9PSAnLicgJiYgKCFpc051bWJlcihwYXN0ZWRUZXh0KSB8fCBwYXN0ZWRUZXh0ID09PSAnJykpIHtcclxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFNob3VsZCB3ZSBzZW5kIGEgd2FybmluZyBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yP1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgaXMgbm90IGEgdmFsaWQgcGFzdGUgY29udGVudC5gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNC4gQ2FsY3VsYXRlIHRoZSBwYXN0ZSByZXN1bHRcclxuICAgICAgICBsZXQgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3Rpbmc7XHJcbiAgICAgICAgbGV0IGluaXRpYWxVbmZvcm1hdHRlZE51bWJlcjtcclxuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIGF1dG9OdW1lcmljICdnZXQnIHJldHVybnMgJzAuMDAnIGlmIHRoZSBpbnB1dCBpcyBlbXB0eSwgaGVuY2Ugd2UgbmVlZCB0byBzdG9yZSB0aGUgJ3JlYWwnIGVtcHR5IGluaXRpYWwgdmFsdWUgd2hlbiBuZWVkZWRcclxuICAgICAgICAgICAgLy9GSVhNRSBUaGlzIGhhcyBiZWVuIGZpeGVkIGluIGEgcHJldmlvdXMgY29tbWl0LCBnZXQgc2hvdWxkIHJldHVybiAnJyBvbiBhbiBlbXB0eSBpbnB1dC4gUmVtb3ZlIHRoaXMgdW5uZWVkZWQgJ2lmJ1xyXG4gICAgICAgICAgICBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSAnJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZVN0cmljdChpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIpO1xyXG4gICAgICAgIGxldCBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlO1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBwYXN0ZWQgY29udGVudCBpcyBuZWdhdGl2ZSwgdGhlbiB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUgdG9vXHJcbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSAmJiAhaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSBgLSR7aW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyfWA7XHJcbiAgICAgICAgICAgIGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSBmYWxzZTtcclxuICAgICAgICBsZXQgbGVmdFBhcnQ7XHJcbiAgICAgICAgbGV0IHJpZ2h0UGFydDtcclxuICAgICAgICBzd2l0Y2ggKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSkge1xyXG4gICAgICAgICAgICAvKiA0YS4gVHJ1bmNhdGUgcGFzdGUgYmVoYXZpb3I6XHJcbiAgICAgICAgICAgICAqIEluc2VydCBhcyBtYW55IG51bWJlcnMgYXMgcG9zc2libGUgb24gdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiB0aGUgY2FyZXQgZnJvbSB0aGUgcGFzdGVkIHRleHQgY29udGVudCwgdW50aWwgdGhlIGlucHV0IHJlYWNoIGl0cyByYW5nZSBsaW1pdC5cclxuICAgICAgICAgICAgICogSWYgdGhlcmUgaXMgbW9yZSBjaGFyYWN0ZXJzIGluIHRoZSBjbGlwYm9hcmQgb25jZSBhIGxpbWl0IGlzIHJlYWNoZWQsIGRyb3AgdGhlIGV4dHJhbmVvdXMgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICogT3RoZXJ3aXNlIHBhc3RlIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgY2xpcGJvYXJkLlxyXG4gICAgICAgICAgICAgKiBXaGlsZSBkb2luZyBzbywgd2UgY2hlY2sgaWYgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGFsbG93ZWQsIGFuZCBzdG9wIGFzIHNvb24gYXMgd2UgZW5jb3VudGVyIG9uZSBvZiB0aG9zZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogNGIuIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3I6XHJcbiAgICAgICAgICAgICAqIElkZW0gdGhhbiB0aGUgJ3RydW5jYXRlJyBwYXN0ZSBiZWhhdmlvciwgZXhjZXB0IHRoYXQgd2hlbiBhIHJhbmdlIGxpbWl0IGlzIGhpdCwgd2UgdHJ5IHRvIHJlcGxhY2UgdGhlIHN1YnNlcXVlbnQgaW5pdGlhbCBudW1iZXJzIHdpdGggdGhlIHBhc3RlZCBvbmVzLCB1bnRpbCB3ZSBoaXQgdGhlIHJhbmdlIGxpbWl0IGEgc2Vjb25kIChhbmQgbGFzdCkgdGltZSwgb3Igd2UgcnVuIG91dCBvZiBudW1iZXJzIHRvIHBhc3RlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY2FzZS1kZWNsYXJhdGlvbnM6IDAgKi9cclxuICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxyXG4gICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0ID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Rm9ybWF0dGVkUGFydCA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZShzZWxlY3Rpb25FbmQsIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYS4gSWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgc2VsZWN0ZWQgcGFydCwgYW5kIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGxlZnRGb3JtYXR0ZWRQYXJ0ICsgcmlnaHRGb3JtYXR0ZWRQYXJ0LCBob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiLiBFbHNlIGlmIHRoaXMgaXMgb25seSBvbmUgY2FyZXQgKGFuZCB0aGVyZWZvcmUgbm8gc2VsZWN0aW9uKSwgdGhlbiByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChpbml0aWFsRm9ybWF0dGVkVmFsdWUsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSB1bmZvcm1hdHRlZCByZXN1bHQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgcGFzdGUgaXMgbmVnYXRpdmUgYW5kIHRoZSBpbml0aWFsIHZhbHVlIGlzIG5vdCwgdGhlbiBJIG11c3Qgb2Zmc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBieSBvbmUgcGxhY2UgdG8gdGhlIHJpZ2h0IHRvIHRha2UgdGhlIGFkZGl0aW9uYWwgaHlwaGVuIGludG8gYWNjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKys7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJlc3VsdC5zbGljZShjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgcmVzdWx0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFzdGVkVGV4dCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnRQYXJ0LCAnLicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIEkgcmVtb3ZlIGEgZG90IGhlcmUsIHRoZW4gSSBuZWVkIHRvIHVwZGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gKGRlY3JlbWVudCBpdCBieSAxKSB3aGVuIHBvc2l0aW9uaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGRvIHNvLCB3ZSBrZWVwIHRoYXQgaW5mbyBpbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0Q29udGFpbmVkQURvdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gbGVmdFBhcnQucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmlnaHRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAtLSBIZXJlLCB3ZSBhcmUgZ29vZCB0byBnbyB0byBjb250aW51ZSBvbiB0aGUgc2FtZSBiYXNpc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGMuIEFkZCBudW1iZXJzIG9uZSBieSBvbmUgYXQgdGhlIGNhcmV0IHBvc2l0aW9uLCB3aGlsZSB0ZXN0aW5nIGlmIHRoZSByZXN1bHQgaXMgdmFsaWQgYW5kIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVcclxuICAgICAgICAgICAgICAgIC8vICAgIENvbnRpbnVlIHVudGlsIHlvdSBlaXRoZXIgcnVuIG91dCBvZiBudW1iZXJzIHRvIHBhc3RlLCBvciB0aGF0IHlvdSBnZXQgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pblBhcnNlID0gcGFyc2VTdHIoaG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKGhvbGRlci5zZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7IC8vIFRoaXMgaXMgc2V0IGFzIHRoZSBkZWZhdWx0LCBpbiBjYXNlIHdlIGRvIG5vdCBhZGQgZXZlbiBvbmUgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICBsZXQgcGFzdGVkVGV4dEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdFBhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhc3RlZFRleHRJbmRleCA8IHBhc3RlZFRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSByZXN1bHQgd2l0aCBhbm90aGVyIHBhc3RlZCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZExlZnRQYXJ0ICs9IHBhc3RlZFRleHRbcGFzdGVkVGV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb2RpZmllZExlZnRQYXJ0ICsgcmlnaHRQYXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgbGltaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmSW5SYW5nZShyZXN1bHQsIG1pblBhcnNlLCBtYXhQYXJzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cywgc3RvcCB0aGUgbG9vcCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBnb29kIGtub3duIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkVGV4dEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nICs9IHBhc3RlZFRleHRJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1hYWCBIZXJlIHdlIGhhdmUgdGhlIHJlc3VsdCBmb3IgdGhlIGB0cnVuY2F0ZWAgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAndHJ1bmNhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIElmIHRoZSB1c2VyIGFzIGRlZmluZWQgYSB0cnVuY2F0ZSBjYWxsYmFjayBhbmQgdGhlcmUgYXJlIHN0aWxsIHNvbWUgbnVtYmVycyAodGhhdCB3aWxsIGJlIGRyb3BwZWQpLCB0aGVuIGNhbGwgdGhpcyBjYWxsYmFjayB3aXRoIHRoZSBpbml0aWFsIHBhc3RlIGFzIHdlbGwgYXMgdGhlIHJlbWFpbmluZyBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRvdCBoYXMgYmVlbiByZW1vdmVkIGZvciB0aGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQsIHdlIGRlY3JlbWVudCB0aGUgY2FyZXQgaW5kZXggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL1hYWCAuLi5lbHNlIHdlIG5lZWQgdG8gY29udGludWUgbW9kaWZ5aW5nIHRoZSByZXN1bHQgZm9yIHRoZSAncmVwbGFjZScgb3B0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZC4gVW50aWwgdGhlcmUgYXJlIG51bWJlcnMgdG8gcGFzdGUsIHJlcGxhY2UgdGhlIGluaXRpYWwgbnVtYmVycyBvbmUgYnkgb25lLCBhbmQgc3RpbGwgZG8gdGhlIHJhbmdlIHRlc3QuXHJcbiAgICAgICAgICAgICAgICAvLyAgICBTdG9wIHdoZW4geW91IGhhdmUgbm8gbW9yZSBudW1iZXJzIHRvIHBhc3RlLCBvciBpZiB5b3UgYXJlIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLlxyXG4gICAgICAgICAgICAgICAgLy8gICAgSWYgeW91IGRvIGdldCB0byB0aGUgcmFuZ2UgbGltaXRzLCB1c2UgdGhlIHByZXZpb3VzIGtub3duIGdvb2QgdmFsdWUgd2l0aGluIHRob3NlIGxpbWl0cy5cclxuICAgICAgICAgICAgICAgIC8vICAgIE5vdGU6IFRoZSBudW1iZXJzIGFyZSByZXBsYWNlZCBvbmUgYnkgb25lLCBpbiB0aGUgaW50ZWdlciB0aGVuIGRlY2ltYWwgcGFydCwgd2hpbGUgaWdub3JpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gV2hhdCBzaG91bGQgaGFwcGVuIGlmIHRoZSB1c2VyIHRyeSB0byBwYXN0ZSBhIGRlY2ltYWwgbnVtYmVyPyBTaG91bGQgd2Ugb3ZlcnJpZGUgdGhlIGN1cnJlbnQgaW5pdGlhbCBkZWNpbWFsIGNoYXJhY3RlciBpbiBmYXZvciBvZiB0aGlzIG5ldyBvbmU/IElmIHdlIGRvLCB0aGVuIHdlIGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlIHZNaW4vdk1heCBmcm9tIHRoZSBzdGFydCBpbiBvcmRlciB0byB0YWtlIGludG8gYWNjb3VudCB0aGlzIG5ldyBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbi4uXHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4ID0gY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3Rpbmc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0R29vZEtub3duUmVzdWx0U2l6ZSA9IGxhc3RHb29kS25vd25SZXN1bHQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXN0ZWRUZXh0SW5kZXggPCBwYXN0ZWRUZXh0Lmxlbmd0aCAmJiBsYXN0R29vZEtub3duUmVzdWx0SW5kZXggPCBsYXN0R29vZEtub3duUmVzdWx0U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0R29vZEtub3duUmVzdWx0W2xhc3RHb29kS25vd25SZXN1bHRJbmRleF0gPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBza2lwIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAncmVwbGFjZW1lbnQnLiBUaGF0IHdheSwgd2UgZG8gbm90IGNoYW5nZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgcG9zaXRpb24gcmVnYXJkaW5nIHRoZSByZW1haW5pbmcgbnVtYmVycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZXBsYWNlIG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZUNoYXJBdChsYXN0R29vZEtub3duUmVzdWx0LCBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgsIHBhc3RlZFRleHRbcGFzdGVkVGV4dEluZGV4XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByYW5nZSBsaW1pdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSWZJblJhbmdlKHJlc3VsdCwgbWluUGFyc2UsIG1heFBhcnNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLCBzdG9wIHRoZSBsb29wIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGdvb2Qga25vd24gcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGxvb3BcclxuICAgICAgICAgICAgICAgICAgICBwYXN0ZWRUZXh0SW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxyXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBsYXN0R29vZEtub3duUmVzdWx0SW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLyogNGMuIE5vcm1hbCBwYXN0ZSBiZWhhdmlvcjpcclxuICAgICAgICAgICAgICogSW5zZXJ0IHRoZSBwYXN0ZWQgbnVtYmVyIGluc2lkZSB0aGUgY3VycmVudCB1bmZvcm1hdHRlZCB0ZXh0LCBhdCB0aGUgcmlnaHQgY2FyZXQgcG9zaXRpb24gb3Igc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2NsYW1wJzpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIDEuIEdlbmVyYXRlIHRoZSB1bmZvcm1hdHRlZCByZXN1bHRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0MiA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZSgwLCBzZWxlY3Rpb25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQyID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKHNlbGVjdGlvbkVuZCwgaW5pdGlhbEZvcm1hdHRlZFZhbHVlLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhLiBJZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBzZWxlY3RlZCBwYXJ0LCBhbmQgcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQyICsgcmlnaHRGb3JtYXR0ZWRQYXJ0MiwgaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIHRoZSBuZWdhdGl2ZSBzaWduIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRSYXdOZWdhdGl2ZVNpZ24ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcclxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBRdWlkIGlmIHRoZSBuZWdhdGl2ZSBzaWduIGlzIG5vdCBvbiB0aGUgbGVmdCAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgYW5kIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50KT9cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IHJlc3VsdC5zbGljZSgwLCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyk7XHJcbiAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIG9ubHkgcGFzdGUgYSBzaW5nbGUgZGVjaW1hbCBjaGFyYWN0ZXIsIHRoZW4gd2UgcmVtb3ZlIHRoZSBwcmV2aW91c2x5IGV4aXN0aW5nIG9uZSAoaWYgYW55KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0UGFydCwgJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBJIHJlbW92ZSBhIGRvdCBoZXJlLCB0aGVuIEkgbmVlZCB0byB1cGRhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIChkZWNyZW1lbnQgaXQgYnkgMSkgd2hlbiBwb3NpdGlvbmluZyBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBkbyBzbywgd2Uga2VlcCB0aGF0IGluZm8gaW4gb3JkZXIgdG8gbW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IGxlZnRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJpZ2h0UGFydC5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gLS0gSGVyZSwgd2UgYXJlIGdvb2QgdG8gZ28gdG8gY29udGludWUgb24gdGhlIHNhbWUgYmFzaXNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtsZWZ0UGFydH0ke3Bhc3RlZFRleHR9JHtyaWdodFBhcnR9YDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAyLiBDYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGluIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzZWxlY3Rpb24sIHRoZW4gdGhlIGNhcmV0IHBvc2l0aW9uIGlzIHNldCBhZnRlciB0aGUgcGFzdGVkIHRleHRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFdoZXJlUGFzdGVkVGV4dEhhc0JlZW5JbnNlcnRlZCA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkICsgcGFzdGVkVGV4dC5sZW5ndGg7IC8vIEkgbXVzdCBub3QgY291bnQgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXN0ZWQgdGV4dCAoaWUuICcuJylcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gYWxsIHRoZSBpbnB1dCB0ZXh0IGlzIHNlbGVjdGVkIGJlZm9yZSBwYXN0aW5nLCB3aGljaCBtZWFucyB3ZSdsbCBjb21wbGV0ZWx5IGVyYXNlIGl0cyBjb250ZW50IGFuZCBwYXN0ZSBvbmx5IHRoZSBjbGlwYm9hcmQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodFBhcnQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHNlbGVjdGVkIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IChvbiB0aGUgZmFyIHJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKSArIHBhc3RlZFRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25FbmQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIEkgbXVzdCBub3QgY291bnQgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXN0ZWQgdGV4dCAoaWUuICcuJyksIG9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3JzIGluIHRoZSBpbml0aWFsIHNlbGVjdGVkIHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gZS50YXJnZXQudmFsdWUuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlIC0gc2VsZWN0aW9uU2l6ZSArIGNvdW50Q2hhckluVGV4dChob2xkZXIuc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciwgc2VsZWN0ZWRUZXh0KSArIHBhc3RlZFRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGZvciBzcGVjaWFsIGNhc2VzLCBvbmx5IGlmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbm90IGJlZW4gc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxJbnB1dFRleHRTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXN0ZWQgdmFsdWUgaGFzIGEgJy0nIHNpZ24sIGJ1dCB0aGUgaW5pdGlhbCB2YWx1ZSBkb2VzIG5vdCwgb2Zmc2V0IHRoZSBpbmRleCBieSBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNS4gQ2hlY2sgaWYgdGhlIHJlc3VsdCBpcyBhIHZhbGlkIG51bWJlciwgaWYgbm90LCBkcm9wIHRoZSBwYXN0ZSBhbmQgZG8gbm90aGluZy5cclxuICAgICAgICBpZiAoIWlzTnVtYmVyKHJlc3VsdCkgfHwgcmVzdWx0ID09PSAnJykge1xyXG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGFzdGVkIHZhbHVlICcke3Jhd1Bhc3RlZFRleHR9JyB3b3VsZCByZXN1bHQgaW50byBhbiBpbnZhbGlkIGNvbnRlbnQgJyR7cmVzdWx0fScuYCk7IC8vVE9ETyBTaG91bGQgd2Ugc2VuZCBhIHdhcm5pbmcgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcj9cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBUaGlzIGlzIG5vdCBEUlkgOyByZWZhY3RvciB3aXRoIGFib3ZlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNi4gSWYgaXQncyBhIHZhbGlkIG51bWJlciwgY2hlY2sgaWYgaXQgZmFsbHMgaW5zaWRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlLiBJZiB0aGlzIGZhaWxzLCBtb2RpZnkgdGhlIHZhbHVlIGZvbGxvd2luZyB0aGlzIHByb2NlZHVyZSA6XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBJZiAnZXJyb3InICh0aGlzIGlzIHRoZSBkZWZhdWx0KSA6XHJcbiAgICAgICAgICogICAgICAtIE5vcm1hbCBwYXN0ZSBiZWhhdmlvci5cclxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgdGhlbiB0aHJvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZS5cclxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAgICAgICAqIElmICdpZ25vcmUnIDpcclxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxyXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCBkbyBub3RoaW5nIG1vcmUuXHJcbiAgICAgICAgICogICAgICAtIERvIG5vdCBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlLCBkbyBub3QgY2hhbmdlIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgICAgICAgKiBJZiAnY2xhbXAnIDpcclxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxyXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCBzZXQgdGhlIHZhbHVlIHRvIHRoZSBtaW5pbXVtIG9yIG1heGltdW0gbGltaXQsIHdoaWNoZXZlciBpcyBjbG9zZXN0IHRvIHRoZVxyXG4gICAgICAgICAqICAgICAgICBwYXN0ZSByZXN1bHQuXHJcbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyLlxyXG4gICAgICAgICAqIElmICd0cnVuY2F0ZScgOlxyXG4gICAgICAgICAqICAgICAgLSBUcnVuY2F0ZSBwYXN0ZSBiZWhhdmlvci5cclxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXHJcbiAgICAgICAgICogICAgICAtIERyb3AgdGhlIHJlbWFpbmluZyBub24tcGFzdGVkIG51bWJlcnMsIGFuZCBrZWVwIHRoZSBsYXN0IGtub3duIG5vbi1mYWlsaW5nIHJlc3VsdC5cclxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIGFmdGVyIHRoZSBsYXN0IHBhc3RlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICogSWYgJ3JlcGxhY2UnIDpcclxuICAgICAgICAgKiAgICAgIC0gUmVwbGFjZSBwYXN0ZSBiZWhhdmlvci5cclxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXHJcbiAgICAgICAgICogICAgIC0gVGhlbiB0cnkgdG8gcmVwbGFjZSBhcyBtYW55IG51bWJlcnMgYXMgcG9zc2libGUgd2l0aCB0aGUgcGFzdGVkIG9uZXMuIE9uY2UgaXQgZmFpbHMsIGtlZXAgdGhlIGxhc3Qga25vd24gbm9uLWZhaWxpbmcgcmVzdWx0LlxyXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGxhc3QgcGFzdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHZhbHVlSGFzQmVlbkNsYW1wZWQgPSBmYWxzZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcclxuICAgICAgICAgICAgdmFsdWVIYXNCZWVuU2V0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxldCBjbGFtcGVkVmFsdWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFtcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhbXBlZFZhbHVlID0gY2xhbXBUb1JhbmdlTGltaXRzKHJlc3VsdCwgaG9sZGVyLnNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY2xhbXBlZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEZhdGFsIGVycm9yOiBVbmFibGUgdG8gc2V0IHRoZSBjbGFtcGVkIHZhbHVlICcke2NsYW1wZWRWYWx1ZX0nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNCZWVuU2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjbGFtcGVkVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCBvbmx5IGZvciBzZXR0aW5nIHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHJlc3VsdHMgaW4gYSB2YWx1ZSAnJHtyZXN1bHR9JyB0aGF0IGlzIG91dHNpZGUgb2YgdGhlIG1pbmltdW0gWyR7aG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtIFske2hvbGRlci5zZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSB2YWx1ZSByYW5nZS5gKTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIC4uLmFuZCBub3RoaW5nIGVsc2Ugc2hvdWxkIGJlIGNoYW5nZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNy4gVGhlbiBsYXN0bHksIHNldCB0aGUgY2FyZXQgcG9zaXRpb24gYXQgdGhlIHJpZ2h0IGxvZ2ljYWwgcGxhY2VcclxuICAgICAgICBsZXQgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyO1xyXG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYW1wJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNCZWVuQ2xhbXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCAtIGhvbGRlci5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpOyAvLyBUaGlzIHB1dHMgdGhlIGNhcmV0IG9uIHRoZSByaWdodCBvZiB0aGUgbGFzdCBkZWNpbWFsIHBsYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpOyAvLyAuLmFuZCB0aGlzIG9uIHRoZSBmYXIgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIGlmIHRoZSB2YWx1ZSBoYXMgbm90IGJlZW4gY2xhbXBlZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdXNlZC4uLlxyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgb25lIG9yIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHBhc3RlZCwgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGUgcG90ZW50aWFsIHRob3VzYW5kIHNlcGFyYXRvcnMgdGhhdCBjb3VsZCBiZSBhZGRlZCBieSB0aGUgZm9ybWF0dGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlciA9IGZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIocmVzdWx0LCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgZS50YXJnZXQudmFsdWUsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA4LiBXZSBtYWtlIHN1cmUgd2Ugc2VuZCBhbiBpbnB1dCBldmVudCBvbmx5IGlmIHRoZSByZXN1bHQgaXMgZGlmZmVyZW50IHRoYW4gdGhlIGluaXRpYWwgdmFsdWUgYmVmb3JlIHRoZSBwYXN0ZVxyXG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQgJiYgaW5pdGlhbEZvcm1hdHRlZFZhbHVlICE9PSBlLnRhcmdldC52YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBPbiBhICdub3JtYWwnIG5vbi1hdXRvTnVtZXJpYyBpbnB1dCwgYW4gYGlucHV0YCBldmVudCBpcyBzZW50IHdoZW4gYSBwYXN0ZSBpcyBkb25lLiBXZSBtaW1pYyB0aGF0LlxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gZm9jdXNpbmcgb3V0IG9mIHRoZSBpbnB1dCwgd2UgY2hlY2sgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLCB0aGVuIHdlIHNlbmQgYSBgY2hhbmdlYCBldmVudCAoc2luY2UgdGhlIG5hdGl2ZSBvbmUgd291bGQgaGF2ZSBiZWVuIHByZXZlbnRlZCBieSBgZS5wcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgaW4gdGhlIG90aGVyIGV2ZW50IGxpc3RlbmVycykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uQmx1cihob2xkZXIsIGUpIHtcclxuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlLnRhcmdldCk7XHJcbiAgICAgICAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTsgLy8gLi4uYW5kIGltbWVkaWF0ZWx5IHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gc2VuZCBhIHNlY29uZCBjaGFuZ2UgZXZlbnQgKHRoYXQgc29tZWhvdyBnZXRzIHBpY2tlZCB1cCBieSBqUXVlcnksIGJ1dCBub3QgYnkgYGFkZEV2ZW50TGlzdGVuZXIoKWAgLy9GSVhNRSBLTk9XTiBCVUcgOiBUaGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIHNlY29uZCBjaGFuZ2UgZXZlbnQgdG8gYmUgcGlja2VkIHVwIGJ5IGpRdWVyeSwgd2hpY2ggYWRkcyAnLjAwJyBhdCB0aGUgZW5kIG9mIGFuIGludGVnZXJcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25TdWJtaXQoJHRoaXMsIGhvbGRlcikge1xyXG4gICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuZm9ybWF0T25TdWJtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGpRdWVyeSBzZWxlY3RlZCBpbnB1dCBpZiB0aGUgdGFnIGFuZCB0eXBlIGFyZSBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcclxuICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxyXG4gICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIGlucHV0IHR5cGVzXHJcbiAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICRpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgb25seSBpZiB0aGUgYGZvcm1hdE9uUGFnZUxvYWRgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICRpbnB1dCBqUXVlcnktc2VsZWN0ZWQgPGlucHV0PiBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQoc2V0dGluZ3MsICRpbnB1dCwgJHRoaXMpIHtcclxuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMpO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGJlZW4gc2V0IGJ5IHRoZSBkZXYsIGJ1dCBub3QgZGlyZWN0bHkgYXMgYW4gYXR0cmlidXRlIGluIHRoZSBodG1sLCB0aGVuIGl0IHRha2VzXHJcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkYCkpLlxyXG4gICAgICAgICAgICAgKiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlciBoYXMgc2V0IGZvciBgZGF0YS1hbi1kZWZhdWx0YCBpbiB0aGUgaHRtbCAoYXNwLm5ldCB1c2VycykuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cclxuICAgICAgICAgICAgICogQnV0IGlmIGBpbnB1dC52YWx1ZWAgaXMgc2V0IHRvIGEgbnVtYmVyLCBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsIHRoZW4gaXQgbWVhbnMgdGhlIGRldiBoYXNcclxuICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXHJcbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXHJcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBpZ25vcmUgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBhbHRvZ2V0aGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUgPSB0b051bWVyaWNWYWx1ZShjdXJyZW50VmFsdWUsIHNldHRpbmdzKTsgLy8gVGhpcyBhbGxvd3MgdG8gdXNlIGEgbG9jYWxpemVkIHZhbHVlIG9uIHN0YXJ0dXAgb0RlY1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHVuTG9jYWxpemVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogQ2hlY2tzIGZvciA6XHJcbiAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxyXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIFRoZSBmb2xsb3dpbmcgSFRNTCBkYXRhIGF0dHJpYnV0ZSBpcyBSRVFVSVJFRCAoZGF0YS1hbi1kZWZhdWx0PVwic2FtZSB2YWx1ZSBhcyB0aGUgdmFsdWUgYXR0cmlidXRlXCIpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUudG9TdHJpbmcoKSAhPT0gY3VycmVudFZhbHVlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICFpc051bWJlcih1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ2dldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgdmFsdWUgc2hvdWxkIE5PVCBiZSBzYXZlZCBpbiBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGN1cnJlbnRWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJyAmJiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmUoY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA9PT0gJHRoaXMuYXR0cigndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgPT09ICR0aGlzLnRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmhhbmNlIHRoZSB1c2VyIGV4cGVyaWVuY2UgYnkgbW9kaWZ5aW5nIHRoZSBkZWZhdWx0IGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGRlcGVuZGluZyBvbiBgY3VycmVuY3lTeW1ib2xgIGFuZCBgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnRgLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gKGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGApLCBidXQgaGFzIHNldCBhIGN1cnJlbmN5IHN5bWJvbCAoYGN1cnJlbmN5U3ltYm9sYCksXHJcbiAgICAgKiB0aGVuIHdlIG1vZGlmeSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGluIG9yZGVyIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvdXRwdXQgbG9naWNhbCBieSBkZWZhdWx0IDpcclxuICAgICAqIC0gXCIkLTEsMjM0LjU2XCIgaW5zdGVhZCBvZiBcIi0kMSwyMzQuNTZcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSlcclxuICAgICAqIC0gXCItMSwyMzQuNTYkXCIgaW5zdGVhZCBvZiBcIjEsMjM0LjU2LSRcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJwXCJ9KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBJZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyBhbHJlYWR5IHNldCwgd2UgZG8gbm90IG92ZXJ3cml0ZSBpdFxyXG4gICAgICAgIGlmICghaXNOdWxsKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNldHRpbmdzKSAmJlxyXG4gICAgICAgICAgICBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpICYmXHJcbiAgICAgICAgICAgICFpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gJ3AnOyAvLyBEZWZhdWx0IC0xLDIzNC41NiDigqxcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gJ2wnOyAvLyBEZWZhdWx0IC0kMSwyMzQuNTZcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNldHMgdGhlIGRlZmF1bHQgdmFsdWUgaWYgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBpcyBgbnVsbGBcclxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAnbCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5hbHl6ZSBhbmQgc2F2ZSB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgaW50ZWdlciBzaXplIGZvciBsYXRlciB1c2VzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzKHNldHRpbmdzKSB7XHJcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIGxldCBbbWluaW11bVZhbHVlSW50ZWdlclBhcnRdID0gKCFzZXR0aW5ncy5taW5pbXVtVmFsdWUgJiYgc2V0dGluZ3MubWluaW11bVZhbHVlICE9PSAwKT9bXTpzZXR0aW5ncy5taW5pbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIG1heGltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWF4aW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICBtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XHJcblxyXG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heChtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xyXG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGFzIG5lZWRlZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uKHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR0aW5ncy5vRGVjID0gU3RyaW5nKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XHJcblxyXG4gICAgICAgIC8vIE1vc3QgY2FsY3VsdXMgYXNzdW1lIGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGlzIGFuIGludGVnZXIsIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IG1ha2VzIGl0IGNsZWFyIChvdGhlcndpc2UgaGF2aW5nIGl0IGFzIGEgc3RyaW5nIGxlYWRzIHRvIHByb2JsZW1zIGluIHJvdW5kaW5nIGZvciBpbnN0YW5jZSlcclxuICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcuJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcsJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLCcgJiYgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPSAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZXMgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKSB7XHJcbiAgICAgICAgY29uc3QgYWxsTnVtYmVyc1JlZyA9ICdbMC05XSc7XHJcbiAgICAgICAgY29uc3Qgbm9BbGxOdW1iZXJzUmVnID0gJ1teMC05XSc7XHJcblxyXG4gICAgICAgIC8vIFRlc3QgaWYgdGhlcmUgaXMgYSBuZWdhdGl2ZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZ1xyXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YChbLVxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1dPylgOicoLT8pJztcclxuICAgICAgICBzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwID0gYU5lZ1JlZztcclxuXHJcbiAgICAgICAgbGV0IG5lZ2F0aXZlU2lnblJlZ1BhcnQ7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25SZWdQYXJ0ID0gYFxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7bmVnYXRpdmVTaWduUmVnUGFydH1cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dLio/KCR7YWxsTnVtYmVyc1JlZ318XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9KWApO1xyXG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKCR7YWxsTnVtYmVyc1JlZ31cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8pW15cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dJHtub0FsbE51bWJlcnNSZWd9KiRgKTtcclxuXHJcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcclxuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnJyk7XHJcbiAgICAgICAgc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfSg/OlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9Pygke2FsbE51bWJlcnNSZWd9K1xcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfSspfCgke2FsbE51bWJlcnNSZWd9Kig/OlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfSopPykpYCk7XHJcblxyXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcclxuICAgICAgICBzZXR0aW5ncy5zdHJpcFJlZyA9IG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooJHthbGxOdW1iZXJzUmVnfSlgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJyBsYXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKSB7XHJcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgJ3RydWUnIGFuZCAnZmFsc2UnIHRvIHJlYWwgQm9vbGVhblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcclxuICAgICAgICAgICAgLy9UT0RPIGlmIGEgdmFsdWUgaXMgYWxyZWFkeSBvZiB0eXBlICdOdW1iZXInLCBzaG91bGRuJ3Qgd2Uga2VlcCBpdCBhcyBhIG51bWJlciBmb3IgZnVydGhlciBtYW5pcHVsYXRpb24sIGluc3RlYWQgb2YgdXNpbmcgYSBzdHJpbmc/XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBvbGQgc2V0dGluZ3Mgb3B0aW9ucyBuYW1lIHRvIG5ldyBvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpIHtcclxuICAgICAgICAvL1RPRE8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gb25jZSB0aGUgb2xkIG9wdGlvbnMgYXJlIG5vdCB1c2VkIGFueW1vcmVcclxuICAgICAgICBjb25zdCBvbGRPcHRpb25zQ29udmVydGVyID0ge1xyXG4gICAgICAgICAgICAvLyBPbGQgb3B0aW9uIG5hbWUsIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBuZXcgb3B0aW9uXHJcbiAgICAgICAgICAgIGFTZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRHcm91cFNlcGFyYXRvcicsXHJcbiAgICAgICAgICAgIG5TZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9TZXBhcmF0b3JPbkZvY3VzJyxcclxuICAgICAgICAgICAgZEdyb3VwICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdGFsR3JvdXBTcGFjaW5nJyxcclxuICAgICAgICAgICAgYURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyJyxcclxuICAgICAgICAgICAgYWx0RGVjICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnLFxyXG4gICAgICAgICAgICBhU2lnbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sJyxcclxuICAgICAgICAgICAgcFNpZ24gICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcsXHJcbiAgICAgICAgICAgIHBOZWcgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnLFxyXG4gICAgICAgICAgICBhU3VmZml4ICAgICAgICAgICAgICAgICAgICAgIDogJ3N1ZmZpeFRleHQnLFxyXG4gICAgICAgICAgICBvTGltaXRzICAgICAgICAgICAgICAgICAgICAgIDogJ292ZXJyaWRlTWluTWF4TGltaXRzJyxcclxuICAgICAgICAgICAgdk1heCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtYXhpbXVtVmFsdWUnLFxyXG4gICAgICAgICAgICB2TWluICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pbmltdW1WYWx1ZScsXHJcbiAgICAgICAgICAgIG1EZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyxcclxuICAgICAgICAgICAgZURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyxcclxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsICAgICAgICAgICAgICAgICA6ICdzY2FsZURlY2ltYWxQbGFjZXMnLFxyXG4gICAgICAgICAgICBhU3RvciAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnLFxyXG4gICAgICAgICAgICBtUm91bmQgICAgICAgICAgICAgICAgICAgICAgIDogJ3JvdW5kaW5nTWV0aG9kJyxcclxuICAgICAgICAgICAgYVBhZCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhbGxvd0RlY2ltYWxQYWRkaW5nJyxcclxuICAgICAgICAgICAgbkJyYWNrZXQgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicsXHJcbiAgICAgICAgICAgIHdFbXB0eSAgICAgICAgICAgICAgICAgICAgICAgOiAnZW1wdHlJbnB1dEJlaGF2aW9yJyxcclxuICAgICAgICAgICAgbFplcm8gICAgICAgICAgICAgICAgICAgICAgICA6ICdsZWFkaW5nWmVybycsXHJcbiAgICAgICAgICAgIGFGb3JtICAgICAgICAgICAgICAgICAgICAgICAgOiAnZm9ybWF0T25QYWdlTG9hZCcsXHJcbiAgICAgICAgICAgIHNOdW1iZXIgICAgICAgICAgICAgICAgICAgICAgOiAnc2VsZWN0TnVtYmVyT25seScsXHJcbiAgICAgICAgICAgIGFuRGVmYXVsdCAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdFZhbHVlT3ZlcnJpZGUnLFxyXG4gICAgICAgICAgICB1blNldE9uU3VibWl0ICAgICAgICAgICAgICAgIDogJ3VuZm9ybWF0T25TdWJtaXQnLFxyXG4gICAgICAgICAgICBvdXRwdXRUeXBlICAgICAgICAgICAgICAgICAgIDogJ291dHB1dEZvcm1hdCcsXHJcbiAgICAgICAgICAgIGRlYnVnICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2hvd1dhcm5pbmdzJyxcclxuICAgICAgICAgICAgLy8gQ3VycmVudCBvcHRpb25zIDpcclxuICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG5vU2VwYXJhdG9yT25Gb2N1cyAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiB0cnVlLFxyXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93UG9zaXRpdmVTaWduICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc3VmZml4VGV4dCAgICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG92ZXJyaWRlTWluTWF4TGltaXRzICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZSAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2NhbGVEaXZpc29yICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbFBsYWNlcyAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzY2FsZVN5bWJvbCAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9uSW52YWxpZFBhc3RlICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgYWxsb3dEZWNpbWFsUGFkZGluZyAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBlbXB0eUlucHV0QmVoYXZpb3IgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGZvcm1hdE9uUGFnZUxvYWQgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGUgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvd1dhcm5pbmdzICAgICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAvL0ZJWE1FIEZpbmQgYSB3YXkgdG8gZXhjbHVkZSB0aG9zZSBpbnRlcm5hbCBkYXRhIGZyb20gdGhlIHNldHRpbmdzIG9iamVjdCAoaWRlYWxseSBieSB1c2luZyBhbm90aGVyIG9iamVjdCwgb3IgYmV0dGVyIHlldCwgY2xhc3MgYXR0cmlidXRlcykgLS0+XHJcbiAgICAgICAgICAgIGhhc0ZvY3VzICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgcnVuT25jZSAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmUgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgY2FyZXRGaXggICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIHN0cmlwICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHBvc2l0aXZlU2lnbkNoYXJhY3RlcjogdHJ1ZSxcclxuICAgICAgICAgICAgbUludFBvcyAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBtSW50TmVnICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9EZWMgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb1BhZCAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvQnJhY2tldCAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIG9TZXAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgb1NpZ24gICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBvU3VmZml4ICAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGFOZWdSZWdBdXRvU3RyaXAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgc2tpcEZpcnN0QXV0b1N0cmlwICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBza2lwTGFzdEF1dG9TdHJpcCAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGFsbG93ZWRBdXRvU3RyaXAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtUmVnQXV0b1N0cmlwICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICBzdHJpcFJlZyAgICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgIGhvbGRlciAgICAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIGlzIGEgJ25ldycgb3B0aW9uLCB3ZSBjb250aW51ZSBsb29waW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXIuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2Ugd2UgaGF2ZSBhbiAnb2xkJyBvcHRpb24gbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmcoYFlvdSBhcmUgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgb3B0aW9uIG5hbWUgJyR7b3B0aW9ufScuIFBsZWFzZSB1c2UgJyR7b2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dfScgaW5zdGVhZCBmcm9tIG5vdyBvbi4gVGhlIG9sZCBvcHRpb24gbmFtZSB3aWxsIGJlIGRyb3BwZWQgc29vbi5gLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiB3ZSBtb2RpZnkgdGhlIGluaXRpYWwgb3B0aW9uIG9iamVjdCB0byB1c2UgdGhlIG5ldyBvcHRpb25zIGluc3RlYWQgb2YgdGhlIG9sZCBvbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl1dID0gb3B0aW9uc1tvcHRpb25dO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbl07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLm9yIHRoZSBvcHRpb24gbmFtZSBpcyB1bmtub3duLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBvcHRpb25zIG9iamVjdCwgdGhlcmVmb3JlIHdlIHRocm93IGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYE9wdGlvbiBuYW1lICcke29wdGlvbn0nIGlzIHVua25vd24uIFBsZWFzZSBmaXggdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGF1dG9OdW1lcmljYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmFseXNlIHRoZSBzZXR0aW5ncy9vcHRpb25zIHBhc3NlZCBieSB0aGUgdXNlciwgdmFsaWRhdGUgYW5kIGNsZWFuIHRoZW0sIHRoZW4gcmV0dXJuIHRoZW0uXHJcbiAgICAgKiBOb3RlOiBUaGlzIHJldHVybnMgYG51bGxgIGlmIHNvbWVob3cgdGhlIHNldHRpbmdzIHJldHVybmVkIGJ5IGpRdWVyeSBpcyBub3QgYW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZSAtIElmIFRSVUUsIHRoZW4gdGhlIHNldHRpbmdzIGFscmVhZHkgZXhpc3RzIGFuZCB0aGlzIGZ1bmN0aW9uIG9ubHkgdXBkYXRlcyB0aGVtIGluc3RlYWQgb2YgcmVjcmVhdGluZyB0aGVtIGZyb20gc2NyYXRjaFxyXG4gICAgICogQHJldHVybnMge29iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHVwZGF0ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIFwiYXV0b051bWVyaWNcIiBzZXR0aW5ncy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIGl0IHJldHVybnMgXCJ1bmRlZmluZWRcIi5cclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgdXNlciB1c2VkIG9sZCBvcHRpb25zLCB3ZSBjb252ZXJ0IHRoZW0gdG8gbmV3IG9uZXNcclxuICAgICAgICBpZiAodXBkYXRlIHx8ICFpc051bGwob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXBkYXRlIHx8IGlzVW5kZWZpbmVkKHNldHRpbmdzKSkge1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIHVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgZ3JhYiBhbnkgc2V0dGluZ3MsIGNyZWF0ZSB0aGVtIGZyb20gdGhlIGRlZmF1bHQgb25lcyBhbmQgY29tYmluZSB0aGVtIHdpdGggdGhlIG9wdGlvbnMgcGFzc2VkXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIGdlbmVyYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBhdHRlbXB0IHRvIGdyYWIgdGhlIEhUTUw1IGRhdGEuIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHdlJ2xsIGdldCBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdEYXRhID0gJHRoaXMuZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB0YWdEYXRhLCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9jdXMgICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBydW5PbmNlICAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICAgICAgIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZSAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBjYXJldEZpeCAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFuZHJvaWRTZWxlY3Rpb25TdGFydDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgICAgICA6IHRydWUsIC8vIFRocm93IGlucHV0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaXAgICAgICAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICAgICAgIDogYWxsb3dlZFRhZ0xpc3QsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyhzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbXByb3ZlIHRoZSBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIG9wdGlvbiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgY29ycmVjdE5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50T3B0aW9uKHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVnYXRpdmUgYW5kIHBvc2l0aXZlIHNpZ25zLCBhcyBuZWVkZWRcclxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gc2V0dGluZ3MubWluaW11bVZhbHVlIDwgMCA/ICctJyA6ICcnO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIgPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUgPj0gMCA/ICcrJyA6ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBjaGFuZ2VzIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgKGZyb20gdGhlIG9yaWdpbmFsIGF1dG9Db2RlKCkgZnVuY3Rpb24pXHJcbiAgICAgICAgICAgIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGNvcnJlY3REZWNpbWFsUGxhY2VzT3ZlcnJpZGVPcHRpb24oc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBzZXRzQWx0ZXJuYXRpdmVEZWNpbWFsU2VwYXJhdG9yQ2hhcmFjdGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzXHJcbiAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcclxuXHJcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzLCBzY2FsZURpdmlzb3IgJiBub1NlcGFyYXRvck9uRm9jdXMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxyXG4gICAgICAgICAgICBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcclxuICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgYHZhbHVlYCBwYXJhbWV0ZXIgdGhhdCBjYW4gZWl0aGVyIGJlIDpcclxuICAgICAqIC0gYSByZWFsIG51bWJlcixcclxuICAgICAqIC0gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgcmVhbCBudW1iZXIsIG9yXHJcbiAgICAgKiAtIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGxvY2FsaXplZCBudW1iZXIgKHdpdGggc3BlY2lmaWMgZ3JvdXAgc2VwYXJhdG9ycyBhbmQgZGVjaW1hbCBjaGFyYWN0ZXIpLFxyXG4gICAgICogLi4udG8gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgcmVhbCAnamF2YXNjcmlwdCcgbnVtYmVyIChpZS4gJzEyMzQnIG9yICcxMjM0LjU2NycpLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgTmFOYCBpZiBzdWNoIGNvbnZlcnNpb24gZmFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbnR8ZmxvYXR8c3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE5hTn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9OdW1lcmljVmFsdWUodmFsdWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAoaXNOdW1iZXIoTnVtYmVyKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGhhcyBlaXRoZXIgYWxyZWFkeSBiZWVuIHN0cmlwcGVkLCBvciBhICdyZWFsJyBqYXZhc2NyaXB0IG51bWJlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRWxzZSBpZiBpdCdzIGEgc3RyaW5nIHRoYXQgYE51bWJlcigpYCBjYW5ub3QgdHlwZWNhc3QsIHRoZW4gd2UgdHJ5IHRvIGNvbnZlcnQgdGhlIGxvY2FsaXplZCBudW1lcmljIHN0cmluZyB0byBhIG51bWVyaWMgb25lXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgbnVtZXJpYyBzdHJpbmcsIHN0cmlwcGluZyB1bm5lY2Vzc2FyeSBjaGFyYWN0ZXJzIGluIHRoZSBwcm9jZXNzXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnRUb051bWVyaWNTdHJpbmcodmFsdWUudG9TdHJpbmcoKSwgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyBzdGlsbCBub3QgYSBudW1lcmljIHN0cmluZywgdGhlbiB3ZSB0aHJvdyBhIHdhcm5pbmdcclxuICAgICAgICAgICAgaWYgKCFpc051bWJlcihOdW1iZXIocmVzdWx0KSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCwgc2V0dGluZ3Muc2hvd1dhcm5pbmdzKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE5hTjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ldGhvZHMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IG1ldGhvZHMgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIGluaXRpYWxpemUgYXV0b051bWVyaWMgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgKG9wdGlvbnMgY2FuIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlcilcclxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcpOyAgICAgICAgICAgIC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoKTsgICAgICAgICAgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jywge29wdGlvbnN9KTsgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKHtvcHRpb25zfSk7ICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfHtzdGF0ZW1lbnRzLCBicmFuY2hlcywgbGluZXMsIGZ1bmN0aW9ucywgZXhjbHVkZXMsIG92ZXJyaWRlc318e3N0YXRlbWVudHMsIGJyYW5jaGVzLCBsaW5lcywgZnVuY3Rpb25zLCBleGNsdWRlc318e3N0YXRlbWVudHMsIGxpbmVzLCBicmFuY2hlcywgZnVuY3Rpb25zLCBleGNsdWRlc319XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9ICQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkaW5wdXQgPSBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgkdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaG9sZGVyID0gZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5ydW5PbmNlICYmIHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGV2ZW50cyBsaXN0ZW5lcnMgdG8gc3VwcG9ydGVkIGlucHV0IHR5cGVzIChcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZSlcclxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBlID0+IHsgb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGUgPT4geyBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZSA9PiB7IG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZSA9PiB7IG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7IG9uS2V5ZG93bihob2xkZXIsIGUpOyB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGUgPT4geyBvbktleXByZXNzKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZSA9PiB7IG9uSW5wdXQoaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHsgb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGUgPT4geyBvbkJsdXIoaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBlID0+IHsgb25QYXN0ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpOyAvL1RPRE8gU3dpdGNoIHRvIGBhZGRFdmVudExpc3RlbmVyJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gc3RvcCBhbmQgcmVtb3ZlIGF1dG9OdW1lcmljIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gICAgICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gRGVzdHJveXMgYXV0b051bWVyaWMgb24gdGhpcyBzZWxlY3RlZCBlbGVtZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9mZignLmF1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0byBjbGVhciB0aGUgdmFsdWUgZnJvbSBzZXNzaW9uU3RvcmFnZSAob3IgY29va2llLCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0cykuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyBSZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpcGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgYXV0b051bWVyaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogSXQgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpZiBuZWVkZWQuXHJcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHtkaWdpdEdyb3VwU2VwYXJhdG9yOiBcIi5cIiwgZGVjaW1hbENoYXJhY3RlcjogXCIsXCIsIGN1cnJlbmN5U3ltYm9sOiAn4oKsICd9KS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcInVwZGF0ZVwiLCB7b3B0aW9uc30pOyAvLyBVcGRhdGVzIHRoZSBzZXR0aW5nc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBjdXJyZW50IHVuZm9ybWF0dGVkIGlucHV0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0IHRoYXQgc3RvcmUgdGhlIGZpZWxkIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlIHdpdGggdGhlIG5ldyBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMpICE9PSAnJyB8fCAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzdHJpcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0byBmb3JtYXQgdGhlIHZhbHVlIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cclxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBpdCBjYW4gYmUgYW4gaW50ZWdlciAnMTIzNCcgb3IgYSBkb3VibGUgJzEyMzQuNTY3ODknXHJcbiAgICAgICAgICogYW5kIG11c3QgY29udGFpbiBvbmx5IG51bWJlcnMgYW5kIG9uZSBkZWNpbWFsIChwZXJpb2QpIGNoYXJhY3RlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAnMTIzNDUuNjcnKTsgLy8gRm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRyYWlsaW5nIG5lZ2F0aXZlIHNldHRpbmdzLCBzaW5jZSBpdCdzIHBvc3NpYmxlIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgbmVnYXRpdmUsIGJ1dCBub3QgdGhlIG5ld2x5IHNldCBvbmVcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdG9OdW1lcmljVmFsdWUobmV3VmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdGVzdCBpcyBuZWVkZWQgYnkgdGhlIHNob3dQb3NpdGl2ZVNpZ24gb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNaZXJvID0gaXNaZXJvT3JIYXNOb1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGVuc3VyZSByb3VuZGluZyBkb2VzIG5vdCBoYXBwZW4gdHdpY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNCZWVuUm91bmRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kcyB0aGUgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcERlY2ltYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBEZWNpbWFsID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCZWVuUm91bmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGVtcERlY2ltYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiAhc2V0dGluZ3Mub25PZmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b051bWVyaWNWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcERlY2ltYWwgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcihzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJvdW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZHMgaWYgdGhpcyBoYXMgbm90IGJlZW4gZG9uZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0JlZW5Sb3VuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmVzIHJhd1ZhbHVlIGluY2x1ZGluZyB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMgJiYgIXNldHRpbmdzLm9uT2ZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGVtcERlY2ltYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICYmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnc2V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIG9mIHRoZSBtaW5pbXVtVmFsdWUgWyR7c2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHtzZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNGb2N1cyAmJiBzZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyBzZXR0aW5ncy5zY2FsZVN5bWJvbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeU9yaWdpbmFsVmFsLmNhbGwoJHRoaXMsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0byB1bi1mb3JtYXQgaW5wdXRzLlxyXG4gICAgICAgICAqIFRoaXMgaXMgaGFuZHkgdG8gdXNlIHJpZ2h0IGJlZm9yZSBmb3JtIHN1Ym1pc3Npb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZ3MgKGllLiBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIpLCB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXHJcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycy5cclxuICAgICAgICAgKiBQbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBtb3JlIGRldGFpbHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygndW5TZXQnKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB1blNldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLCAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gcmUtZm9ybWF0IGlucHV0cy5cclxuICAgICAgICAgKiBUaGlzIGlzIGhhbmR5IHRvIHVzZSByaWdodCBhZnRlciBmb3JtIHN1Ym1pc3Npb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3JlU2V0Jyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVTZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgalF1ZXJ5T3JpZ2luYWxWYWwuY2FsbCgkdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgLy9UT0RPIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGdldCBhIG5ldyByZWZlcmVuY2UgdG8gJHRoaXMgc2luY2UgaXQgaGFzIGJlZW4gZG9uZSBpbiBgaW5pdCgpYD9cclxuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgLy9UT0RPIFRoaXMgbG9va3MgYSBsb3QgbGlrZSBgZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoKWAuIElzIHRoYXQgbmVjZXNzYXJ5PyBDYW4gdGhlIGlucHV0IGVsZW1lbnQgYmUgY2hhbmdlZCBzaW5jZSBhdXRvTnVtZXJpYyBoYXMgYmVlbiBpbml0aWFsaXplZD9cclxuICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJnZXRcIiBtZXRob2QuYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnlPcmlnaW5hbFZhbC5jYWxsKCR0aGlzLmVxKDApKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBcIjwkeyR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpfT5cIiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MucmF3VmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWYWx1ZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZSh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEoL1xcZC8pLnRlc3QodmFsdWUpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnICYmIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgfHwgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcHMgdHJhaWxpbmcgbmVnYXRpdmUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmltcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB6ZXJvcyB3aGVuIGxlYWRpbmdaZXJvIGRvZXMgTk9UIGVxdWFsIFwia2VlcFwiLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyksIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2VzIHRoZSBuZWdhdGl2ZSBzeW1ib2wgaW4gZnJvbnQgb2YgdGhlIHRyYWlsaW5nIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgaXNWYWx1ZU5lZ2F0aXZlICYmICFpc05lZ2F0aXZlKHZhbHVlKSAmJiBOdW1iZXIodmFsdWUpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgfHwgdmFsdWUgPT09ICcnICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhIG51bWVyaWMgc3RyaW5nXHJcbiAgICAgICAgICAgIC8vIFRoaXMgZ2V0cyByaWQgb2YgdGhlIHRyYWlsaW5nIHplcm9zIGluIHRoZSBkZWNpbWFsIHBsYWNlcyBzaW5jZSBgZ2V0YCBkb2VzIG5vdCBwYWQgZGVjaW1hbHNcclxuICAgICAgICAgICAgcmV0dXJuIHRyaW1QYWRkZWRaZXJvc0Zyb21EZWNpbWFsUGxhY2VzKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgYnV0IGZvbGxvd2luZyB0aGUgYG91dHB1dEZvcm1hdGAgc2V0dGluZywgd2hpY2ggbWVhbnMgdGhlIG91dHB1dCBjYW4gZWl0aGVyIGJlIDpcclxuICAgICAgICAgKiAtIGEgc3RyaW5nICh0aGF0IGNvdWxkIG9yIGNvdWxkIG5vdCByZXByZXNlbnQgYSBudW1iZXIgKGllLiBcIjEyMzQ1LDY3LVwiKSksIG9yXHJcbiAgICAgICAgICogLSBhIHBsYWluIG51bWJlciAoaWYgdGhlIHNldHRpbmcgJ251bWJlcicgaXMgdXNlZCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXR1cm5lZCB2YWx1ZXMgYXJlIGFuIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kLlxyXG4gICAgICAgICAqIENoZWNrIHRoZSBcIm91dHB1dEZvcm1hdFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldExvY2FsaXplZCgpIHtcclxuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgaW5wdXQgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSByZWFsIEphdmFzY3JpcHQgbnVtYmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0TnVtYmVyJyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE51bWJlcigpIHtcclxuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsICdudW1iZXInKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxyXG4gICAgICAgICAqIEB1c2FnZSBhTklucHV0LmF1dG9OdW1lcmljKCdnZXRGb3JtYXR0ZWQnKSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Rm9ybWF0dGVkKCkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCcwJykgfHwgISgndmFsdWUnIGluIHRoaXNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZ2V0IHRoZSBmb3JtYXR0ZWQgc3RyaW5nIGZyb20gdGhlIGVsZW1lbnQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXHJcbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXHJcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBkZXRhaWxzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFN0cmluZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KGZhbHNlLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXHJcbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXHJcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBkZXRhaWxzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7e318W119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0QXJyYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheSh0cnVlLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgY3VycmVudCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpO1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKS5kZWNpbWFsQ2hhcmFjdGVyOyAvLyBSZXR1cm4gdGhlIGRlY2ltYWxDaGFyYWN0ZXIgc2V0dGluZyBhcyBhIHN0cmluZyAtIGFueSB2YWxpZCBvcHRpb24gbmFtZSBjYW4gYmUgdXNlZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRTZXR0aW5ncygpIHtcclxuICAgICAgICAgICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gYXJndW1lbnQgYG9wdGlvbk5hbWVgIHRvIHRoaXMgZnVuY3Rpb24gc28gdGhhdCBpdCByZXR1cm4gb25seSB0aGUgdmFsdWUgb2YgdGhhdCBvcHRpb24sIG5vdCB0aGUgZW50aXJlIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF1dG9OdW1lcmljIGZ1bmN0aW9uIGFjY2VwdHMgbWV0aG9kcyBuYW1lcyAoaW4gc3RyaW5nIGZvcm1hdCkgYW5kIHRob3NlIG1ldGhvZCBwYXJhbWV0ZXJzIGlmIG5lZWRlZC5cclxuICAgICAqIEl0IGluaXRpYWxpemUgYXV0b051bWVyaWMgb24gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgbWV0aG9kIG5hbWUgKGllLiAnc2V0JywgJ2dldCcsIGV0Yy4pXHJcbiAgICAgKiBAcGFyYW0geyp9IGFyZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkLmZuLmF1dG9OdW1lcmljID0gZnVuY3Rpb24obWV0aG9kLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICFtZXRob2QpIHtcclxuICAgICAgICAgICAgLy8gVGhlIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZCBkaXJlY3RseSwgd2l0aG91dCB1c2luZyBhIG5hbWVkIG1ldGhvZFxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgYXV0b051bWVyaWMgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge29iamVjdH1cclxuICAgICAqL1xyXG4gICAgZ2V0RGVmYXVsdENvbmZpZyA9ICgpID0+IGRlZmF1bHRTZXR0aW5ncztcclxuXHJcbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0gZGVmYXVsdFNldHRpbmdzOyAvLyBNYWtlIHRob3NlIHNldHRpbmdzIHB1YmxpYyB2aWEgalF1ZXJ5IHRvby5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbGwgdGhlIHByZWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucyBpbiBvbmUgb2JqZWN0LlxyXG4gICAgICogWW91IGNhbiBhbHNvIGFjY2VzcyBhIHNwZWNpZmljIGxhbmd1YWdlIG9iamVjdCBkaXJlY3RseSBieSB1c2luZyBgYW4uZ2V0TGFuZ3VhZ2VzKCkuRnJlbmNoYCBmb3IgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge29iamVjdH1cclxuICAgICAqL1xyXG4gICAgZ2V0TGFuZ3VhZ2VzID0gKCkgPT4gbGFuZ3VhZ2VPcHRpb247XHJcblxyXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5sYW5nID0gbGFuZ3VhZ2VPcHRpb247IC8vIE1ha2UgdGhvc2UgcHJlZGVmaW5lZCBsYW5ndWFnZSBvcHRpb25zIHB1YmxpYyB2aWEgalF1ZXJ5IHRvby5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgQSBudW1iZXIsIG9yIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50IGEgamF2YXNjcmlwdCBudW1iZXJcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBhdXRvRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zID0gbnVsbCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzU3RyaW5nKHZhbHVlKSAmJiAhaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWF0ZSBhIHZlcnkgYmFzaWMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWVyaWMgc3RyaW5nLCBzdHJpcHBpbmcgdW5uZWNlc3NhcnkgY2hhcmFjdGVycyBpbiB0aGUgcHJvY2Vzc1xyXG4gICAgICAgIGxldCB2YWx1ZVN0cmluZyA9IHRvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlU3RyaW5nKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWVTdHJpbmd9XSB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGZvcm1hdCBpcyBub3QgYSByZWNvZ25pemVkIG51bWJlci5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJhc2ljIHRlc3RzIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZVN0cmluZyBpcyB2YWxpZFxyXG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnYXV0b0Zvcm1hdC5hdXRvTnVtZXJpYycsIGRvY3VtZW50LCBgUmFuZ2UgdGVzdCBmYWlsZWRgKTtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlU3RyaW5nfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIG9rLCBwcm9jZWVkIHRvIHJvdW5kaW5nLCBmb3JtYXR0aW5nIGFuZCBncm91cGluZ1xyXG4gICAgICAgIHZhbHVlU3RyaW5nID0gcm91bmRWYWx1ZSh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xyXG4gICAgICAgIHZhbHVlU3RyaW5nID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgdmFsdWVTdHJpbmcgPSBhZGRHcm91cFNlcGFyYXRvcnModmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nO1xyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0OyAvLyBUaGUgalF1ZXJ5IGV4cG9ydFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBhdXRvVW5Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2l2aW5nIGFuIHVuZm9ybWF0dGVkIHZhbHVlIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgdW5mb3JtYXR0ZWQgdmFsdWUsIHdoYXRldmVyIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxyXG4gICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7IC8vVE9ETyBDb21wbGV0ZSB0aGUgdGVzdCB0byB0aHJvdyB3aGVuIGdpdmVuIGEgd3JvbmdseSBmb3JtYXR0ZWQgbnVtYmVyIChpZS4gJ2Zvb2JhcicpXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgQSBudW1iZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbnVtYmVyIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIHVuZm9ybWF0IGl0LCBbJHt2YWx1ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xyXG4gICAgICAgIGNvbnN0IGF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgY2hlY2tzIGlzIGEgbmVnYXRpdmUgc2lnbiBpcyBhbnl3aGVyZSBpbiB0aGUgYHZhbHVlYCwgbm90IGp1c3Qgb24gdGhlIHZlcnkgZmlyc3QgY2hhcmFjdGVyIChpZS4gJzEyMzQ1LjY3LScpXHJcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcclxuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICYmIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcclxuICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0OyAvLyBUaGUgalF1ZXJ5IGV4cG9ydFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXHJcbiAgICAgKiBJZiB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nLCBvdGhlcndpc2UgaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsZW5pZW50IHNpbmNlIGl0IG9ubHkgdGVzdHMgdGhlIHNldHRpbmdzIHByb3BlcnRpZXMgOyBpdCBpZ25vcmVzIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBvcHRpb25zIG9iamVjdCBjb3VsZCBoYXZlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cclxuICAgICAqIEB0aHJvd3MgRXJyb3JcclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGUgPSAodXNlck9wdGlvbnMsIHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXHJcbiAgICAgICAgaWYgKCFpc051bGwodXNlck9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKHVzZXJPcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSB1c2VyIGNhbiBjaG9vc2UgaWYgdGhlIGB1c2VyT3B0aW9uc2AgaGFzIGFscmVhZHkgYmVlbiBleHRlbmRlZCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIG9yIG5vdFxyXG4gICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdXNlck9wdGlvbnMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1c2VyT3B0aW9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpcnN0IHRoaW5ncyBmaXJzdCwgd2UgdGVzdCB0aGF0IHRoZSBgc2hvd1dhcm5pbmdzYCBvcHRpb24gaXMgdmFsaWRcclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93V2FybmluZ3MpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zaG93V2FybmluZ3MpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ3Nob3dXYXJuaW5ncycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2hvd1dhcm5pbmdzfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWZpbmUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgbmVlZGVkIGZvciB0aGUgZm9sbG93aW5nIHRlc3RzXHJcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlSW50ZWdlciA9IC9eWzAtOV0rJC87XHJcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcclxuICAgICAgICAvLyBjb25zdCB0ZXN0RmxvYXRBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKykkLztcclxuICAgICAgICBjb25zdCB0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKyk/JC87XHJcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcclxuXHJcbiAgICAgICAgLy8gVGhlbiB0ZXN0cyB0aGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIFtcclxuICAgICAgICAgICAgJywnLCAgICAgIC8vIENvbW1hXHJcbiAgICAgICAgICAgICcuJywgICAgICAvLyBEb3RcclxuICAgICAgICAgICAgJyAnLCAgICAgIC8vIE5vcm1hbCBzcGFjZVxyXG4gICAgICAgICAgICAnXFx1MjAwOScsIC8vIFRoaW4tc3BhY2VcclxuICAgICAgICAgICAgJ1xcdTIwMmYnLCAvLyBOYXJyb3cgbm8tYnJlYWsgc3BhY2VcclxuICAgICAgICAgICAgJ1xcdTAwYTAnLCAvLyBOby1icmVhayBzcGFjZVxyXG4gICAgICAgICAgICAnJywgICAgICAgLy8gTm8gc2VwYXJhdG9yXHJcbiAgICAgICAgICAgIFwiJ1wiLCAgICAgIC8vIEFwb3N0cm9waGVcclxuICAgICAgICAgICAgJ9msJywgICAgICAvLyBBcmFiaWMgdGhvdXNhbmRzIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAny5knLCAgICAgIC8vIERvdCBhYm92ZVxyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGlnaXRHcm91cFNlcGFyYXRvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJ9msJywgJ8uZJywgXCInXCIsICcgJywgJ1xcdTIwMDknLCAnXFx1MjAyZicsICdcXHUwMGEwJyBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cykgJiYgIWlzQm9vbGVhbihvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlICdub1NlcGFyYXRvck9uRm9jdXMnIG9wdGlvbiBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRob3VzYW5kIHNlcGFyYXRvciBvcHRpb24gJ2RpZ2l0YWxHcm91cFNwYWNpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmd9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciwgW1xyXG4gICAgICAgICAgICAnLCcsIC8vIENvbW1hXHJcbiAgICAgICAgICAgICcuJywgLy8gRG90XHJcbiAgICAgICAgICAgICfCtycsIC8vIE1pZGRsZS1kb3RcclxuICAgICAgICAgICAgJ9mrJywgLy8gQXJhYmljIGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgICfijpYnLCAvLyBEZWNpbWFsIHNlcGFyYXRvciBrZXkgc3ltYm9sXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJy4nLCAnLCcsICfCtycsICfijpYnIG9yICfZqycsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgIGlmIChvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcikge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnZGVjaW1hbENoYXJhY3RlcicgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2RpZ2l0R3JvdXBTZXBhcmF0b3InIFske29wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcn1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiYgIWlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGN1cnJlbmN5IHN5bWJvbCBvcHRpb24gJ2N1cnJlbmN5U3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmN1cnJlbmN5U3ltYm9sfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LCBbJ3AnLCAncyddKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAnY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQsIFsncCcsICdzJywgJ2wnLCAncicsIG51bGxdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIG9wdGlvbiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSwgJ3MnIChzdWZmaXgpLCAnbCcgKGxlZnQpLCAncicgKHJpZ2h0KSBvciAnbnVsbCcsIFske29wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNob3dQb3NpdGl2ZVNpZ24pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zaG93UG9zaXRpdmVTaWduKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2hvdyBwb3NpdGl2ZSBzaWduIG9wdGlvbiAnc2hvd1Bvc2l0aXZlU2lnbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnN1ZmZpeFRleHQpIHx8IChvcHRpb25zLnN1ZmZpeFRleHQgIT09ICcnICYmIChpc05lZ2F0aXZlKG9wdGlvbnMuc3VmZml4VGV4dCkgfHwgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMudGVzdChvcHRpb25zLnN1ZmZpeFRleHQpKSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnc3VmZml4VGV4dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuc3VmZml4VGV4dH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cykgJiYgIWlzSW5BcnJheShvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLCBbJ2NlaWxpbmcnLCAnZmxvb3InLCAnaWdub3JlJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb3ZlcnJpZGVNaW5NYXhMaW1pdHMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdjZWlsaW5nJywgJ2Zsb29yJyBvciAnaWdub3JlJywgWyR7b3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0c31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLm1heGltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAnbWF4aW11bVZhbHVlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5taW5pbXVtVmFsdWUpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMubWluaW11bVZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21pbmltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLm1pbmltdW1WYWx1ZSkgPiBwYXJzZUZsb2F0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiA7ICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiAnbWF4aW11bVZhbHVlJyBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEoaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB8fFxyXG4gICAgICAgICAgICAoaXNJbnQob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlID49IDApIHx8IC8vIElmIGludGVnZXIgb3B0aW9uXHJcbiAgICAgICAgICAgIChpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkpICAvLyBJZiBzdHJpbmcgb3B0aW9uXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXcml0ZSBhIHdhcm5pbmcgbWVzc2FnZSBpbiB0aGUgY29uc29sZSBpZiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgaW4gbWluaW11bVZhbHVlL21heGltdW1WYWx1ZSBpcyBvdmVycmlkZGVuIGJ5IGRlY2ltYWxQbGFjZXNPdmVycmlkZSAoYW5kIG5vdCBpZiBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBkZWNpbWFsIHVzZWQgaW4gbWluaW11bVZhbHVlL21heGltdW1WYWx1ZSlcclxuICAgICAgICBjb25zdCB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChvcHRpb25zLm1pbmltdW1WYWx1ZSwgb3B0aW9ucy5tYXhpbXVtVmFsdWUpO1xyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzICE9PSBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgdG8gWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSB3aWxsIG92ZXJyaWRlIHRoZSBkZWNpbWFscyBkZWNsYXJlZCBpbiAnbWluaW11bVZhbHVlJyBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIGFuZCAnbWF4aW11bVZhbHVlJyBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmAsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nICYmICFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FsbG93RGVjaW1hbFBhZGRpbmcnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBzZXR0aW5nIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAoIWlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgfHwgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG5vcm1hbCBkZWNpbWFsIHBsYWNlcyBcImRlY2ltYWxQbGFjZXNPdmVycmlkZVwiXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAhaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpID4gTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykpIHtcclxuICAgICAgICAgICAgd2FybmluZyhgVGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHZhbHVlLiBDdXJyZW50bHksIHRoaXMgd2lsbCBsaW1pdCB0aGUgYWJpbGl0eSBvZiB5b3VyIGNsaWVudCB0byBtYW51YWxseSBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVjaW1hbCBwbGFjZXMuIERvIHlvdSByZWFsbHkgd2FudCB0byBkbyB0aGF0P2AsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIGRpdmlzb3Igb3B0aW9uICdzY2FsZURpdmlzb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIHByZWZlcmFibHkgYW4gaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURpdmlzb3J9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEZWNpbWFsUGxhY2VzKSAmJiAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuc2NhbGVEZWNpbWFsUGxhY2VzKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsUGxhY2VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgc3ltYm9sIG9wdGlvbiAnc2NhbGVTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuc2NhbGVTeW1ib2x9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2F2ZSB0byBzZXNzaW9uIHN0b3JhZ2Ugb3B0aW9uICdzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm9uSW52YWxpZFBhc3RlLCBbXHJcbiAgICAgICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgICAgICdpZ25vcmUnLFxyXG4gICAgICAgICAgICAnY2xhbXAnLFxyXG4gICAgICAgICAgICAndHJ1bmNhdGUnLFxyXG4gICAgICAgICAgICAncmVwbGFjZScsXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlIGJlaGF2aW9yIG9wdGlvbiAnb25JbnZhbGlkUGFzdGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdlcnJvcicsICdpZ25vcmUnLCAnY2xhbXAnLCAndHJ1bmNhdGUnIG9yICdyZXBsYWNlJyAoY2YuIGRvY3VtZW50YXRpb24pLCBbJHtvcHRpb25zLm9uSW52YWxpZFBhc3RlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnJvdW5kaW5nTWV0aG9kLCBbXHJcbiAgICAgICAgICAgICdTJyxcclxuICAgICAgICAgICAgJ0EnLFxyXG4gICAgICAgICAgICAncycsXHJcbiAgICAgICAgICAgICdhJyxcclxuICAgICAgICAgICAgJ0InLFxyXG4gICAgICAgICAgICAnVScsXHJcbiAgICAgICAgICAgICdEJyxcclxuICAgICAgICAgICAgJ0MnLFxyXG4gICAgICAgICAgICAnRicsXHJcbiAgICAgICAgICAgICdOMDUnLFxyXG4gICAgICAgICAgICAnQ0hGJyxcclxuICAgICAgICAgICAgJ1UwNScsXHJcbiAgICAgICAgICAgICdEMDUnLFxyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByb3VuZGluZyBtZXRob2Qgb3B0aW9uICdyb3VuZGluZ01ldGhvZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ1MnLCAnQScsICdzJywgJ2EnLCAnQicsICdVJywgJ0QnLCAnQycsICdGJywgJ04wNScsICdDSEYnLCAnVTA1JyBvciAnRDA1JyAoY2YuIGRvY3VtZW50YXRpb24pLCBbJHtvcHRpb25zLnJvdW5kaW5nTWV0aG9kfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGNvbnRyb2wgZGVjaW1hbCBwYWRkaW5nIG9wdGlvbiAnYWxsb3dEZWNpbWFsUGFkZGluZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZ31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikgJiYgIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYnJhY2tldHMgZm9yIG5lZ2F0aXZlIHZhbHVlcyBvcHRpb24gJ25lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnKCwpJywgJ1ssXScsICc8LD4nIG9yICd7LH0nLCBbJHtvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvciwgWydmb2N1cycsICdwcmVzcycsICdhbHdheXMnLCAnemVybyddKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICdlbXB0eUlucHV0QmVoYXZpb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3J9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubGVhZGluZ1plcm8sIFsnYWxsb3cnLCAnZGVueScsICdrZWVwJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3Igb3B0aW9uICdsZWFkaW5nWmVybycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2FsbG93JywgJ2RlbnknIG9yICdrZWVwJywgWyR7b3B0aW9ucy5sZWFkaW5nWmVyb31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdmb3JtYXRPblBhZ2VMb2FkJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5KSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNlbGVjdCBudW1iZXIgb25seSBvcHRpb24gJ3NlbGVjdE51bWJlck9ubHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNlbGVjdE51bWJlck9ubHl9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpICYmIChvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSAnJyAmJiAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlKSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdkZWZhdWx0VmFsdWVPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGV9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51bmZvcm1hdE9uU3VibWl0KSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcmVtb3ZlIGZvcm1hdHRpbmcgb24gc3VibWl0IG9wdGlvbiAndW5mb3JtYXRPblN1Ym1pdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMudW5mb3JtYXRPblN1Ym1pdH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5vdXRwdXRGb3JtYXQpICYmICFpc0luQXJyYXkob3B0aW9ucy5vdXRwdXRGb3JtYXQsIFtcclxuICAgICAgICAgICAgJ3N0cmluZycsXHJcbiAgICAgICAgICAgICdudW1iZXInLFxyXG4gICAgICAgICAgICAnLicsXHJcbiAgICAgICAgICAgICctLicsXHJcbiAgICAgICAgICAgICcsJyxcclxuICAgICAgICAgICAgJy0sJyxcclxuICAgICAgICAgICAgJy4tJyxcclxuICAgICAgICAgICAgJywtJyxcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VzdG9tIGxvY2FsZSBmb3JtYXQgb3B0aW9uICdvdXRwdXRGb3JtYXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIG51bGwsICdzdHJpbmcnLCAnbnVtYmVyJywgJy4nLCAnLS4nLCAnLCcsICctLCcsICcuLScgb3IgJywtJywgWyR7b3B0aW9ucy5vdXRwdXRGb3JtYXR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdmYWlsT25Vbmtub3duT3B0aW9uJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9ufV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmF1dG9WYWxpZGF0ZSA9IHZhbGlkYXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHNldHRpbmdzL29wdGlvbnMgYXJlIHZhbGlkLCBGQUxTRSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBhcmVTZXR0aW5nc1ZhbGlkID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZShvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2UgYW4gYXJhYmljIG51bWJlciBhcyBhIHN0cmluZyBhbmQgcmV0dXJuIGEgamF2YXNjcmlwdCBudW1iZXIuXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyeSB0byBjb252ZXJ0IHRoZSBhcmFiaWMgZGVjaW1hbCBhbmQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBUaGlzIHJldHVybnMgYE5hTmAgaXMgdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxyXG4gICAgICogQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTcwMjUzOTIvMjgzNDg5OFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmFiaWNOdW1iZXJzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybkFOdW1iZXIgSWYgYHRydWVgLCByZXR1cm4gYSBOdW1iZXIsIG90aGVyd2lzZSByZXR1cm4gYSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2VEZWNpbWFsQ2hhcmFjdGVyXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnNlVGhvdXNhbmRTZXBhcmF0b3JcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfE5hTn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXJhYmljVG9MYXRpbk51bWJlcnMoYXJhYmljTnVtYmVycywgcmV0dXJuQU51bWJlciA9IHRydWUsIHBhcnNlRGVjaW1hbENoYXJhY3RlciA9IGZhbHNlLCBwYXJzZVRob3VzYW5kU2VwYXJhdG9yID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXJhYmljTnVtYmVycy50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT09ICcnIHx8IHJlc3VsdC5tYXRjaCgvW9mg2aHZotmj2aTZpdmm2afZqNmp27Tbtdu2XS9nKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBBcmFiaWMvUGVyc2lhbiBudW1iZXJzIGFyZSBmb3VuZCwgcmV0dXJuIHRoZSBudW1lcmljIHN0cmluZyBkaXJlY3RseVxyXG4gICAgICAgICAgICByZXR1cm4gYXJhYmljTnVtYmVycztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZURlY2ltYWxDaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL9mrLywgJy4nKTsgLy8gRGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZVRob3VzYW5kU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC/ZrC9nLCAnJyk7IC8vIFRob3VzYW5kIHNlcGFyYXRvclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgbnVtYmVycyBvbmx5XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1vZoNmh2aLZo9mk2aXZptmn2ajZqV0vZywgZCA9PiBkLmNoYXJDb2RlQXQoMCkgLSAxNjMyKSAvLyBBcmFiaWMgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9b27Dbsduy27PbtNu127bbt9u427ldL2csIGQgPT4gZC5jaGFyQ29kZUF0KDApIC0gMTc3Nik7IC8vIFBlcnNpYW4gbnVtYmVyc1xyXG5cclxuICAgICAgICAvLyBgTmFOYCBoYXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBzdHJpbmcgYCdOYU4nYFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdEFzTnVtYmVyID0gTnVtYmVyKHJlc3VsdCk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHJlc3VsdEFzTnVtYmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0QXNOdW1iZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmV0dXJuQU51bWJlcikge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRBc051bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBjdXN0b20gZXZlbnQgYW5kIGltbWVkaWF0ZWx5IHNlbnQgaXQgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBldmVudCBpcyB0aHJvd24gZnJvbSBgZG9jdW1lbnRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBlbGVtZW50ID0gZG9jdW1lbnQsIGRldGFpbCA9IG51bGwpIHtcclxuICAgICAgICBsZXQgZXZlbnQ7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xyXG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCB7IGRldGFpbCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgKElFKVxyXG4gICAgICovXHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xyXG4gICAgICAgICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcclxuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XHJcbiAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgZGVmYXVsdFNldHRpbmdzLCBqUXVlcnkuZm4uYXV0b051bWVyaWMubGFuZy5UdXJraXNoLCB7IGN1cnJlbmN5U3ltYm9sOiAnJyB9KTtcclxuXHJcbiAgICAvLyBIaWphY2sgdGhlIG9yaWdpbmFsIHZhbCBmbiBpbiBvcmRlciB0b1xyXG4gICAgLy8gdXNlICRhdXRvTnVtZXJpYy52YWwoKSBhbmQgYmUgYWJsZSB0byBnZXQvc2V0XHJcbiAgICAvLyB0aGUgdW5tYXNrZWQgdmFsdWUuXHJcbiAgICBqUXVlcnkuZm4udmFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICRtZSA9ICQobWUpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGFuIGluc3RhbmNlIG9mIGF1dG9OdW1lcmljLFxyXG4gICAgICAgIC8vIHNpbXBseSBjYWxsIHRoZSBvcmlnaW5hbCBqUXVlcnkuZm4udmFsXHJcbiAgICAgICAgaWYgKCRtZS5kYXRhKCdhdXRvTnVtZXJpYycpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeU9yaWdpbmFsVmFsLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIFdlJ3JlIHRyeWluZyB0byByZWFkIHRoZSBudW1lcmljIHZhbHVlXHJcbiAgICAgICAgICAgIHJldHVybiAkbWUuYXV0b051bWVyaWMoJ2dldCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHsgLy8gV2UncmUgdHJ5aW5nIHRvIHNldCBhIHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVmFsID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGxldCBudW1lcmljVmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgICAgICAgICAgICAgIG51bWVyaWNWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBcIiR7b3JpZ2luYWxWYWx9XCIgaXMgbm90IGEgbnVtYmVyLmA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYFRoZSB0eXBlIFwiJHt0eXBlb2YgdmFsdWV9XCIgaXMgbm90IHN1cHBvcnRlZC5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbnVtZXJpY1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAkbWUuYXV0b051bWVyaWMoJ3NldCcsIG51bWVyaWNWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcclxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXHJcbiAgICBnZXREZWZhdWx0Q29uZmlnLFxyXG4gICAgZ2V0TGFuZ3VhZ2VzLFxyXG4gICAgdmFsaWRhdGUsIC8vIGFuLnZhbGlkYXRlKG9wdGlvbnMpIDogdGhyb3dzIGlmIG5lY2Vzc2FyeVxyXG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy8gYW4uYXJlU2V0dGluZ3NWYWxpZChvcHRpb25zKSA6IHJldHVybiB0cnVlIG9yIGZhbHNlIC8vVE9ETyBJcyB0aGlzIHJlZHVuZGFudD8gU2hvdWxkIHdlIGxldCB0aGUgZGV2ZWxvcGVycyB3cmFwIGVhY2ggYXV0b051bWVyaWMudmFsaWRhdGUoKSBjYWxscyBpbiB0cnkvY2F0Y2ggYmxvY2s/IE9yIHNob3VsZCB3ZSBqdXN0IGZhY2lsaXRhdGUgdGhlaXIgbGlmZSBieSBkb2luZyBpdCBhbHJlYWR5P1xyXG5cclxuICAgIC8vVE9ETyBDb21wbGV0ZSB0aGUgaW50ZXJmYWNlIHdpdGggZnVuY3Rpb25zIGhhdmluZyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgOlxyXG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxyXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXHJcbiAgICAvL3NldCAgICAgICAgICA6IGFuLnNldCh2YWx1ZSwgaW5wdXQpXHJcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcclxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXHJcbiAgICAvL2dldEZvcm1hdHRlZCA6IGFuLmdldEZvcm1hdHRlZChpbnB1dClcclxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxyXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxyXG4gICAgLy9zZXR0aW5ncyAgICAgOiBhbi5zZXR0aW5ncyhpbnB1dClcclxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxyXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxyXG4gICAgLy9kZXN0cm95ICAgICAgOiBhbi5kZXN0cm95KGlucHV0KVxyXG5cclxuICAgIC8vcmF3ICAgICAgICAgIDogYW4ucmF3KGlucHV0KSAvLyBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nXHJcbiAgICAvL251bWJlciAgICAgICA6IGFuLm51bWJlcihpbnB1dCkgLy8gUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIG51bWJlciAoV2FybmluZzogVGhpcyBjYW4gbGVhZCB0byBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBiaWcgbnVtYmVycylcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;