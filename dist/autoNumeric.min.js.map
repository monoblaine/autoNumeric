{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///autoNumeric.min.js","webpack:///webpack/bootstrap 209cfc9fe2f703046b88","webpack:///./src/autoNumeric.js","webpack:///external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","_typeof","obj","constructor","autoFormat","autoUnFormat","getDefaultConfig","getLanguages","validate","areSettingsValid","allowedTagList","defaultSettings","digitGroupSeparator","noSeparatorOnFocus","digitalGroupSpacing","decimalCharacter","decimalCharacterAlternative","currencySymbol","currencySymbolPlacement","negativePositiveSignPlacement","showPositiveSign","suffixText","overrideMinMaxLimits","maximumValue","minimumValue","decimalPlacesOverride","decimalPlacesShownOnFocus","scaleDivisor","scaleDecimalPlaces","scaleSymbol","saveValueToSessionStorage","onInvalidPaste","roundingMethod","allowDecimalPadding","negativeBracketsTypeOnBlur","emptyInputBehavior","leadingZero","formatOnPageLoad","selectNumberOnly","defaultValueOverride","unformatOnSubmit","outputFormat","showWarnings","failOnUnknownOption","keyCode","Backspace","Tab","Enter","Shift","Ctrl","Alt","PauseBreak","CapsLock","Esc","Space","PageUp","PageDown","End","Home","LeftArrow","UpArrow","RightArrow","DownArrow","Insert","Delete","num0","num1","num2","num3","num4","num5","num6","num7","num8","num9","a","b","d","e","f","g","h","j","k","l","n","o","q","r","s","t","u","v","w","x","y","z","Windows","RightClick","numpad0","numpad1","numpad2","numpad3","numpad4","numpad5","numpad6","numpad7","numpad8","numpad9","MultiplyNumpad","PlusNumpad","MinusNumpad","DotNumpad","SlashNumpad","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","NumLock","ScrollLock","MyComputer","MyCalculator","Semicolon","Equal","Comma","Hyphen","Dot","Slash","Backquote","LeftBracket","Backslash","RightBracket","Quote","Command","AndroidDefault","keyName","Unidentified","AltGr","Fn","FnLock","Hyper","Meta","Super","SymbolLock","Clear","Copy","CrSel","Cut","EraseEof","ExSel","Paste","Redo","Undo","Accept","Again","Attn","Cancel","ContextMenu","Execute","Find","Finish","Help","Pause","Play","Props","Select","ZoomIn","ZoomOut","BrightnessDown","BrightnessUp","Eject","LogOff","Power","PowerOff","PrintScreen","Hibernate","Standby","WakeUp","Compose","Dead","Print","Minus","Plus","NumpadDot","NumpadDotAlt","NumpadMultiply","NumpadPlus","NumpadMinus","NumpadSlash","NumpadDotObsoleteBrowsers","NumpadMultiplyObsoleteBrowsers","NumpadPlusObsoleteBrowsers","NumpadMinusObsoleteBrowsers","NumpadSlashObsoleteBrowsers","defaultMinimumValue","defaultMaximumValue","defaultRoundingMethod","defaultLeadingZero","defaultSelectNumberOnly","languageOption","French","NorthAmerican","British","Swiss","Japanese","Turkish","Spanish","Chinese","apply","$","isNull","isUndefined","isUndefinedOrNullOrEmpty","isString","str","String","isBoolean","isTrueOrFalseString","lowercaseValue","toLowerCase","isObject","reference","isEmptyObj","prop","hasOwnProperty","isNumber","isNaN","parseFloat","isFinite","isInt","parseInt","preparePastedText","text","holder","stripAllNonNumberCharacters","settingsClone","replace","contains","needle","indexOf","isInArray","array","toString","Error","decimalPlaces","_str$split","split","_str$split2","decimalPart","keyCodeNumber","event","which","character","fromCharCode","result","checkIfInRange","parsedMinValue","parsedMaxValue","parsedValue","parseStr","testMinMax","isNegative","numericString","checkEverywhere","arguments","isNegativeStrict","charAt","isZeroOrHasNoValue","test","setRawNegativeSign","replaceCharAt","string","index","newCharacter","substr","clampToRangeLimits","settings","Math","max","min","countNumberCharactersOnTheCaretLeftSide","formattedNumberString","caretPosition","numberDotOrNegativeSign","RegExp","numberDotAndNegativeSignCount","findCaretPositionInFormattedNumber","rawNumberString","caretPositionInRawValue","formattedNumberStringSize","rawNumberStringSize","formattedNumberStringIndex","rawNumberStringIndex","countCharInText","charCounter","convertCharacterCountToIndexPosition","characterCount","getElementSelection","that","position","selectionStart","focus","select","document","selection","createRange","moveStart","end","start","selectionEnd","setElementSelection","range","createTextRange","collapse","moveEnd","throwError","message","warning","showWarning","console","warn","runCallbacksFoundInTheSettingsObject","$this","each","val","autoNumeric","maximumVMinAndVMaxDecimalLength","leftOrAll","skipFirstAutoStrip","trailingNegative","skipLastAutoStrip","allowedAutoStrip","match","numRegAutoStrip","join","nSign","_s$split","_s$split2","integerPart","modifiedIntegerPart","negativeSignCharacter","mIntPos","slice","mIntNeg","hasFocus","stripReg","toggleNegativeBracket","_settings$negativeBra","_settings$negativeBra2","firstBracket","lastBracket","convertToNumericString","lastIndexOf","temp","arabicToLatinNumbers","toLocale","locale","Number","modifyNegativeSignAndDecimalCharacterForRawValue","modifyNegativeSignAndDecimalCharacterForFormattedValue","checkEmpty","inputValue","signOnEmpty","addGroupSeparators","strip","empty","isValueNegative","isZero","digitalGroup","_inputValue$split","_inputValue$split2","_inputValue$split3","_inputValue$split4","substring","positiveSignCharacter","rawValue","truncateZeros","roundedInputValue","temporaryDecimalPlacesOverride","regex","roundValue","round","ceil","floor","ivRounded","dPos","inputValueHasADot","vdPos","cDec","zeros","rLength","tRound","odd","ivArray","truncateDecimal","isPaste","_s$split3","_s$split4","modifiedDecimalPart","nL","search","xc","yc","xNeg","checkIfInRangeWithOverrideOption","minParse","maxParse","valParse","getCurrentElement","element","getAutoNumericHolder","update","data","AutoNumericHolder","get","keepAnOriginalSettingsCopy","oDec","oPad","oBracket","oSep","oSign","oSuffix","readCookie","name","nameEQ","ca","cookie","storageTest","mod","sessionStorage","setItem","removeItem","cleanLeadingTrailingZeros","trimPaddedZerosFromDecimalPlaces","_numericString$split","_numericString$split2","trimmedDecimalPart","saveValueToPersistentStorage","action","storedName","decodeURIComponent","date","expires","Date","setTime","getTime","toUTCString","getItem","_getStringOrArray","getArrayBehavior","formIndex","allFormElements","aiIndex","scIndex","rSubmitterTypes","rSubmittable","rCheckableType","rNonAutoNumericTypes","count","field","localName","type","disabled","checked","formFields","serializeArray","scElement","testInput","_ret2","serialize","formParts","_formParts$i$split","_formParts$i$split2","inputName","modifiedInputValue","onFocusInAndMouseEnter","is","jQueryOriginalVal","roundedValue","valueOnFocus","lastVal","onEmpty","onKeydown","_updateAutoNumericHolderEventKeycode","initialValueOnKeydown","readOnly","processed","eventKeyCode","triggerEvent","_updateAutoNumericHolderProperties","_skipAlways","_processCharacterDeletion","_formatValue","throwInput","preventDefault","formatted","onKeypress","eventCharacter","isCharacterInsertionAllowed","_processCharacterInsertion","onInput","androidSelectionStart","charCodeAt","androidCharEntered","decimalCharacterPosition","hasDecimalCharacter","onKeyup","skip","valuePartsBeforePaste","isOnAndroid","onFocusOutAndMouseLeave","origValue","_checkIfInRangeWithOv3","_checkIfInRangeWithOv4","minTest","maxTest","trigger","groupedValue","change","onPaste","rawPastedText","clipboardData","getData","initialFormattedValue","selectionSize","isAllInputTextSelected","isPasteNegative","untranslatedPastedText","pastedText","caretPositionOnInitialTextAfterPasting","initialUnformattedNumber","isInitialValueNegative","isPasteNegativeAndInitialValueIsPositive","leftPartContainedADot","leftPart","rightPart","leftFormattedPart","rightFormattedPart","lastGoodKnownResult","pastedTextIndex","modifiedLeftPart","lastGoodKnownResultIndex","lastGoodKnownResultSize","leftFormattedPart2","rightFormattedPart2","indexWherePastedTextHasBeenInserted","indexSelectionEndInRawValue","selectedText","valueHasBeenSet","valueHasBeenClamped","error","clampedValue","caretPositionInFormattedNumber","onBlur","onSubmit","closest","on","$settings","getInputIfSupportedTagAndType","$input","currentElementTag","formatDefaultValueOnPageLoad","setValue","currentValue","unLocalizedCurrentValue","toNumericValue","attr","Infinity","toStrip","tagList","correctNegativePositiveSignPlacementOption","calculateVMinAndVMaxIntegerSizes","_settings$maximumValu","_settings$maximumValu2","maximumValueIntegerPart","_ref3","_ref4","minimumValueIntegerPart","correctDecimalPlacesOverrideOption","setsAlternativeDecimalSeparatorCharacter","cachesUsualRegularExpressions","allNumbersReg","noAllNumbersReg","aNegReg","aNegRegAutoStrip","negativeSignRegPart","allowed","transformOptionsValuesToDefaultTypes","convertOldOptionsToNewOnes","options","oldOptionsConverter","aSep","nSep","dGroup","aDec","altDec","aSign","pSign","pNeg","aSuffix","oLimits","vMax","vMin","mDec","eDec","scaleDecimal","aStor","mRound","aPad","nBracket","wEmpty","lZero","aForm","sNumber","anDefault","unSetOnSubmit","outputType","debug","runOnce","caretFix","option","getInitialSettings","extend","tagData","NaN","arabicNumbers","returnANumber","parseDecimalCharacter","parseThousandSeparator","resultAsNumber","eventName","detail","window","CustomEvent","bubbles","cancelable","createEvent","initCustomEvent","dispatchEvent","fn","$that","setReal","pos","_setSelection","left","right","_getLeftAndRightPartA","_getLeftAndRightPartAroundTheSelection","_getLeftAndRightPartA2","stripZeros","newValue","parts","_normalizeParts","_checkIfInRangeWithOv","_checkIfInRangeWithOv2","testValue","_setCaretPosition","currencySymbolLen","hasNeg","valueLen","signPosition","_getSignPosition","oldParts","_getLeftAndRightPartA3","_getLeftAndRightPartA4","_setValueParts","ctrlKey","metaKey","shiftKey","_checkPaste","negLen","suffixTextLen","_expandSelectionOnSign","_ref","_ref2","_getUnformattedLeftAn3","_getUnformattedLeftAndRightPartAroundTheSelection","_getUnformattedLeftAn4","_getUnformattedLeftAn","_getUnformattedLeftAn2","_processCharacterDele","_processCharacterDeletionIfTrailingNegativeSign","_processCharacterDele2","eventOrChar","_getUnformattedLeftAn5","_getUnformattedLeftAn6","eventNumber","_this","leftLength","_getUnformattedLeftAn7","_getUnformattedLeftAn8","_leftLength$split","_leftLength$split2","subParts","leftAr","shift","signParts","escapeChr","escapedParts","miniParts","leftReg","newLeft","input","methods","init","_this2","eventHandlers","eventConfigs","handler","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","eventConfig","addEventListener","return","initialized","misc","removeAllEvents","el","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","removeEventListener","off","destroy","clearValue","removeData","wipe","set","_checkIfInRangeWithOv5","_checkIfInRangeWithOv6","attemptedValue","hasBeenRounded","tempDecimal","onOff","unSet","reSet","eq","getLocalized","getNumber","getFormatted","getString","getArray","getSettings","method","_len","args","_key","defaults","lang","valueString","_checkIfInRangeWithOv7","_checkIfInRangeWithOv8","autoStrip","autoUnformat","userOptions","shouldExtendDefaultOptions","testPositiveInteger","testNumericalCharacters","testFloatOrIntegerAndPossibleNegativeSign","testPositiveFloatOrInteger","vMinAndVMaxMaximumDecimalPlaces","autoValidate","isValid","params","evt","Event","me","$me","originalVal","numericValue","default","format","unFormat"],"mappings":"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","file":"autoNumeric.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\n\tvar jQuery = __webpack_require__(1);\n\tvar $ = __webpack_require__(1);\n\t(function() {\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t *               autoNumeric.js\r\n\t *\r\n\t * @version      2.0.12\r\n\t * @date         2017-04-07 UTC 07:00\r\n\t *\r\n\t * @author       Bob Knothe\r\n\t * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n\t *               cf. AUTHORS.md.\r\n\t * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n\t * @since        2009-08-09\r\n\t *\r\n\t * @summary      autoNumeric is a library that provides live as-you-type\r\n\t *               formatting for international numbers and currencies.\r\n\t *\r\n\t *               Note : Some functions are borrowed from big.js\r\n\t * @link         https://github.com/MikeMcl/big.js/\r\n\t *\r\n\t * Please report any bugs to https://github.com/autoNumeric/autoNumeric\r\n\t *\r\n\t * @license      Released under the MIT License\r\n\t * @link         http://www.opensource.org/licenses/mit-license.php\r\n\t *\r\n\t * Permission is hereby granted, free of charge, to any person\r\n\t * obtaining a copy of this software and associated documentation\r\n\t * files (the \"Software\"), to deal in the Software without\r\n\t * restriction, including without limitation the rights to use,\r\n\t * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n\t * copies of the Software, and to permit persons to whom the\r\n\t * Software is furnished to do so, subject to the following\r\n\t * conditions:\r\n\t *\r\n\t * The above copyright notice and this permission notice shall be\r\n\t * included in all copies or substantial portions of the Software.\r\n\t *\r\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n\t * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n\t * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n\t * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n\t * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n\t * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n\t * OTHER DEALINGS IN THE SOFTWARE.\r\n\t */\n\t\n\t/* global module, require, define */\n\t\n\t// Functions names for ES6 exports\n\tvar autoFormat = void 0;\n\tvar autoUnFormat = void 0;\n\tvar getDefaultConfig = void 0;\n\tvar getLanguages = void 0;\n\tvar validate = void 0;\n\tvar areSettingsValid = void 0;\n\t\n\t// AutoNumeric default settings\n\t/**\r\n\t * List of allowed tag on which autoNumeric can be used.\r\n\t */\n\tvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\t\n\t/**\r\n\t * Defaults options are public - these can be overridden by the following method:\r\n\t * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" \">`)\r\n\t * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' ' });`)\r\n\t * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n\t */\n\tvar defaultSettings = {\n\t    /* Allowed thousand grouping separator characters :\r\n\t     * ','      // Comma\r\n\t     * '.'      // Dot\r\n\t     * ' '      // Normal space\r\n\t     * '\\u2009' // Thin-space\r\n\t     * '\\u202f' // Narrow no-break space\r\n\t     * '\\u00a0' // No-break space\r\n\t     * ''       // No separator\r\n\t     * \"'\"      // Apostrophe\r\n\t     * ''      // Arabic thousands separator\r\n\t     * ''      // Dot above\r\n\t     * Deprecated older option name : aSep\r\n\t     */\n\t    digitGroupSeparator: ',',\n\t\n\t    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n\t     * example if the input value \"$ 1,999.88 suffix\"\r\n\t     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n\t     * Deprecated older option name : nSep\r\n\t     */\n\t    noSeparatorOnFocus: false,\n\t\n\t    /* Digital grouping for the thousand separator used in Format\r\n\t     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n\t     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n\t     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n\t     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n\t     * Deprecated older option name : dGroup\r\n\t     */\n\t    digitalGroupSpacing: '3',\n\t\n\t    /* Allowed decimal separator characters :\r\n\t     * ',' : Comma\r\n\t     * '.' : Dot\r\n\t     * '' : Middle-dot\r\n\t     * '' : Arabic decimal separator\r\n\t     * '' : Decimal separator key symbol\r\n\t     * Deprecated older option name : aDec\r\n\t     */\n\t    decimalCharacter: '.',\n\t\n\t    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n\t     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n\t     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n\t     * Deprecated older option name : altDec\r\n\t     */\n\t    decimalCharacterAlternative: null,\n\t\n\t    /* currencySymbol = allowed currency symbol\r\n\t     * Must be in quotes currencySymbol: \"$\"\r\n\t     * space to the right of the currency symbol currencySymbol: '$ '\r\n\t     * space to the left of the currency symbol currencySymbol: ' $'\r\n\t     * Deprecated older option name : aSign\r\n\t     */\n\t    currencySymbol: '',\n\t\n\t    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n\t     * for prefix currencySymbolPlacement: \"p\" (default)\r\n\t     * for suffix currencySymbolPlacement: \"s\"\r\n\t     * Deprecated older option name : pSign\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n\t    currencySymbolPlacement: 'p',\n\t\n\t    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n\t     * -1,234.56  => default no options required\r\n\t     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n\t     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n\t     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n\t     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n\t     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n\t     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n\t     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n\t     * Deprecated older option name : pNeg\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n\t    negativePositiveSignPlacement: null,\n\t\n\t    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n\t     * By default, this positive sign is not shown.\r\n\t     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n\t     */\n\t    showPositiveSign: false,\n\t\n\t    /* Additional suffix\r\n\t     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n\t     * Numeric characters and negative sign not allowed'\r\n\t     * Deprecated older option name : aSuffix\r\n\t     */\n\t    suffixText: '',\n\t\n\t    /* Override min max limits\r\n\t     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n\t     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n\t     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n\t     * Deprecated older option name : oLimits\r\n\t     */\n\t    overrideMinMaxLimits: null,\n\t\n\t    /* Maximum possible value\r\n\t     * value must be enclosed in quotes and use the period for the decimal point\r\n\t     * value must be larger than minimumValue\r\n\t     * Deprecated older option name : vMax\r\n\t     */\n\t    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\t\n\t    /* Minimum possible value\r\n\t     * value must be enclosed in quotes and use the period for the decimal point\r\n\t     * value must be smaller than maximumValue\r\n\t     * Deprecated older option name : vMin\r\n\t     */\n\t    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\t\n\t    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n\t     * Deprecated older option name : mDec\r\n\t     */\n\t    decimalPlacesOverride: null,\n\t\n\t    /* Expanded decimal places visible when input has focus - example:\r\n\t     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n\t     * the \"get\" method returns the extended decimal places\r\n\t     * Deprecated older option name : eDec\r\n\t     */\n\t    decimalPlacesShownOnFocus: null,\n\t\n\t    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n\t     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n\t     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n\t     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n\t     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n\t     */\n\t\n\t    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n\t     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n\t     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n\t     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n\t     */\n\t    scaleDivisor: null,\n\t\n\t    /*\r\n\t     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n\t     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n\t     * Deprecated older option name : scaleDecimal\r\n\t     */\n\t    scaleDecimalPlaces: null,\n\t\n\t    /*\r\n\t     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n\t     * This is optional too.\r\n\t     */\n\t    scaleSymbol: null,\n\t\n\t    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n\t     * if ie 6 or 7 the value will be saved as a session cookie\r\n\t     * Deprecated older option name : aStor\r\n\t     */\n\t    saveValueToSessionStorage: false,\n\t\n\t    /*\r\n\t     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n\t     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n\t     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n\t     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n\t     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n\t     *                The non-pasted numbers are dropped and therefore not used at all.\r\n\t     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n\t     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n\t     *\r\n\t     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n\t     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n\t     *          Only the first number will be used (here '123').\r\n\t     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n\t     */\n\t    //TODO Shouldn't we use `truncate` as the default value?\n\t    onInvalidPaste: 'error',\n\t\n\t    /* method used for rounding\r\n\t     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n\t     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n\t     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n\t     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n\t     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n\t     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n\t     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n\t     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n\t     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n\t     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n\t     * roundingMethod: \"U05\" Rounds up to next .05\r\n\t     * roundingMethod: \"D05\" Rounds down to next .05\r\n\t     * Deprecated older option name : mRound\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n\t    //TODO Add an `an.roundingMethod` object that enum those options clearly\n\t    roundingMethod: 'S',\n\t\n\t    /* Allow padding the decimal places with zeros\r\n\t     * allowDecimalPadding: true - always Pad decimals with zeros\r\n\t     * allowDecimalPadding: false - does not pad with zeros.\r\n\t     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n\t     *\r\n\t     * thanks to Jonas Johansson for the suggestion\r\n\t     * Deprecated older option name : aPad\r\n\t     */\n\t    allowDecimalPadding: true,\n\t\n\t    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n\t     * Those brackets are visible only when the field does NOT have the focus.\r\n\t     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n\t     * This option can be of the following values :\r\n\t     * null, // This is the default value, which deactivate this feature\r\n\t     * '(,)',\r\n\t     * '[,]',\r\n\t     * '<,>' or\r\n\t     * '{,}'\r\n\t     * Deprecated older option name : nBracket\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n\t    negativeBracketsTypeOnBlur: null,\n\t\n\t    /* Displayed on empty string \"\"\r\n\t     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n\t     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n\t     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n\t     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n\t     * Deprecated older option name : wEmpty\r\n\t     */\n\t    emptyInputBehavior: 'focus',\n\t\n\t    /* Controls leading zero behavior\r\n\t     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n\t     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n\t     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n\t     * Deprecated older option name : lZero\r\n\t     */\n\t    leadingZero: 'deny',\n\t\n\t    /* Determine if the default value will be formatted on initialization.\r\n\t     * true = automatically formats the default value on initialization\r\n\t     * false = will not format the default value on initialization\r\n\t     * Deprecated older option name : aForm\r\n\t     */\n\t    formatOnPageLoad: true,\n\t\n\t    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n\t     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n\t     * Deprecated older option name : sNumber\r\n\t     */\n\t    selectNumberOnly: false,\n\t\n\t    /* Helper option for ASP.NET postback\r\n\t     * should be the value of the unformatted default value\r\n\t     * examples:\r\n\t     * no default value=\"\" {defaultValueOverride: \"\"}\r\n\t     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n\t     * Deprecated older option name : anDefault\r\n\t     */\n\t    defaultValueOverride: null,\n\t\n\t    /* Removes formatting on submit event\r\n\t     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n\t     * review the 'unSet' method for other formats\r\n\t     * Deprecated older option name : unSetOnSubmit\r\n\t     */\n\t    unformatOnSubmit: false,\n\t\n\t    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n\t     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n\t     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n\t     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n\t     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n\t     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n\t     * Deprecated older option name : outputType\r\n\t     */\n\t    outputFormat: null,\n\t\n\t    /* Defines if warnings should be shown\r\n\t     * Error handling function\r\n\t     * true => all warning are shown\r\n\t     * false => no warnings are shown, only the thrown errors\r\n\t     * Deprecated older option name : debug\r\n\t     */\n\t    showWarnings: true,\n\t\n\t    /*\r\n\t     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n\t     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n\t     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n\t     */\n\t    failOnUnknownOption: false\n\t};\n\t\n\t/**\r\n\t * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n\t * //TODO Replace every call to this object with a call to `keyName`\r\n\t * @deprecated\r\n\t */\n\tvar keyCode = {\n\t    Backspace: 8,\n\t    Tab: 9,\n\t    Enter: 13,\n\t    Shift: 16,\n\t    Ctrl: 17,\n\t    Alt: 18,\n\t    PauseBreak: 19,\n\t    CapsLock: 20,\n\t    Esc: 27,\n\t    Space: 32,\n\t    PageUp: 33,\n\t    PageDown: 34,\n\t    End: 35,\n\t    Home: 36,\n\t    LeftArrow: 37,\n\t    UpArrow: 38,\n\t    RightArrow: 39,\n\t    DownArrow: 40,\n\t    Insert: 45,\n\t    Delete: 46,\n\t    num0: 48,\n\t    num1: 49,\n\t    num2: 50,\n\t    num3: 51,\n\t    num4: 52,\n\t    num5: 53,\n\t    num6: 54,\n\t    num7: 55,\n\t    num8: 56,\n\t    num9: 57,\n\t    a: 65,\n\t    b: 66,\n\t    c: 67,\n\t    d: 68,\n\t    e: 69,\n\t    f: 70,\n\t    g: 71,\n\t    h: 72,\n\t    i: 73,\n\t    j: 74,\n\t    k: 75,\n\t    l: 76,\n\t    m: 77,\n\t    n: 78,\n\t    o: 79,\n\t    p: 80,\n\t    q: 81,\n\t    r: 82,\n\t    s: 83,\n\t    t: 84,\n\t    u: 85,\n\t    v: 86,\n\t    w: 87,\n\t    x: 88,\n\t    y: 89,\n\t    z: 90,\n\t    Windows: 91,\n\t    RightClick: 93,\n\t    numpad0: 96,\n\t    numpad1: 97,\n\t    numpad2: 98,\n\t    numpad3: 99,\n\t    numpad4: 100,\n\t    numpad5: 101,\n\t    numpad6: 102,\n\t    numpad7: 103,\n\t    numpad8: 104,\n\t    numpad9: 105,\n\t    MultiplyNumpad: 106,\n\t    PlusNumpad: 107,\n\t    MinusNumpad: 109,\n\t    DotNumpad: 110,\n\t    SlashNumpad: 111,\n\t    F1: 112,\n\t    F2: 113,\n\t    F3: 114,\n\t    F4: 115,\n\t    F5: 116,\n\t    F6: 117,\n\t    F7: 118,\n\t    F8: 119,\n\t    F9: 120,\n\t    F10: 121,\n\t    F11: 122,\n\t    F12: 123,\n\t    NumLock: 144,\n\t    ScrollLock: 145,\n\t    MyComputer: 182,\n\t    MyCalculator: 183,\n\t    Semicolon: 186,\n\t    Equal: 187,\n\t    Comma: 188,\n\t    Hyphen: 189,\n\t    Dot: 190,\n\t    Slash: 191,\n\t    Backquote: 192,\n\t    LeftBracket: 219,\n\t    Backslash: 220,\n\t    RightBracket: 221,\n\t    Quote: 222,\n\t    Command: 224,\n\t    AndroidDefault: 229 };\n\t\n\t/**\r\n\t * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n\t * Those names are listed here :\r\n\t * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n\t */\n\tvar keyName = {\n\t    // Special values\n\t    Unidentified: 'Unidentified',\n\t\n\t    // Modifier keys\n\t    Alt: 'Alt',\n\t    AltGr: 'AltGraph',\n\t    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n\t    Ctrl: 'Control',\n\t    Fn: 'Fn',\n\t    FnLock: 'FnLock',\n\t    Hyper: 'Hyper', // 'OS' under Firefox\n\t    Meta: 'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\n\t    Windows: 'Meta', // This is a non-official key name\n\t    Command: 'Meta', // This is a non-official key name\n\t    NumLock: 'NumLock',\n\t    ScrollLock: 'ScrollLock',\n\t    Shift: 'Shift',\n\t    Super: 'Super', // 'OS' under Firefox\n\t    Symbol: 'Symbol',\n\t    SymbolLock: 'SymbolLock',\n\t\n\t    // Whitespace keys\n\t    Enter: 'Enter',\n\t    Tab: 'Tab',\n\t    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\t\n\t    // Navigation keys\n\t    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n\t    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n\t    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n\t    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n\t    End: 'End',\n\t    Home: 'Home',\n\t    PageDown: 'PageDown',\n\t    PageUp: 'PageUp',\n\t\n\t    // Editing keys\n\t    Backspace: 'Backspace',\n\t    Clear: 'Clear',\n\t    Copy: 'Copy',\n\t    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n\t    Cut: 'Cut',\n\t    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n\t    EraseEof: 'EraseEof',\n\t    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n\t    Insert: 'Insert',\n\t    Paste: 'Paste',\n\t    Redo: 'Redo',\n\t    Undo: 'Undo',\n\t\n\t    // UI keys\n\t    Accept: 'Accept',\n\t    Again: 'Again',\n\t    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n\t    Cancel: 'Cancel',\n\t    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n\t    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n\t    Execute: 'Execute',\n\t    Find: 'Find',\n\t    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n\t    Help: 'Help',\n\t    Pause: 'Pause',\n\t    Play: 'Play',\n\t    Props: 'Props',\n\t    Select: 'Select',\n\t    ZoomIn: 'ZoomIn',\n\t    ZoomOut: 'ZoomOut',\n\t\n\t    // Device keys\n\t    BrightnessDown: 'BrightnessDown',\n\t    BrightnessUp: 'BrightnessUp',\n\t    Eject: 'Eject',\n\t    LogOff: 'LogOff',\n\t    Power: 'Power',\n\t    PowerOff: 'PowerOff',\n\t    PrintScreen: 'PrintScreen',\n\t    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n\t    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n\t    WakeUp: 'WakeUp',\n\t\n\t    // IME and composition keys\n\t    Compose: 'Compose',\n\t    Dead: 'Dead',\n\t\n\t    // Function keys\n\t    F1: 'F1',\n\t    F2: 'F2',\n\t    F3: 'F3',\n\t    F4: 'F4',\n\t    F5: 'F5',\n\t    F6: 'F6',\n\t    F7: 'F7',\n\t    F8: 'F8',\n\t    F9: 'F9',\n\t    F10: 'F10',\n\t    F11: 'F11',\n\t    F12: 'F12',\n\t\n\t    // Document keys\n\t    Print: 'Print',\n\t\n\t    // 'Normal' keys\n\t    num0: '0',\n\t    num1: '1',\n\t    num2: '2',\n\t    num3: '3',\n\t    num4: '4',\n\t    num5: '5',\n\t    num6: '6',\n\t    num7: '7',\n\t    num8: '8',\n\t    num9: '9',\n\t    numpad0: '0',\n\t    numpad1: '1',\n\t    numpad2: '2',\n\t    numpad3: '3',\n\t    numpad4: '4',\n\t    numpad5: '5',\n\t    numpad6: '6',\n\t    numpad7: '7',\n\t    numpad8: '8',\n\t    numpad9: '9',\n\t    a: 'a',\n\t    b: 'b',\n\t    c: 'c',\n\t    d: 'd',\n\t    e: 'e',\n\t    f: 'f',\n\t    g: 'g',\n\t    h: 'h',\n\t    i: 'i',\n\t    j: 'j',\n\t    k: 'k',\n\t    l: 'l',\n\t    m: 'm',\n\t    n: 'n',\n\t    o: 'o',\n\t    p: 'p',\n\t    q: 'q',\n\t    r: 'r',\n\t    s: 's',\n\t    t: 't',\n\t    u: 'u',\n\t    v: 'v',\n\t    w: 'w',\n\t    x: 'x',\n\t    y: 'y',\n\t    z: 'z',\n\t    MultiplyNumpad: '*',\n\t    PlusNumpad: '+',\n\t    MinusNumpad: '-',\n\t    DotNumpad: '.',\n\t    SlashNumpad: '/',\n\t    Semicolon: ';',\n\t    Equal: '=',\n\t    Comma: ',',\n\t    Hyphen: '-',\n\t    Minus: '-',\n\t    Plus: '+',\n\t    Dot: '.',\n\t    Slash: '/',\n\t    Backquote: '`',\n\t    LeftBracket: '[',\n\t    RightBracket: ']',\n\t    Backslash: '\\\\',\n\t    Quote: \"'\",\n\t    NumpadDot: '.',\n\t    NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n\t    NumpadMultiply: '*',\n\t    NumpadPlus: '+',\n\t    NumpadMinus: '-',\n\t    NumpadSlash: '/',\n\t    NumpadDotObsoleteBrowsers: 'Decimal',\n\t    NumpadMultiplyObsoleteBrowsers: 'Multiply',\n\t    NumpadPlusObsoleteBrowsers: 'Add',\n\t    NumpadMinusObsoleteBrowsers: 'Subtract',\n\t    NumpadSlashObsoleteBrowsers: 'Divide'\n\t};\n\t\n\tvar defaultMinimumValue = '-999999999999.99';\n\tvar defaultMaximumValue = '999999999999.99';\n\tvar defaultRoundingMethod = 'U';\n\tvar defaultLeadingZero = 'deny';\n\tvar defaultSelectNumberOnly = true;\n\t\n\t/**\r\n\t * Predefined options for the most common languages\r\n\t */\n\tvar languageOption = {\n\t    French: { // Franais\n\t        digitGroupSeparator: '.', // or '\\u202f'\n\t        decimalCharacter: ',',\n\t        decimalCharacterAlternative: '.',\n\t        currencySymbol: '\\u202F\\u20AC',\n\t        currencySymbolPlacement: 's',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    NorthAmerican: {\n\t        digitGroupSeparator: ',',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '$',\n\t        currencySymbolPlacement: 'p',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    British: {\n\t        digitGroupSeparator: ',',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '',\n\t        currencySymbolPlacement: 'p',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    Swiss: { // Suisse\n\t        digitGroupSeparator: '\\'',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '\\u202FCHF',\n\t        currencySymbolPlacement: 's',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    Japanese: { // \n\t        digitGroupSeparator: ',',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '',\n\t        currencySymbolPlacement: 'p',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    Turkish: {\n\t        digitGroupSeparator: '.',\n\t        decimalCharacter: ',',\n\t        decimalCharacterAlternative: '.',\n\t        currencySymbol: '',\n\t        currencySymbolPlacement: 's',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue,\n\t        negativePositiveSignPlacement: 'p'\n\t    }\n\t};\n\tlanguageOption.Spanish = languageOption.French; // Espaol (idem French)\n\tlanguageOption.Chinese = languageOption.Japanese; //  (Chinese)\n\t\n\t/**\r\n\t * UMD structure\r\n\t */\n\t(function (factory) {\n\t    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n\t        // Node/CommonJS\n\t        module.exports = factory(require('jquery'));\n\t    } else {\n\t        // Browser globals\n\t        factory(window.jQuery);\n\t    }\n\t})(function ($) {\n\t    var jQueryOriginalVal = $.fn.val;\n\t\n\t    // Helper functions\n\t\n\t    /**\r\n\t     * Return TRUE if the `value` is null\r\n\t     *\r\n\t     * @static\r\n\t     * @param {*} value The value to test\r\n\t     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n\t     */\n\t    function isNull(value) {\n\t        return value === null;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the `value` is undefined\r\n\t     *\r\n\t     * @static\r\n\t     * @param {*} value The value to test\r\n\t     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n\t     */\n\t    function isUndefined(value) {\n\t        return value === void 0;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the `value` is undefined, null or empty\r\n\t     *\r\n\t     * @param {*} value\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isUndefinedOrNullOrEmpty(value) {\n\t        return value === null || value === void 0 || '' === value;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given parameter is a String\r\n\t     *\r\n\t     * @param {*} str\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isString(str) {\n\t        return typeof str === 'string' || str instanceof String;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a boolean\r\n\t     *\r\n\t     * @static\r\n\t     * @param {*} value\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isBoolean(value) {\n\t        return typeof value === 'boolean';\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a string 'true' or 'false'\r\n\t     *\r\n\t     * This function accepts any cases for those strings.\r\n\t     * @param {string} value\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isTrueOrFalseString(value) {\n\t        var lowercaseValue = String(value).toLowerCase();\n\t        return lowercaseValue === 'true' || lowercaseValue === 'false';\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is an object\r\n\t     *\r\n\t     * @param {*} reference\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isObject(reference) {\n\t        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given object is empty\r\n\t     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n\t     *\r\n\t     * @param {object} obj\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isEmptyObj(obj) {\n\t        for (var prop in obj) {\n\t            if (obj.hasOwnProperty(prop)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a number (or a number written as a string).\r\n\t     *\r\n\t     * @param {*} n\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isNumber(n) {\n\t        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is an integer (and not a float).\r\n\t     *\r\n\t     * @param {*} n\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isInt(n) {\n\t        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n\t    }\n\t\n\t    /**\r\n\t     * Return the pasted text that will be used.\r\n\t     *\r\n\t     * @param {string} text\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @returns {string|void|XML|*}\r\n\t     */\n\t    function preparePastedText(text, holder) {\n\t        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE is the string `str` contains the string `needle`\r\n\t     * Note: this function does not coerce the parameters types\r\n\t     *\r\n\t     * @param {string} str\r\n\t     * @param {string} needle\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function contains(str, needle) {\n\t        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n\t            return false;\n\t        }\n\t\n\t        return str.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the `needle` is in the array\r\n\t     *\r\n\t     * @param {*} needle\r\n\t     * @param {Array} array\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isInArray(needle, array) {\n\t        if (!isArray(array) || array === [] || isUndefined(needle)) {\n\t            return false;\n\t        }\n\t\n\t        return array.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is an Array\r\n\t     *\r\n\t     * @param {*} arr\r\n\t     * @throws Error\r\n\t     * @returns {*|boolean}\r\n\t     */\n\t    function isArray(arr) {\n\t        if (Object.prototype.toString.call([]) === '[object Array]') {\n\t            // Make sure an array has a class attribute of [object Array]\n\t            // Test passed, now check if is an Array\n\t            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n\t        } else {\n\t            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n\t     *\r\n\t     * @param {string} str\r\n\t     * @returns {boolean}\r\n\t     */\n\t    // function hasDecimals(str) {\n\t    //     const [, decimalPart] = str.split('.');\n\t    //     return !isUndefined(decimalPart);\n\t    // }\n\t\n\t    /**\r\n\t     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n\t     *\r\n\t     * @param {string} str\r\n\t     * @returns {int}\r\n\t     */\n\t    function decimalPlaces(str) {\n\t        var _str$split = str.split('.'),\n\t            _str$split2 = _slicedToArray(_str$split, 2),\n\t            decimalPart = _str$split2[1];\n\t\n\t        if (!isUndefined(decimalPart)) {\n\t            return decimalPart.length;\n\t        }\n\t\n\t        return 0;\n\t    }\n\t\n\t    /**\r\n\t     * Return the code for the key used to generate the given event.\r\n\t     *\r\n\t     * @param {Event} event\r\n\t     * @returns {string|Number}\r\n\t     */\n\t    function keyCodeNumber(event) {\n\t        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n\t        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n\t    }\n\t\n\t    /**\r\n\t     * Return the character from the event key code.\r\n\t     * @example character(50) => '2'\r\n\t     *\r\n\t     * @param {Event} event\r\n\t     * @returns {string}\r\n\t     */\n\t    function character(event) {\n\t        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n\t            return String.fromCharCode(keyCodeNumber(event));\n\t        } else {\n\t            // Special case for obsolete browsers like IE that return the old names\n\t            var result = void 0;\n\t            switch (event.key) {\n\t                case 'Decimal':\n\t                    result = keyName.NumpadDot;\n\t                    break;\n\t                case 'Multiply':\n\t                    result = keyName.NumpadMultiply;\n\t                    break;\n\t                case 'Add':\n\t                    result = keyName.NumpadPlus;\n\t                    break;\n\t                case 'Subtract':\n\t                    result = keyName.NumpadMinus;\n\t                    break;\n\t                case 'Divide':\n\t                    result = keyName.NumpadSlash;\n\t                    break;\n\t                case 'Del':\n\t                    // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401 //FIXME  terminer\n\t                    result = keyName.Dot; // as of version 2.0.8 the character() function is only called on keypress event. The 'Del' does not throw the keypress event.\n\t                    break;\n\t                default:\n\t                    result = event.key;\n\t            }\n\t\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n\t     *\r\n\t     * @param {string} value\r\n\t     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n\t     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n\t        var parsedValue = parseStr(value);\n\t        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given string contains a negative sign :\r\n\t     * - everywhere in the string (by default), or\r\n\t     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n\t     *\r\n\t     * @param {string} numericString A number represented by a string\r\n\t     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isNegative(numericString) {\n\t        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        //TODO Use the `negativeSignCharacter` from the settings here\n\t        if (checkEverywhere) {\n\t            return contains(numericString, '-');\n\t        }\n\t\n\t        return isNegativeStrict(numericString);\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n\t     *\r\n\t     * @example isNegativeStrict('1234.56')     => false\r\n\t     * @example isNegativeStrict('1234.56-')    => false\r\n\t     * @example isNegativeStrict('-1234.56')    => true\r\n\t     * @example isNegativeStrict('-1,234.56 ') => true\r\n\t     *\r\n\t     * @param {string} numericString\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isNegativeStrict(numericString) {\n\t        //TODO Using the `negativeSignCharacter` from the settings here\n\t        return numericString.charAt(0) === '-';\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 '), or is empty (' ').\r\n\t     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n\t     *\r\n\t     * @param {string} numericString\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isZeroOrHasNoValue(numericString) {\n\t        return !/[1-9]/g.test(numericString);\n\t    }\n\t\n\t    /**\r\n\t     * Return the negative version of the value (represented as a string) given as a parameter.\r\n\t     *\r\n\t     * @param {string} value\r\n\t     * @returns {*}\r\n\t     */\n\t    function setRawNegativeSign(value) {\n\t        if (!isNegativeStrict(value)) {\n\t            return '-' + value;\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    /**\r\n\t     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n\t     *\r\n\t     * @param {string} string\r\n\t     * @param {int} index\r\n\t     * @param {string} newCharacter\r\n\t     * @returns {string}\r\n\t     */\n\t    function replaceCharAt(string, index, newCharacter) {\n\t        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n\t    }\n\t\n\t    /**\r\n\t     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n\t     *\r\n\t     * @param {string|number} value\r\n\t     * @param {object} settings\r\n\t     * @returns {number}\r\n\t     */\n\t    function clampToRangeLimits(value, settings) {\n\t        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n\t        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n\t    }\n\t\n\t    /**\r\n\t     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n\t     *\r\n\t     * @param {string} formattedNumberString\r\n\t     * @param {int} caretPosition This must be a positive integer\r\n\t     * @param {string} decimalCharacter\r\n\t     * @returns {number}\r\n\t     */\n\t    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n\t        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n\t        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\t\n\t        var numberDotAndNegativeSignCount = 0;\n\t        for (var i = 0; i < caretPosition; i++) {\n\t            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n\t            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n\t                numberDotAndNegativeSignCount++;\n\t            }\n\t        }\n\t\n\t        return numberDotAndNegativeSignCount;\n\t    }\n\t\n\t    /**\r\n\t     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n\t     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n\t     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n\t     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n\t     *\r\n\t     * @example\r\n\t     * 1234567|89.01   : position 7 (rawNumberString)\r\n\t     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n\t     *\r\n\t     * @param {string} rawNumberString\r\n\t     * @param {int} caretPositionInRawValue\r\n\t     * @param {string} formattedNumberString\r\n\t     * @param {string} decimalCharacter\r\n\t     * @returns {*}\r\n\t     */\n\t    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n\t        var formattedNumberStringSize = formattedNumberString.length;\n\t        var rawNumberStringSize = rawNumberString.length;\n\t\n\t        var formattedNumberStringIndex = void 0;\n\t        var rawNumberStringIndex = 0;\n\t        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n\t            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n\t                rawNumberStringIndex++;\n\t            }\n\t        }\n\t\n\t        return formattedNumberStringIndex;\n\t    }\n\t\n\t    /**\r\n\t     * Count the number of occurrence of the given character, in the given text.\r\n\t     *\r\n\t     * @param {string} character\r\n\t     * @param {string} text\r\n\t     * @returns {number}\r\n\t     */\n\t    function countCharInText(character, text) {\n\t        var charCounter = 0;\n\t        for (var i = 0; i < text.length; i++) {\n\t            if (text[i] === character) {\n\t                charCounter++;\n\t            }\n\t        }\n\t\n\t        return charCounter;\n\t    }\n\t\n\t    /**\r\n\t     * Return the index that can be used to set the caret position.\r\n\t     * This takes into account that the position is starting at '0', not 1.\r\n\t     *\r\n\t     * @param {int} characterCount\r\n\t     * @returns {number}\r\n\t     */\n\t    function convertCharacterCountToIndexPosition(characterCount) {\n\t        return Math.max(characterCount, characterCount - 1);\n\t    }\n\t\n\t    /**\r\n\t     * Cross browser routine for getting selected range/cursor position\r\n\t     *\r\n\t     * @param {HTMLElement|EventTarget} that\r\n\t     * @returns {{}}\r\n\t     */\n\t    function getElementSelection(that) {\n\t        var position = {};\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var select = document.selection.createRange();\n\t            position.length = select.text.length;\n\t            select.moveStart('character', -that.value.length);\n\t            position.end = select.text.length;\n\t            position.start = position.end - position.length;\n\t        } else {\n\t            position.start = that.selectionStart;\n\t            position.end = that.selectionEnd;\n\t            position.length = position.end - position.start;\n\t        }\n\t\n\t        return position;\n\t    }\n\t\n\t    /**\r\n\t     * Cross browser routine for setting selected range/cursor position\r\n\t     *\r\n\t     * @param {HTMLElement|EventTarget} that\r\n\t     * @param {int} start\r\n\t     * @param {int|null} end\r\n\t     */\n\t    function setElementSelection(that, start) {\n\t        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t        if (isUndefinedOrNullOrEmpty(end)) {\n\t            end = start;\n\t        }\n\t\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var range = that.createTextRange();\n\t            range.collapse(true);\n\t            range.moveEnd('character', end);\n\t            range.moveStart('character', start);\n\t            range.select();\n\t        } else {\n\t            that.selectionStart = start;\n\t            that.selectionEnd = end;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Function that throw error messages\r\n\t     *\r\n\t     * @param {string} message\r\n\t     */\n\t    function throwError(message) {\n\t        throw new Error(message);\n\t    }\n\t\n\t    /**\r\n\t     * Function that display a warning messages, according to the debug level.\r\n\t     *\r\n\t     * @param {string} message\r\n\t     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n\t     */\n\t    function warning(message) {\n\t        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        if (showWarning) {\n\t            /* eslint no-console: 0 */\n\t            console.warn('Warning: ' + message);\n\t        }\n\t    }\n\t\n\t    // autoNumeric-specific functions\n\t\n\t    /**\r\n\t     * Run any callbacks found in the settings object.\r\n\t     * Any parameter could be a callback:\r\n\t     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n\t     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {object} settings\r\n\t     */\n\t    function runCallbacksFoundInTheSettingsObject($this, settings) {\n\t        // Loops through the settings object (option array) to find the following\n\t        $.each(settings, function (k, val) {\n\t            if (typeof val === 'function') {\n\t                settings[k] = val($this, settings, k);\n\t            } else if (typeof $this.autoNumeric[val] === 'function') {\n\t                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n\t                settings[k] = $this.autoNumeric[val]($this, settings, k);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n\t     *\r\n\t     * @param {string} minimumValue\r\n\t     * @param {string} maximumValue\r\n\t     * @returns {number}\r\n\t     */\n\t    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n\t        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n\t    }\n\t\n\t    /**\r\n\t     * Strip all unwanted non-number characters.\r\n\t     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} leftOrAll\r\n\t     * @returns {string|*}\r\n\t     */\n\t    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n\t        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n\t        //TODO Refactor this with `convertToNumericString()` if possible?\n\t        if (settings.currencySymbol !== '') {\n\t            // Remove currency sign\n\t            s = s.replace(settings.currencySymbol, '');\n\t        }\n\t        if (settings.suffixText) {\n\t            // Remove suffix\n\t            while (contains(s, settings.suffixText)) {\n\t                s = s.replace(settings.suffixText, '');\n\t            }\n\t        }\n\t\n\t        // First replace anything before digits\n\t        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\t\n\t        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n\t            settings.trailingNegative = true;\n\t        }\n\t\n\t        // Then replace anything after digits\n\t        s = s.replace(settings.skipLastAutoStrip, '$1');\n\t\n\t        // Then remove any uninteresting characters\n\t        s = s.replace(settings.allowedAutoStrip, '');\n\t        if (settings.decimalCharacterAlternative) {\n\t            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n\t        }\n\t\n\t        // Get only number string\n\t        var m = s.match(settings.numRegAutoStrip);\n\t        s = m ? [m[1], m[2], m[3]].join('') : '';\n\t\n\t        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n\t            var nSign = '';\n\t\n\t            var _s$split = s.split(settings.decimalCharacter),\n\t                _s$split2 = _slicedToArray(_s$split, 2),\n\t                integerPart = _s$split2[0],\n\t                decimalPart = _s$split2[1];\n\t\n\t            var modifiedIntegerPart = integerPart;\n\t            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n\t                nSign = settings.negativeSignCharacter;\n\t                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n\t            }\n\t\n\t            // Strip leading zero on positive value if need\n\t            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            // Strip leading zero on negative value if need\n\t            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n\t        }\n\t\n\t        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n\t            s = s.replace(settings.stripReg, '$1$2');\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Sets or removes brackets on negative values, depending on the focus state.\r\n\t     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n\t     * //TODO Use another object to keep track of internal data that are not settings\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function toggleNegativeBracket(s, settings) {\n\t        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n\t            //TODO Split the first and last bracket only once during the settings initialization\n\t            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n\t                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n\t                firstBracket = _settings$negativeBra2[0],\n\t                lastBracket = _settings$negativeBra2[1];\n\t\n\t            if (!settings.hasFocus) {\n\t                // Add brackets\n\t                s = s.replace(settings.negativeSignCharacter, '');\n\t                s = firstBracket + s + lastBracket;\n\t            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n\t                // Remove brackets\n\t                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n\t                s = s.replace(firstBracket, settings.negativeSignCharacter);\n\t                s = s.replace(lastBracket, '');\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n\t     *\r\n\t     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n\t     * Lastly, it also put the negative sign back to its normal position if needed.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {string|void|XML|*}\r\n\t     */\n\t    function convertToNumericString(s, settings) {\n\t        // Remove the currency symbol\n\t        s = s.replace(settings.currencySymbol, '');\n\t\n\t        // Remove the grouping separators (thousands separators usually)\n\t        s = s.replace(settings.digitGroupSeparator, '');\n\t\n\t        // Replace the decimal character by a dot\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace(settings.decimalCharacter, '.');\n\t        }\n\t\n\t        // Move the trailing negative sign to the right position, if any\n\t        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n\t            s = s.replace('-', '');\n\t            s = '-' + s;\n\t        }\n\t\n\t        // Convert any arabic numbers to latin ones\n\t        var temp = arabicToLatinNumbers(s, true, false, false);\n\t        if (!isNaN(temp)) {\n\t            s = temp.toString();\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n\t     * See the \"outputFormat\" option definition for more details.\r\n\t     *\r\n\t     * @param {string|null} value\r\n\t     * @param {string} locale\r\n\t     * @returns {*}\r\n\t     */\n\t    function toLocale(value, locale) {\n\t        if (isNull(locale) || locale === 'string') {\n\t            return value;\n\t        }\n\t\n\t        var result = void 0;\n\t        switch (locale) {\n\t            case 'number':\n\t                result = Number(value);\n\t                break;\n\t            case '.-':\n\t                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n\t                break;\n\t            case ',':\n\t            case '-,':\n\t                result = value.replace('.', ',');\n\t                break;\n\t            case ',-':\n\t                result = value.replace('.', ',');\n\t                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n\t                break;\n\t            // The default case\n\t            case '.':\n\t            case '-.':\n\t                result = value;\n\t                break;\n\t            default:\n\t                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {string}\r\n\t     */\n\t    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace(settings.decimalCharacter, '.');\n\t        }\n\t        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n\t            s = s.replace(settings.negativeSignCharacter, '-');\n\t        }\n\t        if (!s.match(/\\d/)) {\n\t            // The default value returned by `get` is not formatted with decimals\n\t            s += '0';\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {string}\r\n\t     */\n\t    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n\t        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n\t            s = s.replace('-', settings.negativeSignCharacter);\n\t        }\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace('.', settings.decimalCharacter);\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Private function to check for empty value\r\n\t     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n\t     *\r\n\t     * @param {string} inputValue\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} signOnEmpty\r\n\t     * @returns {*}\r\n\t     */\n\t    function checkEmpty(inputValue, settings, signOnEmpty) {\n\t        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n\t            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n\t                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n\t            }\n\t\n\t            return inputValue;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\r\n\t     * Modify the input value by adding the group separators, as defined in the settings.\r\n\t     *\r\n\t     * @param {string} inputValue\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function addGroupSeparators(inputValue, settings) {\n\t        if (settings.strip) {\n\t            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n\t        }\n\t\n\t        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n\t        if (settings.trailingNegative && !isNegative(inputValue)) {\n\t            inputValue = '-' + inputValue;\n\t        }\n\t\n\t        var empty = checkEmpty(inputValue, settings, true);\n\t        var isValueNegative = isNegative(inputValue);\n\t        var isZero = isZeroOrHasNoValue(inputValue);\n\t        if (isValueNegative) {\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        if (!isNull(empty)) {\n\t            return empty;\n\t        }\n\t\n\t        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n\t        var digitalGroup = void 0;\n\t        switch (settings.digitalGroupSpacing) {\n\t            case '2':\n\t                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n\t                break;\n\t            case '2s':\n\t                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n\t                break;\n\t            case '4':\n\t                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n\t                break;\n\t            default:\n\t                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n\t        }\n\t\n\t        // Splits the string at the decimal string\n\t\n\t        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n\t            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n\t            integerPart = _inputValue$split2[0],\n\t            decimalPart = _inputValue$split2[1];\n\t\n\t        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n\t            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\t\n\t            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\t\n\t            integerPart = _inputValue$split4[0];\n\t            decimalPart = _inputValue$split4[1];\n\t        }\n\t\n\t        if (settings.digitGroupSeparator !== '') {\n\t            // Re-inserts the thousand separator via a regular expression\n\t            while (digitalGroup.test(integerPart)) {\n\t                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n\t            }\n\t        }\n\t\n\t        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n\t            if (decimalPart.length > settings.decimalPlacesOverride) {\n\t                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n\t            }\n\t\n\t            // Joins the whole number with the decimal value\n\t            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n\t        } else {\n\t            // Otherwise if it's an integer\n\t            inputValue = integerPart;\n\t        }\n\t\n\t        settings.trailingNegative = false;\n\t\n\t        if (settings.currencySymbolPlacement === 'p') {\n\t            if (isValueNegative) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'l':\n\t                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n\t                        break;\n\t                    case 'r':\n\t                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n\t                        break;\n\t                    case 's':\n\t                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n\t                        settings.trailingNegative = true;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (settings.showPositiveSign && !isZero) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'l':\n\t                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n\t                        break;\n\t                    case 'r':\n\t                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n\t                        break;\n\t                    case 's':\n\t                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else {\n\t                inputValue = settings.currencySymbol + inputValue;\n\t            }\n\t        }\n\t\n\t        if (settings.currencySymbolPlacement === 's') {\n\t            if (isValueNegative) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'r':\n\t                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n\t                        settings.trailingNegative = true;\n\t                        break;\n\t                    case 'l':\n\t                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n\t                        settings.trailingNegative = true;\n\t                        break;\n\t                    case 'p':\n\t                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (settings.showPositiveSign && !isZero) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'r':\n\t                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n\t                        break;\n\t                    case 'l':\n\t                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n\t                        break;\n\t                    case 'p':\n\t                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else {\n\t                inputValue = inputValue + settings.currencySymbol;\n\t            }\n\t        }\n\t\n\t        // Removes the negative sign and places brackets\n\t        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n\t            inputValue = toggleNegativeBracket(inputValue, settings);\n\t        }\n\t\n\t        return inputValue + settings.suffixText;\n\t    }\n\t\n\t    /**\r\n\t     * Truncate not needed zeros\r\n\t     *\r\n\t     * @param {string} roundedInputValue\r\n\t     * @param {int} temporaryDecimalPlacesOverride\r\n\t     * @returns {void|XML|string|*}\r\n\t     */\n\t    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n\t        var regex = void 0;\n\t        switch (temporaryDecimalPlacesOverride) {\n\t            case 0:\n\t                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n\t                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            case 1:\n\t                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n\t                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            default:\n\t                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n\t                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n\t        }\n\t\n\t        // If there are no decimal places, we don't need a decimal point at the end\n\t        roundedInputValue = roundedInputValue.replace(regex, '$1');\n\t        if (temporaryDecimalPlacesOverride === 0) {\n\t            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n\t        }\n\t\n\t        return roundedInputValue;\n\t    }\n\t\n\t    /**\r\n\t     * Round the input value using the rounding method defined in the settings.\r\n\t     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n\t     *\r\n\t     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n\t     *\r\n\t     * @param {string} inputValue\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function roundValue(inputValue, settings) {\n\t        inputValue = inputValue === '' ? '0' : inputValue.toString();\n\t        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n\t            switch (settings.roundingMethod) {\n\t                case 'N05':\n\t                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n\t                    break;\n\t                case 'U05':\n\t                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n\t                    break;\n\t                default:\n\t                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n\t            }\n\t\n\t            var result = void 0;\n\t            if (!contains(inputValue, '.')) {\n\t                result = inputValue + '.00';\n\t            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n\t                result = inputValue + '0';\n\t            } else {\n\t                result = inputValue;\n\t            }\n\t            return result;\n\t        }\n\t\n\t        var ivRounded = '';\n\t        var i = 0;\n\t        var nSign = '';\n\t        var temporaryDecimalPlacesOverride = void 0;\n\t\n\t        // sets the truncate zero method\n\t        if (settings.allowDecimalPadding) {\n\t            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n\t        } else {\n\t            temporaryDecimalPlacesOverride = 0;\n\t        }\n\t\n\t        // Checks if the inputValue (input Value) is a negative value\n\t        if (isNegativeStrict(inputValue)) {\n\t            nSign = '-';\n\t\n\t            // Removes the negative sign that will be added back later if required\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n\t        if (!inputValue.match(/^\\d/)) {\n\t            inputValue = '0' + inputValue;\n\t        }\n\t\n\t        // Determines if the value is equal to zero. If it is, remove the negative sign\n\t        if (Number(inputValue) === 0) {\n\t            nSign = '';\n\t        }\n\t\n\t        // Trims leading zero's as needed\n\t        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n\t            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n\t        }\n\t\n\t        var dPos = inputValue.lastIndexOf('.');\n\t        var inputValueHasADot = dPos === -1;\n\t\n\t        // Virtual decimal position\n\t        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\t\n\t        // Checks decimal places to determine if rounding is required :\n\t        // Check if no rounding is required\n\t        var cDec = inputValue.length - 1 - vdPos;\n\t\n\t        if (cDec <= settings.decimalPlacesOverride) {\n\t            // Check if we need to pad with zeros\n\t            ivRounded = inputValue;\n\t            if (cDec < temporaryDecimalPlacesOverride) {\n\t                if (inputValueHasADot) {\n\t                    ivRounded += settings.decimalCharacter;\n\t                }\n\t\n\t                var zeros = '000000';\n\t                while (cDec < temporaryDecimalPlacesOverride) {\n\t                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n\t                    ivRounded += zeros;\n\t                    cDec += zeros.length;\n\t                }\n\t            } else if (cDec > temporaryDecimalPlacesOverride) {\n\t                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n\t            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n\t                ivRounded = ivRounded.replace(/\\.$/, '');\n\t            }\n\t\n\t            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t        }\n\t\n\t        // Rounded length of the string after rounding\n\t        var rLength = void 0;\n\t        if (inputValueHasADot) {\n\t            rLength = settings.decimalPlacesOverride - 1;\n\t        } else {\n\t            rLength = settings.decimalPlacesOverride + dPos;\n\t        }\n\t\n\t        var tRound = Number(inputValue.charAt(rLength + 1));\n\t        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n\t        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\t\n\t        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n\t        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n\t        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n\t        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n\t        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n\t        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n\t        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n\t        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n\t        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n\t        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n\t        tRound > 0 && settings.roundingMethod === 'U') {\n\t            // Round up away from zero\n\t            // Round up the last digit if required, and continue until no more 9's are found\n\t            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n\t                if (ivArray[i] !== '.') {\n\t                    ivArray[i] = +ivArray[i] + 1;\n\t                    if (ivArray[i] < 10) {\n\t                        break;\n\t                    }\n\t\n\t                    if (i > 0) {\n\t                        ivArray[i] = '0';\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Reconstruct the string, converting any 10's to 0's\n\t        ivArray = ivArray.slice(0, rLength + 1);\n\t\n\t        // Return the rounded value\n\t        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\t\n\t        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t    }\n\t\n\t    /**\r\n\t     * Truncates the decimal part of a number.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} isPaste\r\n\t     * @returns {*}\r\n\t     */\n\t    function truncateDecimal(s, settings, isPaste) {\n\t        s = isPaste ? roundValue(s, settings) : s;\n\t\n\t        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n\t            var _s$split3 = s.split(settings.decimalCharacter),\n\t                _s$split4 = _slicedToArray(_s$split3, 2),\n\t                integerPart = _s$split4[0],\n\t                decimalPart = _s$split4[1];\n\t\n\t            // truncate decimal part to satisfying length since we would round it anyway\n\t\n\t\n\t            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n\t                if (settings.decimalPlacesOverride > 0) {\n\t                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n\t                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n\t                } else {\n\t                    s = integerPart;\n\t                }\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n\t     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n\t     *\r\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n\t     *\r\n\t     * @param {number|string} n A numeric value.\r\n\t     * @returns {{}}\r\n\t     */\n\t    function parseStr(n) {\n\t        var x = {}; // A Big number instance.\n\t        var e = void 0;\n\t        var i = void 0;\n\t        var nL = void 0;\n\t        var j = void 0;\n\t\n\t        // Minus zero?\n\t        if (n === 0 && 1 / n < 0) {\n\t            n = '-0';\n\t        }\n\t\n\t        // Determine sign. 1 positive, -1 negative\n\t        n = n.toString();\n\t        if (isNegativeStrict(n)) {\n\t            n = n.slice(1);\n\t            x.s = -1;\n\t        } else {\n\t            x.s = 1;\n\t        }\n\t\n\t        // Decimal point?\n\t        e = n.indexOf('.');\n\t        if (e > -1) {\n\t            n = n.replace('.', '');\n\t        }\n\t\n\t        // length of string if no decimal character\n\t        if (e < 0) {\n\t            // Integer\n\t            e = n.length;\n\t        }\n\t\n\t        // Determine leading zeros\n\t        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n\t        nL = n.length;\n\t        if (i === nL) {\n\t            // Zero\n\t            x.e = 0;\n\t            x.c = [0];\n\t        } else {\n\t            // Determine trailing zeros\n\t            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n\t                nL -= 1;\n\t            }\n\t            nL -= 1;\n\t\n\t            // Decimal location\n\t            x.e = e - i - 1;\n\t            x.c = [];\n\t\n\t            // Convert string to array of digits without leading/trailing zeros\n\t            for (e = 0; i <= nL; i += 1) {\n\t                x.c[e] = +n.charAt(i);\n\t                e += 1;\n\t            }\n\t        }\n\t\n\t        return x;\n\t    }\n\t\n\t    /**\r\n\t     * Function to test if the input value falls with the Min / Max settings.\r\n\t     * This uses the parsed strings for the above parseStr function.\r\n\t     *\r\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n\t     *\r\n\t     * @param {object} y Big number instance\r\n\t     * @param {object} x Big number instance\r\n\t     * @returns {*}\r\n\t     */\n\t    function testMinMax(y, x) {\n\t        var xc = x.c;\n\t        var yc = y.c;\n\t        var i = x.s;\n\t        var j = y.s;\n\t        var k = x.e;\n\t        var l = y.e;\n\t\n\t        // Either zero?\n\t        if (!xc[0] || !yc[0]) {\n\t            var _result = void 0;\n\t            if (!xc[0]) {\n\t                _result = !yc[0] ? 0 : -j;\n\t            } else {\n\t                _result = i;\n\t            }\n\t            return _result;\n\t        }\n\t\n\t        // Signs differ?\n\t        if (i !== j) {\n\t            return i;\n\t        }\n\t        var xNeg = i < 0;\n\t\n\t        // Compare exponents\n\t        if (k !== l) {\n\t            return k > l ^ xNeg ? 1 : -1;\n\t        }\n\t        i = -1;\n\t        k = xc.length;\n\t        l = yc.length;\n\t        j = k < l ? k : l;\n\t\n\t        // Compare digit by digit\n\t        for (i += 1; i < j; i += 1) {\n\t            if (xc[i] !== yc[i]) {\n\t                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n\t            }\n\t        }\n\t\n\t        // Compare lengths\n\t        var result = void 0;\n\t        if (k === l) {\n\t            result = 0;\n\t        } else {\n\t            result = k > l ^ xNeg ? 1 : -1;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Check that the number satisfy the format conditions\r\n\t     * and lays between settings.minimumValue and settings.maximumValue\r\n\t     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function checkIfInRangeWithOverrideOption(s, settings) {\n\t        s = s.toString();\n\t        s = s.replace(',', '.');\n\t        var minParse = parseStr(settings.minimumValue);\n\t        var maxParse = parseStr(settings.maximumValue);\n\t        var valParse = parseStr(s);\n\t\n\t        var result = void 0;\n\t        switch (settings.overrideMinMaxLimits) {\n\t            case 'floor':\n\t                result = [testMinMax(minParse, valParse) > -1, true];\n\t                break;\n\t            case 'ceiling':\n\t                result = [true, testMinMax(maxParse, valParse) < 1];\n\t                break;\n\t            case 'ignore':\n\t                result = [true, true];\n\t                break;\n\t            default:\n\t                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Thanks to Anthony & Evan C\r\n\t     *\r\n\t     * @param {Element|string} element\r\n\t     * @returns {*|jQuery|HTMLElement}\r\n\t     */\n\t    function getCurrentElement(element) {\n\t        /*\r\n\t         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n\t         * for jQuery to be able to parse the selector correctly.\r\n\t         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n\t         */\n\t        if (isString(element)) {\n\t            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n\t            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n\t        }\n\t\n\t        return $(element);\n\t    }\n\t\n\t    /**\r\n\t     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} update\r\n\t     * @returns {*}\r\n\t     */\n\t    function getAutoNumericHolder($this, settings) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        var data = $this.data('autoNumeric');\n\t        if (!data) {\n\t            data = {};\n\t            $this.data('autoNumeric', data);\n\t        }\n\t\n\t        var holder = data.holder;\n\t        if (update || isUndefined(holder) && settings) {\n\t            holder = new AutoNumericHolder($this.get(0), settings);\n\t            data.holder = holder;\n\t        }\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\r\n\t     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n\t     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function keepAnOriginalSettingsCopy(settings) {\n\t        //TODO Rename the old option names to the new ones\n\t        settings.oDec = settings.decimalPlacesOverride;\n\t        settings.oPad = settings.allowDecimalPadding;\n\t        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n\t        settings.oSep = settings.digitGroupSeparator;\n\t        settings.oSign = settings.currencySymbol;\n\t        settings.oSuffix = settings.suffixText;\n\t    }\n\t\n\t    /**\r\n\t     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n\t     * This is taken from Quirksmode.\r\n\t     *\r\n\t     * @param {string} name\r\n\t     * @returns {*}\r\n\t     */\n\t    function readCookie(name) {\n\t        var nameEQ = name + '=';\n\t        var ca = document.cookie.split(';');\n\t        var c = '';\n\t        for (var i = 0; i < ca.length; i += 1) {\n\t            c = ca[i];\n\t            while (c.charAt(0) === ' ') {\n\t                c = c.substring(1, c.length);\n\t            }\n\t            if (c.indexOf(nameEQ) === 0) {\n\t                return c.substring(nameEQ.length, c.length);\n\t            }\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\r\n\t     * Test if sessionStorage is supported.\r\n\t     * This is taken from Modernizr.\r\n\t     *\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function storageTest() {\n\t        var mod = 'modernizr';\n\t        try {\n\t            sessionStorage.setItem(mod, mod);\n\t            sessionStorage.removeItem(mod);\n\t            return true;\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n\t     *\r\n\t     * @param {string} value\r\n\t     * @param {object} settings\r\n\t     * @returns {string}\r\n\t     */\n\t    function cleanLeadingTrailingZeros(value, settings) {\n\t        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n\t        if (value === '') {\n\t            return '';\n\t        }\n\t\n\t        // Return '0' if the value is zero\n\t        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n\t            return '0';\n\t        }\n\t\n\t        if (settings.leadingZero !== 'keep') {\n\t            // Trim leading zero's - leaves one zero to the left of the decimal point\n\t            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\t\n\t            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n\t            if (contains(value, '.')) {\n\t                // Trims trailing zeros after the decimal point\n\t                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n\t            }\n\t        }\n\t        // Strips trailing decimal point\n\t        value = value.replace(/\\.$/, '');\n\t\n\t        return value;\n\t    }\n\t\n\t    /**\r\n\t     * Remove the trailing zeros in the decimal part of a number.\r\n\t     *\r\n\t     * @param {string} numericString\r\n\t     * @returns {*}\r\n\t     */\n\t    function trimPaddedZerosFromDecimalPlaces(numericString) {\n\t        var _numericString$split = numericString.split('.'),\n\t            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n\t            integerPart = _numericString$split2[0],\n\t            decimalPart = _numericString$split2[1];\n\t\n\t        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n\t            return integerPart;\n\t        }\n\t\n\t        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\t\n\t        var result = void 0;\n\t        if (trimmedDecimalPart === '') {\n\t            result = integerPart;\n\t        } else {\n\t            result = integerPart + '.' + trimmedDecimalPart;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n\t     *\r\n\t     * @param {Element|EventTarget} element\r\n\t     * @param {object} settings\r\n\t     * @param {string} action\r\n\t     * @returns {*}\r\n\t     */\n\t    function saveValueToPersistentStorage(element, settings, action) {\n\t        if (settings.saveValueToSessionStorage) {\n\t            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n\t            var date = void 0;\n\t            var expires = void 0;\n\t\n\t            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n\t            if (storageTest() === false) {\n\t                switch (action) {\n\t                    case 'set':\n\t                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n\t                        break;\n\t                    case 'wipe':\n\t                        date = new Date();\n\t                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n\t                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n\t                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n\t                        break;\n\t                    case 'get':\n\t                        return readCookie(storedName);\n\t                }\n\t            } else {\n\t                switch (action) {\n\t                    case 'set':\n\t                        sessionStorage.setItem(storedName, settings.rawValue);\n\t                        break;\n\t                    case 'wipe':\n\t                        sessionStorage.removeItem(storedName);\n\t                        break;\n\t                    case 'get':\n\t                        return sessionStorage.getItem(storedName);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Holder object for field properties\r\n\t     */\n\t\n\t    var AutoNumericHolder = function () {\n\t        /**\r\n\t         * Class constructor\r\n\t         *\r\n\t         * @param {HTMLElement} that - A reference to the current DOM element\r\n\t         * @param {object} settings\r\n\t         */\n\t        function AutoNumericHolder(that, settings) {\n\t            _classCallCheck(this, AutoNumericHolder);\n\t\n\t            this.settings = settings;\n\t            this.that = that;\n\t            this.$that = $(that);\n\t            this.formatted = false;\n\t            this.settingsClone = settings;\n\t            this.value = that.value;\n\t        }\n\t\n\t        /**\r\n\t         * Update the value and the selection values inside the AutoNumericHolder object.\r\n\t         * This keeps tracks of the input value, as well as the current selection.\r\n\t         * This also resets the 'processed' and 'formatted' state.\r\n\t         *\r\n\t         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n\t         *        this function is called on each event handler.\r\n\t         *\r\n\t         * @private\r\n\t         */\n\t\n\t\n\t        _createClass(AutoNumericHolder, [{\n\t            key: '_updateAutoNumericHolderProperties',\n\t            value: function _updateAutoNumericHolderProperties() {\n\t                this.value = this.that.value;\n\t                this.selection = getElementSelection(this.that);\n\t                this.processed = false;\n\t                this.formatted = false;\n\t            }\n\t\n\t            /**\r\n\t             * Update the keycode of the key that triggered the given event.\r\n\t             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n\t             *\r\n\t             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n\t             * e.key describe the key name used to trigger the event.\r\n\t             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n\t             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n\t             * The key list is described here\r\n\t             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_updateAutoNumericHolderEventKeycode',\n\t            value: function _updateAutoNumericHolderEventKeycode(e) {\n\t                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n\t                this.eventKeyCode = keyCodeNumber(e);\n\t            }\n\t\n\t            /**\r\n\t             * Set the text selection inside the input with the given start and end position.\r\n\t             *\r\n\t             * @param {int} start\r\n\t             * @param {int} end\r\n\t             * @param {undefined|boolean} setReal\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_setSelection',\n\t            value: function _setSelection(start, end, setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean)\n\t                start = Math.max(start, 0);\n\t                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n\t                this.selection = {\n\t                    start: start,\n\t                    end: end,\n\t                    length: end - start\n\t                };\n\t\n\t                if (isUndefined(setReal) || setReal) {\n\t                    setElementSelection(this.that, start, end);\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Set the caret position inside the input at the given position.\r\n\t             *\r\n\t             * @param {int} pos\r\n\t             * @param {undefined|boolean} setReal\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_setCaretPosition',\n\t            value: function _setCaretPosition(pos, setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean)\n\t                this._setSelection(pos, pos, setReal);\n\t            }\n\t\n\t            /**\r\n\t             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n\t             * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n\t             *\r\n\t             * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_getLeftAndRightPartAroundTheSelection',\n\t            value: function _getLeftAndRightPartAroundTheSelection() {\n\t                var value = this.value;\n\t                var left = value.substring(0, this.selection.start);\n\t                var right = value.substring(this.selection.end, value.length);\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n\t             * Those parts are unformatted (stripped) of any non-numbers characters.\r\n\t             *\r\n\t             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n\t            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n\t                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n\t                    left = _getLeftAndRightPartA2[0],\n\t                    right = _getLeftAndRightPartA2[1];\n\t\n\t                if (left === '' && right === '') {\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\t                var stripZeros = true;\n\t                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n\t                    stripZeros = false;\n\t                }\n\t                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n\t                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\t\n\t                if (settingsClone.trailingNegative && !isNegative(left)) {\n\t                    left = '-' + left;\n\t                    right = right === '-' ? '' : right;\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Strip parts from excess characters and leading zeros.\r\n\t             *\r\n\t             * @param {string} left\r\n\t             * @param {string} right\r\n\t             * @returns {[*,*]}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_normalizeParts',\n\t            value: function _normalizeParts(left, right) {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\t                var stripZeros = true;\n\t                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n\t                    stripZeros = false;\n\t                }\n\t                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\t\n\t                // If right is not empty and first character is not decimalCharacter\n\t                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\t\n\t                // Prevents multiple leading zeros from being entered\n\t                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n\t                    left = left.substring(0, left.length - 1);\n\t                }\n\t\n\t                if (settingsClone.trailingNegative && !isNegative(left)) {\n\t                    left = '-' + left;\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t\n\t                // Insert zero if has leading dot\n\t                this.newValue = left + right;\n\t                if (settingsClone.decimalCharacter) {\n\t                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n\t                    if (m) {\n\t                        left = left.replace(m[1], m[1] + '0');\n\t                        this.newValue = left + right;\n\t                    }\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n\t             *\r\n\t             * @param {string} left\r\n\t             * @param {string} right\r\n\t             * @param {boolean} isPaste\r\n\t             * @returns {boolean}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_setValueParts',\n\t            value: function _setValueParts(left, right) {\n\t                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t                var settingsClone = this.settingsClone;\n\t                var parts = this._normalizeParts(left, right);\n\t\n\t                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n\t                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n\t                    minTest = _checkIfInRangeWithOv2[0],\n\t                    maxTest = _checkIfInRangeWithOv2[1];\n\t\n\t                var position = parts[0].length;\n\t                this.newValue = parts.join('');\n\t\n\t                if (minTest && maxTest) {\n\t                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n\t                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n\t                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n\t                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n\t                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n\t                    } else {\n\t                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n\t                    }\n\t\n\t                    if (position > this.newValue.length) {\n\t                        position = this.newValue.length;\n\t                    }\n\t\n\t                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n\t                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n\t                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n\t                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n\t                            position = 1;\n\t                        } else {\n\t                            position = 0;\n\t                        }\n\t                    }\n\t\n\t                    this.value = this.newValue;\n\t                    this._setCaretPosition(position, false);\n\t\n\t                    return true;\n\t                }\n\t\n\t                if (!minTest) {\n\t                    this.$that.trigger('autoNumeric:minExceeded');\n\t                } else if (!maxTest) {\n\t                    this.$that.trigger('autoNumeric:maxExceeded');\n\t                }\n\t\n\t                return false;\n\t            }\n\t\n\t            /**\r\n\t             * Helper function for `_expandSelectionOnSign()`.\r\n\t             *\r\n\t             * @returns {*} Sign position of a formatted value\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_getSignPosition',\n\t            value: function _getSignPosition() {\n\t                var settingsClone = this.settingsClone;\n\t                var currencySymbol = settingsClone.currencySymbol;\n\t                var that = this.that;\n\t\n\t                if (currencySymbol) {\n\t                    var currencySymbolLen = currencySymbol.length;\n\t                    if (settingsClone.currencySymbolPlacement === 'p') {\n\t                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n\t                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n\t                    }\n\t                    var valueLen = that.value.length;\n\t                    return [valueLen - currencySymbolLen, valueLen];\n\t                }\n\t\n\t                return [1000, -1];\n\t            }\n\t\n\t            /**\r\n\t             * Expands selection to cover whole sign\r\n\t             * Prevents partial deletion/copying/overwriting of a sign\r\n\t             *\r\n\t             * @param {undefined|boolean} setReal\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_expandSelectionOnSign',\n\t            value: function _expandSelectionOnSign(setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean only)\n\t                //TODO Use array destructuring here to set signPosition to more explicit variables\n\t                var signPosition = this._getSignPosition();\n\t                var selection = this.selection;\n\t\n\t                // If selection catches something except sign and catches only space from sign\n\t                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n\t                    // Then select without empty space\n\t                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n\t                        if (selection.start < signPosition[0]) {\n\t                            this._setSelection(selection.start, signPosition[0], setReal);\n\t                        } else {\n\t                            this._setSelection(signPosition[1], selection.end, setReal);\n\t                        }\n\t                    } else {\n\t                        // Else select with whole sign\n\t                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n\t                    }\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Try to strip pasted value to digits\r\n\t             */\n\t\n\t        }, {\n\t            key: '_checkPaste',\n\t            value: function _checkPaste() {\n\t                if (!isUndefined(this.valuePartsBeforePaste)) {\n\t                    var oldParts = this.valuePartsBeforePaste;\n\t\n\t                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n\t                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n\t                        left = _getLeftAndRightPartA4[0],\n\t                        right = _getLeftAndRightPartA4[1];\n\t\n\t                    // Try to strip the pasted value first\n\t\n\t\n\t                    delete this.valuePartsBeforePaste;\n\t\n\t                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n\t                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n\t                        this.value = oldParts.join('');\n\t                        this._setCaretPosition(oldParts[0].length, false);\n\t                    }\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Process pasting, cursor moving and skipping of not interesting keys.\r\n\t             * If this function returns TRUE, then further processing is not performed.\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @returns {boolean}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_skipAlways',\n\t            value: function _skipAlways(e) {\n\t                // Catch the ctrl up on ctrl-v\n\t                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n\t                    //TODO Move this test inside the `onKeyup` handler\n\t                    this._checkPaste();\n\t                    return false;\n\t                }\n\t\n\t                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n\t                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n\t                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n\t                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n\t                    return true;\n\t                }\n\t\n\t                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n\t                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n\t                    if (this.settings.selectNumberOnly) {\n\t                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n\t                        e.preventDefault();\n\t                        var valueLen = this.that.value.length;\n\t                        var currencySymbolLen = this.settings.currencySymbol.length;\n\t                        var negLen = !isNegative(this.that.value) ? 0 : 1;\n\t                        var suffixTextLen = this.settings.suffixText.length;\n\t                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n\t                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\t\n\t                        var start = void 0;\n\t                        if (currencySymbolPlacement === 's') {\n\t                            start = 0;\n\t                        } else {\n\t                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n\t                        }\n\t\n\t                        var end = void 0;\n\t                        if (currencySymbolPlacement === 'p') {\n\t                            end = valueLen - suffixTextLen;\n\t                        } else {\n\t                            switch (negativePositiveSignPlacement) {\n\t                                case 'l':\n\t                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n\t                                    break;\n\t                                case 'r':\n\t                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n\t                                    break;\n\t                                default:\n\t                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n\t                            }\n\t                        }\n\t\n\t                        setElementSelection(this.that, start, end);\n\t                    }\n\t\n\t                    return true;\n\t                }\n\t\n\t                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n\t                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n\t                    if (e.type === 'keydown') {\n\t                        this._expandSelectionOnSign();\n\t                    }\n\t\n\t                    // Try to prevent wrong paste\n\t                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n\t                        if (e.type === 'keydown' || e.type === 'keypress') {\n\t                            if (isUndefined(this.valuePartsBeforePaste)) {\n\t                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n\t                            }\n\t                        } else {\n\t                            this._checkPaste();\n\t                        }\n\t                    }\n\t\n\t                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n\t                }\n\t\n\t                if (e.ctrlKey || e.metaKey) {\n\t                    return true;\n\t                }\n\t\n\t                // Jump over thousand separator\n\t                //TODO Move this test inside the `onKeydown` handler\n\t                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n\t                    if (e.type === 'keydown' && !e.shiftKey) {\n\t                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n\t                            this._setCaretPosition(this.selection.start - 1);\n\t                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n\t                            this._setCaretPosition(this.selection.start + 1);\n\t                        }\n\t                    }\n\t                    return true;\n\t                }\n\t\n\t                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n\t            }\n\t\n\t            /**\r\n\t             * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n\t             *\r\n\t             * @param {string} left The part on the left of the caret or selection\r\n\t             * @param {string} right The part on the right of the caret or selection\r\n\t             * @returns {[string, string]}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterDeletionIfTrailingNegativeSign',\n\t            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n\t                var _ref2 = _slicedToArray(_ref, 2),\n\t                    left = _ref2[0],\n\t                    right = _ref2[1];\n\t\n\t                var settingsClone = this.settingsClone;\n\t                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n\t                        if (this.value.charAt(this.selection.start - 1) === '-') {\n\t                            left = left.substring(1);\n\t                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n\t                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n\t                            left = left.substring(1);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n\t                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        if (left[0] === '-') {\n\t                            right = right.substring(1);\n\t                        }\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n\t                            left = left.substring(1);\n\t                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        }\n\t                        right = right.substring(1);\n\t                    }\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Process the deletion of characters.\r\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterDeletion',\n\t            value: function _processCharacterDeletion() {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var left = void 0;\n\t                var right = void 0;\n\t\n\t                if (!this.selection.length) {\n\t                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\t\n\t                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\t\n\t                    left = _getUnformattedLeftAn2[0];\n\t                    right = _getUnformattedLeftAn2[1];\n\t\n\t                    if (left === '' && right === '') {\n\t                        settingsClone.throwInput = false;\n\t                    }\n\t\n\t                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n\t                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\t\n\t\n\t                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\t\n\t                        left = _processCharacterDele2[0];\n\t                        right = _processCharacterDele2[1];\n\t                    } else {\n\t                        if (this.eventKeyCode === keyCode.Backspace) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                    }\n\t                } else {\n\t                    this._expandSelectionOnSign(false);\n\t\n\t                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\t\n\t                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\t\n\t                    left = _getUnformattedLeftAn4[0];\n\t                    right = _getUnformattedLeftAn4[1];\n\t                }\n\t\n\t                this._setValueParts(left, right);\n\t            }\n\t\n\t            /**\r\n\t             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n\t             * Returns TRUE if the keycode is allowed.\r\n\t             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n\t             *\r\n\t             * @param {Event|string} eventOrChar The event object, or the character entered (from an android device)\r\n\t             * @returns {boolean}\r\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterInsertion',\n\t            value: function _processCharacterInsertion(eventOrChar) {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n\t                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n\t                    left = _getUnformattedLeftAn6[0],\n\t                    right = _getUnformattedLeftAn6[1];\n\t\n\t                var eventCharacter = void 0;\n\t                if (isString(eventOrChar)) {\n\t                    // Android browsers\n\t                    eventCharacter = eventOrChar;\n\t                } else {\n\t                    // Normal browsers\n\t                    settingsClone.throwInput = true;\n\t\n\t                    // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n\t                    eventCharacter = character(eventOrChar);\n\t                }\n\t\n\t                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n\t                // Do not allow decimal character if no decimal part allowed\n\t                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n\t                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Do not allow decimal character before negativeSignCharacter character\n\t                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Do not allow decimal character if other decimal character present\n\t                    if (contains(left, settingsClone.decimalCharacter)) {\n\t                        return true;\n\t                    }\n\t\n\t                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n\t                        return true;\n\t                    }\n\t\n\t                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n\t                        right = right.substr(1);\n\t                    }\n\t\n\t                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // Prevent minus if not allowed\n\t                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n\t                    if (!settingsClone) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Caret is always after minus\n\t                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n\t                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                            left = settingsClone.negativeSignCharacter;\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t\n\t                        // Change number sign, remove part if should\n\t                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1, left.length);\n\t                        } else {\n\t                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n\t                        }\n\t                    } else {\n\t                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                            left = settingsClone.negativeSignCharacter;\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t\n\t                        // Change number sign, remove part if should\n\t                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n\t                            left = left.substring(1, left.length);\n\t                        } else {\n\t                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n\t                        }\n\t                    }\n\t\n\t                    this._setValueParts(left, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // If the user tries to insert digit before minus sign\n\t                var eventNumber = Number(eventCharacter);\n\t                if (eventNumber >= 0 && eventNumber <= 9) {\n\t                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                        left = settingsClone.negativeSignCharacter;\n\t                        right = right.substring(1, right.length);\n\t                    }\n\t\n\t                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n\t                        left = settingsClone.negativeSignCharacter + left;\n\t                    }\n\t\n\t                    this._setValueParts(left + eventCharacter, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // Prevent any other character\n\t                settingsClone.throwInput = false;\n\t\n\t                return false;\n\t            }\n\t\n\t            /**\r\n\t             * Formatting of just processed value while keeping the cursor position\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_formatValue',\n\t            value: function _formatValue(e) {\n\t                var _this = this;\n\t\n\t                var settingsClone = this.settingsClone;\n\t                var leftLength = this.value;\n\t\n\t                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n\t                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n\t                    left = _getUnformattedLeftAn8[0];\n\t\n\t                // No grouping separator and no currency sign\n\t\n\t\n\t                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n\t                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n\t                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n\t                        subParts = _leftLength$split2[0];\n\t\n\t                    var nSign = '';\n\t                    if (isNegative(subParts)) {\n\t                        nSign = '-';\n\t                        subParts = subParts.replace('-', '');\n\t                        left = left.replace('-', '');\n\t                    }\n\t\n\t                    // Strip leading zero on positive value if needed\n\t                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n\t                        left = left.slice(1);\n\t                    }\n\t\n\t                    // Strip leading zero on negative value if needed\n\t                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n\t                        left = left.slice(1);\n\t                    }\n\t\n\t                    left = nSign + left;\n\t                }\n\t\n\t                var value = addGroupSeparators(this.value, this.settingsClone);\n\t                var position = value.length;\n\t                if (value) {\n\t                    // Prepare regexp which searches for cursor position from unformatted left part\n\t                    var leftAr = left.split('');\n\t\n\t                    // Fixes caret position with trailing minus sign\n\t                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n\t                        leftAr.shift();\n\t\n\t                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n\t                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n\t                                leftAr.push('-');\n\t                                settingsClone.caretFix = e.type === 'keydown';\n\t                            }\n\t\n\t                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n\t                                leftAr.push('-');\n\t                                settingsClone.caretFix = e.type === 'keydown';\n\t                            }\n\t\n\t                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n\t                                (function () {\n\t                                    var signParts = settingsClone.currencySymbol.split('');\n\t                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n\t                                    var escapedParts = [];\n\t                                    $.each(signParts, function (i, miniParts) {\n\t                                        miniParts = signParts[i];\n\t                                        if (isInArray(miniParts, escapeChr)) {\n\t                                            escapedParts.push('\\\\' + miniParts);\n\t                                        } else {\n\t                                            escapedParts.push(miniParts);\n\t                                        }\n\t                                    });\n\t\n\t                                    if (_this.eventKeyCode === keyCode.Backspace) {\n\t                                        escapedParts.push('-');\n\t                                    }\n\t\n\t                                    // Pushing the escaped sign\n\t                                    leftAr.push(escapedParts.join(''));\n\t                                    settingsClone.caretFix = e.type === 'keydown';\n\t                                })();\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    for (var i = 0; i < leftAr.length; i++) {\n\t                        if (!leftAr[i].match('\\\\d')) {\n\t                            leftAr[i] = '\\\\' + leftAr[i];\n\t                        }\n\t                    }\n\t\n\t                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\t\n\t                    // Search cursor position in formatted value\n\t                    var newLeft = value.match(leftReg);\n\t                    if (newLeft) {\n\t                        position = newLeft[0].length;\n\t\n\t                        // If the positive sign is shown, calculate the caret position accordingly\n\t                        if (settingsClone.showPositiveSign) {\n\t                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n\t                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n\t                            }\n\t\n\t                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n\t                                position = settingsClone.currencySymbol.length + 1;\n\t                            }\n\t                        }\n\t\n\t                        // If we are just before the sign which is in prefix position\n\t                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n\t                            // Place caret after prefix sign\n\t                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n\t                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n\t                        }\n\t                    } else {\n\t                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n\t                            // If we could not find a place for cursor and have a sign as a suffix\n\t                            // Place caret before suffix currency sign\n\t                            position -= settingsClone.currencySymbol.length;\n\t                        }\n\t\n\t                        if (settingsClone.suffixText) {\n\t                            // If we could not find a place for cursor and have a suffix\n\t                            // Place caret before suffix\n\t                            position -= settingsClone.suffixText.length;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                // Only update the value if it has changed. This prevents modifying the selection, if any.\n\t                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n\t                    this.that.value = value;\n\t                    this._setCaretPosition(position);\n\t                }\n\t\n\t                if (settingsClone.androidSelectionStart !== null) {\n\t                    // If an Android browser is detected, fix the caret position\n\t                    // Unfortunately this does not fix all android browsers, only Android Chrome currently.\n\t                    // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\n\t                    this._setCaretPosition(settingsClone.androidSelectionStart);\n\t                }\n\t\n\t                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n\t            }\n\t        }]);\n\t\n\t        return AutoNumericHolder;\n\t    }();\n\t\n\t    /**\r\n\t     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n\t     *\r\n\t     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n\t     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n\t     *\r\n\t     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n\t     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n\t     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n\t     *\r\n\t     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n\t     * @param {HTMLElement} that - A reference to the current DOM element\r\n\t     * @returns {*}\r\n\t     * @private\r\n\t     */\n\t\n\t\n\t    function _getStringOrArray() {\n\t        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\t        var that = arguments[1];\n\t\n\t        var $this = getCurrentElement(that);\n\t        var formIndex = $('form').index($this);\n\t        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n\t        var aiIndex = [];\n\t\n\t        // all input index\n\t        var scIndex = [];\n\t\n\t        // successful control index\n\t        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\t\n\t        // from jQuery serialize method\n\t        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\t        // from jQuery serialize method\n\t        var rCheckableType = /^(?:checkbox|radio)$/i;\n\t        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\t\n\t        var count = 0;\n\t\n\t        // index of successful elements\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n\t                scIndex.push(count);\n\t                count++;\n\t            } else {\n\t                scIndex.push(-1);\n\t            }\n\t        });\n\t\n\t        // index of all inputs tags except checkbox\n\t        count = 0;\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n\t                aiIndex.push(count);\n\t                count++;\n\t            } else {\n\t                aiIndex.push(-1);\n\t                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n\t                    count++;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (getArrayBehavior) {\n\t            var formFields = $this.serializeArray();\n\t\n\t            $.each(formFields, function (i, field) {\n\t                var scElement = scIndex.indexOf(i);\n\t\n\t                if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                    var settings = testInput.data('autoNumeric');\n\t\n\t                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                        field.value = testInput.autoNumeric('getLocalized').toString();\n\t                    }\n\t                }\n\t            });\n\t\n\t            return formFields;\n\t        } else {\n\t            var _ret2 = function () {\n\t                // getString() behavior\n\t                var formFields = $this.serialize();\n\t                var formParts = formFields.split('&');\n\t\n\t                $.each(formParts, function (i) {\n\t                    var _formParts$i$split = formParts[i].split('='),\n\t                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n\t                        inputName = _formParts$i$split2[0],\n\t                        inputValue = _formParts$i$split2[1];\n\t\n\t                    var scElement = scIndex.indexOf(i);\n\t\n\t                    // If the current element is a valid element\n\t                    if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                        var settings = testInput.data('autoNumeric');\n\t\n\t                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                            if (inputValue !== null) {\n\t                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n\t                                formParts[i] = inputName + '=' + modifiedInputValue;\n\t                            }\n\t                        }\n\t                    }\n\t                });\n\t\n\t                return {\n\t                    v: formParts.join('&')\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'focusin' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onFocusInAndMouseEnter($this, holder, e) {\n\t        var settings = holder.settingsClone;\n\t\n\t        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n\t            settings.hasFocus = true;\n\t\n\t            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n\t                jQueryOriginalVal.call($this, toggleNegativeBracket(e.target.value, settings));\n\t            }\n\t\n\t            // clean the value to compare to rawValue\n\t            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n\t            result = convertToNumericString(result, settings);\n\t            result = cleanLeadingTrailingZeros(result, settings);\n\t            if (settings.trailingNegative) {\n\t                result = '-' + result;\n\t            }\n\t\n\t            var roundedValue = void 0;\n\t            if (settings.decimalPlacesShownOnFocus) {\n\t                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n\t                roundedValue = roundValue(settings.rawValue, settings);\n\t                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n\t            } else if (settings.scaleDivisor) {\n\t                settings.decimalPlacesOverride = Number(settings.oDec);\n\t                roundedValue = roundValue(settings.rawValue, settings);\n\t                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n\t            } else if (settings.noSeparatorOnFocus) {\n\t                settings.digitGroupSeparator = '';\n\t                settings.currencySymbol = '';\n\t                settings.suffixText = '';\n\t                roundedValue = roundValue(settings.rawValue, settings);\n\t                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\n\t            } else if (result !== settings.rawValue) {\n\t                // updates the rawValue\n\t                $this.autoNumeric('set', result);\n\t            }\n\t\n\t            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n\t            holder.valueOnFocus = e.target.value;\n\t            holder.lastVal = holder.valueOnFocus;\n\t            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n\t            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n\t                jQueryOriginalVal.call($this, onEmpty);\n\t                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n\t                    setElementSelection(e.target, 0, 0);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'keydown' events.\r\n\t     * The user just started pushing any key, hence one event is sent.\r\n\t     *\r\n\t     * Note :\r\n\t     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n\t     * - keydown\r\n\t     * - keypress\r\n\t     * - input\r\n\t     * - keyup\r\n\t     *\r\n\t     * ...when inputting a modifier key (ie. 'ctrl') :\r\n\t     * - keydown\r\n\t     * - keyup\r\n\t     *\r\n\t     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n\t     * - keydown\r\n\t     * - input\r\n\t     * - keyup\r\n\t     *\r\n\t     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n\t     * - keydown\r\n\t     * - keypress\r\n\t     * - keyup\r\n\t     *\r\n\t     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n\t     * - keydown\r\n\t     * - keypress\r\n\t     * - change\r\n\t     * - keyup\r\n\t     *\r\n\t     * When a paste is done, the following events are sent :\r\n\t     * - input (if paste is done with the mouse)\r\n\t     *\r\n\t     * - keydown (if paste is done with ctrl+v)\r\n\t     * - keydown\r\n\t     * - input\r\n\t     * - keyup\r\n\t     * - keyup\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onKeydown(holder, e) {\n\t        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n\t        holder._updateAutoNumericHolderEventKeycode(e);\n\t        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\t\n\t        if (holder.that.readOnly) {\n\t            holder.processed = true;\n\t\n\t            return;\n\t        }\n\t\n\t        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n\t        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n\t            triggerEvent('change', e.target);\n\t            holder.valueOnFocus = e.target.value;\n\t        }\n\t\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        if (holder._skipAlways(e)) {\n\t            holder.processed = true;\n\t\n\t            return;\n\t        }\n\t\n\t        // Check if the key is a delete/backspace key\n\t        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n\t            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n\t            holder.processed = true;\n\t            holder._formatValue(e);\n\t\n\t            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n\t            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                // Throw an input event when a character deletion is detected\n\t                triggerEvent('input', e.target);\n\t                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n\t            }\n\t\n\t            holder.lastVal = e.target.value;\n\t            holder.settingsClone.throwInput = true;\n\t\n\t            return;\n\t        }\n\t\n\t        holder.formatted = false; //TODO Is this line needed?\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'keypress' events.\r\n\t     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n\t     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onKeypress(holder, e) {\n\t        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n\t        var eventCharacter = character(e);\n\t\n\t        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n\t        if (eventCharacter === keyName.Insert) {\n\t            return;\n\t        }\n\t\n\t        var processed = holder.processed;\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        if (holder._skipAlways(e)) {\n\t            return;\n\t        }\n\t\n\t        if (processed) {\n\t            e.preventDefault();\n\t\n\t            return;\n\t        }\n\t\n\t        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n\t        if (isCharacterInsertionAllowed) {\n\t            holder._formatValue(e);\n\t            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                // Throws input event on adding a character\n\t                triggerEvent('input', e.target);\n\t                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n\t            } else {\n\t                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n\t                    var position = getElementSelection(e.target).start + 1;\n\t                    setElementSelection(e.target, position, position);\n\t                }\n\t                e.preventDefault();\n\t            }\n\t\n\t            holder.lastVal = e.target.value;\n\t            holder.settingsClone.throwInput = true;\n\t\n\t            return;\n\t        }\n\t\n\t        e.preventDefault();\n\t\n\t        holder.formatted = false;\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'input' events.\r\n\t     * added to support android devices with mobile chrome browsers and others\r\n\t     * Has the potential to replace the keypress event.\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onInput(holder, e) {\n\t        var value = e.target.value;\n\t\n\t        // Fix the caret position on keyup in the `_formatValue()` function\n\t        holder.settings.androidSelectionStart = null;\n\t\n\t        if (holder.eventKeyCode === keyCode.AndroidDefault) {\n\t            // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\n\t            if (value.length > holder.lastVal.length || value.length >= holder.lastVal.length - holder.selection.length) {\n\t                // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\n\t                holder.eventKeyCode = value.charCodeAt(holder.selection.start);\n\t\n\t                // Capture the actual character entered\n\t                var androidCharEntered = value.charAt(holder.selection.start);\n\t\n\t                // Check if the given character should be inserted, and if so, do insert it into the current element value\n\t                var isCharacterInsertionAllowed = holder._processCharacterInsertion(androidCharEntered);\n\t\n\t                if (isCharacterInsertionAllowed) {\n\t                    // Allowed character entered (number, decimal or plus/minus sign)\n\t                    holder._formatValue(e);\n\t\n\t                    // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\n\t                    //TODO Check if this is an Android bug or an autoNumeric one\n\t                    holder.settings.androidSelectionStart = holder.selection.start;\n\t\n\t                    var decimalCharacterPosition = e.target.value.indexOf(holder.settings.decimalCharacter);\n\t                    var hasDecimalCharacter = decimalCharacterPosition === -1;\n\t\n\t                    // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\n\t                    if (androidCharEntered === holder.settings.decimalCharacter || !hasDecimalCharacter && decimalCharacterPosition < holder.settings.androidSelectionStart) {\n\t                        holder.settings.androidSelectionStart = holder.selection.start + 1;\n\t                    }\n\t\n\t                    if (e.target.value.length > value.length) {\n\t                        // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\n\t                        setElementSelection(e.target, holder.settings.androidSelectionStart, holder.settings.androidSelectionStart);\n\t                    }\n\t\n\t                    holder.lastVal = e.target.value;\n\t\n\t                    return;\n\t                } else {\n\t                    // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\n\t                    e.target.value = holder.lastVal;\n\t                    setElementSelection(e.target, holder.selection.start, holder.selection.end);\n\t                    holder.settings.androidSelectionStart = holder.selection.start;\n\t                }\n\t\n\t                e.preventDefault(); //FIXME How does that affects the normal trigger of the input event?\n\t\n\t                holder.formatted = false;\n\t            } else {\n\t                // Character deleted\n\t                //TODO What about the `Delete` key?\n\t                holder.eventKeyCode = keyCode.Backspace;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'keyup' events.\r\n\t     * The user just released any key, hence one event is sent.\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {object} settings\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onKeyup(holder, settings, e) {\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        var skip = holder._skipAlways(e);\n\t        delete holder.valuePartsBeforePaste;\n\t        var isOnAndroid = holder.settingsClone.androidSelectionStart !== null;\n\t        if (skip && !isOnAndroid || e.target.value === '') {\n\t            return;\n\t        }\n\t\n\t        // Added to properly place the caret when only the currency sign is present\n\t        if (e.target.value === holder.settingsClone.currencySymbol) {\n\t            if (holder.settingsClone.currencySymbolPlacement === 's') {\n\t                setElementSelection(e.target, 0, 0);\n\t            } else {\n\t                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n\t            }\n\t        } else if (holder.eventKeyCode === keyCode.Tab) {\n\t            setElementSelection(e.target, 0, e.target.value.length);\n\t        }\n\t\n\t        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n\t            setElementSelection(e.target, 0, 0);\n\t        }\n\t\n\t        // Saves the extended decimal to preserve the data when navigating away from the page\n\t        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n\t            saveValueToPersistentStorage(e.target, settings, 'set');\n\t        }\n\t\n\t        if (!holder.formatted) {\n\t            holder._formatValue(e);\n\t        }\n\t\n\t        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n\t        if (e.target.value !== holder.initialValueOnKeydown) {\n\t            triggerEvent('autoNumeric:formatted', e.target);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'focusout' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onFocusOutAndMouseLeave($this, holder, e) {\n\t        if (!$this.is(':focus')) {\n\t            var value = e.target.value;\n\t            var origValue = value;\n\t            var settings = holder.settingsClone;\n\t            settings.hasFocus = false;\n\t\n\t            if (settings.saveValueToSessionStorage) {\n\t                saveValueToPersistentStorage(e.target, settings, 'set');\n\t            }\n\t\n\t            if (settings.noSeparatorOnFocus === true) {\n\t                settings.digitGroupSeparator = settings.oSep;\n\t                settings.currencySymbol = settings.oSign;\n\t                settings.suffixText = settings.oSuffix;\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus !== null) {\n\t                settings.decimalPlacesOverride = settings.oDec;\n\t                settings.allowDecimalPadding = settings.oPad;\n\t                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n\t            }\n\t\n\t            value = stripAllNonNumberCharacters(value, settings, true);\n\t\n\t            if (value !== '') {\n\t                if (settings.trailingNegative && !isNegative(value)) {\n\t                    value = '-' + value;\n\t                    settings.trailingNegative = false;\n\t                }\n\t\n\t                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n\t                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n\t                    minTest = _checkIfInRangeWithOv4[0],\n\t                    maxTest = _checkIfInRangeWithOv4[1];\n\t\n\t                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n\t                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n\t                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\t\n\t                    if (settings.scaleDivisor) {\n\t                        value = value / settings.scaleDivisor;\n\t                        value = value.toString();\n\t                    }\n\t\n\t                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? Number(settings.scaleDecimalPlaces) : settings.decimalPlacesOverride;\n\t                    value = roundValue(value, settings);\n\t                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n\t                } else {\n\t                    if (!minTest) {\n\t                        $this.trigger('autoNumeric:minExceeded');\n\t                    }\n\t                    if (!maxTest) {\n\t                        $this.trigger('autoNumeric:maxExceeded');\n\t                    }\n\t\n\t                    value = settings.rawValue;\n\t                }\n\t            } else {\n\t                if (settings.emptyInputBehavior === 'zero') {\n\t                    settings.rawValue = '0';\n\t                    value = roundValue('0', settings);\n\t                } else {\n\t                    settings.rawValue = '';\n\t                }\n\t            }\n\t\n\t            var groupedValue = checkEmpty(value, settings, false);\n\t            if (groupedValue === null) {\n\t                groupedValue = addGroupSeparators(value, settings);\n\t            }\n\t\n\t            if (groupedValue !== origValue) {\n\t                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n\t                jQueryOriginalVal.call($this, groupedValue);\n\t            }\n\t\n\t            if (groupedValue !== holder.valueOnFocus) {\n\t                $this.change();\n\t                delete holder.valueOnFocus;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'paste' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onPaste($this, holder, e) {\n\t        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n\t        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n\t        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n\t        e.preventDefault();\n\t\n\t        var rawPastedText = e.clipboardData.getData('text/plain');\n\t\n\t        // 0. Special case if the user has selected all the input text before pasting\n\t        var initialFormattedValue = e.target.value;\n\t        var selectionStart = e.target.selectionStart || 0;\n\t        var selectionEnd = e.target.selectionEnd || 0;\n\t        var selectionSize = selectionEnd - selectionStart;\n\t        var isAllInputTextSelected = false;\n\t\n\t        if (selectionSize === initialFormattedValue.length) {\n\t            isAllInputTextSelected = true;\n\t        }\n\t\n\t        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n\t        var isPasteNegative = isNegativeStrict(rawPastedText);\n\t        if (isPasteNegative) {\n\t            // 1a. Remove the negative sign from the pasted text\n\t            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n\t        }\n\t\n\t        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n\t        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\t\n\t        var pastedText = void 0;\n\t        if (untranslatedPastedText === '.') {\n\t            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n\t            pastedText = '.';\n\t        } else {\n\t            // Normal case\n\t            // Allow pasting arabic numbers\n\t            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n\t        }\n\t\n\t        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n\t        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n\t            if (holder.settings.onInvalidPaste === 'error') {\n\t                //TODO Should we send a warning instead of throwing an error?\n\t                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n\t            }\n\t\n\t            return;\n\t        }\n\t\n\t        // 4. Calculate the paste result\n\t        var caretPositionOnInitialTextAfterPasting = void 0;\n\t        var initialUnformattedNumber = void 0;\n\t        if (e.target.value === '') {\n\t            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n\t            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n\t            initialUnformattedNumber = '';\n\t        } else {\n\t            initialUnformattedNumber = $this.autoNumeric('get');\n\t        }\n\t        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n\t        var isPasteNegativeAndInitialValueIsPositive = void 0;\n\t        var result = void 0;\n\t\n\t        // If the pasted content is negative, then the result will be negative too\n\t        if (isPasteNegative && !isInitialValueNegative) {\n\t            initialUnformattedNumber = '-' + initialUnformattedNumber;\n\t            isInitialValueNegative = true;\n\t            isPasteNegativeAndInitialValueIsPositive = true;\n\t        } else {\n\t            isPasteNegativeAndInitialValueIsPositive = false;\n\t        }\n\t\n\t        var leftPartContainedADot = false;\n\t        var leftPart = void 0;\n\t        var rightPart = void 0;\n\t        switch (holder.settings.onInvalidPaste) {\n\t            /* 4a. Truncate paste behavior:\r\n\t             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n\t             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n\t             * Otherwise paste all the numbers in the clipboard.\r\n\t             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n\t             *\r\n\t             * 4b. Replace paste behavior:\r\n\t             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n\t             */\n\t            /* eslint no-case-declarations: 0 */\n\t            case 'truncate':\n\t            case 'replace':\n\t                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n\t                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\t\n\t                if (selectionStart !== selectionEnd) {\n\t                    // a. If there is a selection, remove the selected part, and return the left and right part\n\t                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n\t                } else {\n\t                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n\t                    result = preparePastedText(initialFormattedValue, holder);\n\t                }\n\t\n\t                // Add back the negative sign if needed\n\t                if (isInitialValueNegative) {\n\t                    result = setRawNegativeSign(result);\n\t                }\n\t\n\t                // Build the unformatted result string\n\t                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                if (isPasteNegativeAndInitialValueIsPositive) {\n\t                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n\t                    caretPositionOnInitialTextAfterPasting++;\n\t                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n\t                }\n\t\n\t                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n\t                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n\t                if (pastedText === '.') {\n\t                    if (contains(leftPart, '.')) {\n\t                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n\t                        // To do so, we keep that info in order to modify the caret position later\n\t                        leftPartContainedADot = true;\n\t                        leftPart = leftPart.replace('.', '');\n\t                    }\n\t                    rightPart = rightPart.replace('.', '');\n\t                }\n\t                // -- Here, we are good to go to continue on the same basis\n\t\n\t                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n\t                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n\t                var minParse = parseStr(holder.settings.minimumValue);\n\t                var maxParse = parseStr(holder.settings.maximumValue);\n\t                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n\t                var pastedTextIndex = 0;\n\t                var modifiedLeftPart = leftPart;\n\t\n\t                while (pastedTextIndex < pastedText.length) {\n\t                    // Modify the result with another pasted character\n\t                    modifiedLeftPart += pastedText[pastedTextIndex];\n\t                    result = modifiedLeftPart + rightPart;\n\t\n\t                    // Check the range limits\n\t                    if (!checkIfInRange(result, minParse, maxParse)) {\n\t                        // The result is out of the range limits, stop the loop here\n\t                        break;\n\t                    }\n\t\n\t                    // Save the last good known result\n\t                    lastGoodKnownResult = result;\n\t\n\t                    // Update the local variables for the next loop\n\t                    pastedTextIndex++;\n\t                }\n\t\n\t                // Update the last caret position where to insert a new number\n\t                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\t\n\t                //XXX Here we have the result for the `truncate` option\n\t                if (holder.settings.onInvalidPaste === 'truncate') {\n\t                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n\t                    result = lastGoodKnownResult;\n\t\n\t                    if (leftPartContainedADot) {\n\t                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n\t                        caretPositionOnInitialTextAfterPasting--;\n\t                    }\n\t                    break;\n\t                }\n\t                //XXX ...else we need to continue modifying the result for the 'replace' option\n\t\n\t                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n\t                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n\t                //    If you do get to the range limits, use the previous known good value within those limits.\n\t                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n\t                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n\t                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n\t                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\t\n\t                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n\t                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n\t                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n\t                        lastGoodKnownResultIndex++;\n\t                        continue;\n\t                    }\n\t\n\t                    // This replace one character at a time\n\t                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\t\n\t                    // Check the range limits\n\t                    if (!checkIfInRange(result, minParse, maxParse)) {\n\t                        // The result is out of the range limits, stop the loop here\n\t                        break;\n\t                    }\n\t\n\t                    // Save the last good known result\n\t                    lastGoodKnownResult = result;\n\t\n\t                    // Update the local variables for the next loop\n\t                    pastedTextIndex++;\n\t                    lastGoodKnownResultIndex++;\n\t                }\n\t\n\t                // Update the last caret position where to insert a new number\n\t                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\t\n\t                if (leftPartContainedADot) {\n\t                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n\t                    caretPositionOnInitialTextAfterPasting--;\n\t                }\n\t\n\t                result = lastGoodKnownResult;\n\t\n\t                break;\n\t            /* 4c. Normal paste behavior:\r\n\t             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n\t             */\n\t            case 'error':\n\t            case 'ignore':\n\t            case 'clamp':\n\t            default:\n\t                // 1. Generate the unformatted result\n\t                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n\t                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\t\n\t                if (selectionStart !== selectionEnd) {\n\t                    // a. If there is a selection, remove the selected part, and return the left and right part\n\t                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n\t                } else {\n\t                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n\t                    result = preparePastedText(initialFormattedValue, holder);\n\t                }\n\t\n\t                // Add back the negative sign if needed\n\t                if (isInitialValueNegative) {\n\t                    result = setRawNegativeSign(result);\n\t                }\n\t\n\t                // Build the unformatted result string\n\t                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                if (isPasteNegativeAndInitialValueIsPositive) {\n\t                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n\t                    caretPositionOnInitialTextAfterPasting++;\n\t                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n\t                }\n\t\n\t                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n\t                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n\t                if (pastedText === '.') {\n\t                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n\t                    if (contains(leftPart, '.')) {\n\t                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n\t                        // To do so, we keep that info in order to modify the caret position later\n\t                        leftPartContainedADot = true;\n\t                        leftPart = leftPart.replace('.', '');\n\t                    }\n\t                    rightPart = rightPart.replace('.', '');\n\t                }\n\t                // -- Here, we are good to go to continue on the same basis\n\t\n\t                // Generate the unformatted result\n\t                result = '' + leftPart + pastedText + rightPart;\n\t\n\t                // 2. Calculate the caret position in the unformatted value, for later use\n\t                if (selectionStart === selectionEnd) {\n\t                    // There is no selection, then the caret position is set after the pasted text\n\t                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n\t                } else {\n\t                    if (isAllInputTextSelected) {\n\t                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n\t                        caretPositionOnInitialTextAfterPasting = result.length;\n\t                    } else if (rightPart === '') {\n\t                        // If the user selected from the caret position to the end of the input (on the far right)\n\t                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n\t                    } else {\n\t                        // Normal case\n\t                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\t\n\t                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n\t                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n\t                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n\t                    }\n\t                }\n\t\n\t                // Modify the caret position for special cases, only if the whole input has not been selected\n\t                if (!isAllInputTextSelected) {\n\t                    if (isPasteNegativeAndInitialValueIsPositive) {\n\t                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n\t                        caretPositionOnInitialTextAfterPasting++;\n\t                    }\n\t\n\t                    if (leftPartContainedADot) {\n\t                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n\t                        caretPositionOnInitialTextAfterPasting--;\n\t                    }\n\t                }\n\t        }\n\t\n\t        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n\t        if (!isNumber(result) || result === '') {\n\t            if (holder.settings.onInvalidPaste === 'error') {\n\t                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n\t                //TODO This is not DRY ; refactor with above\n\t            }\n\t            return;\n\t        }\n\t\n\t        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n\t        /*\r\n\t         * If 'error' (this is the default) :\r\n\t         *      - Normal paste behavior.\r\n\t         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n\t         *      - Do not change the input value, do not change the current selection.\r\n\t         * If 'ignore' :\r\n\t         *      - Normal paste behavior.\r\n\t         *      - Try to set the new value, if it fails, do nothing more.\r\n\t         *      - Do not change the input value, do not change the current selection.\r\n\t         * If 'clamp' :\r\n\t         *      - Normal paste behavior.\r\n\t         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n\t         *        paste result.\r\n\t         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n\t         * If 'truncate' :\r\n\t         *      - Truncate paste behavior.\r\n\t         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n\t         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n\t         *      - Change the caret position to be positioned after the last pasted character.\r\n\t         * If 'replace' :\r\n\t         *      - Replace paste behavior.\r\n\t         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n\t         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n\t         *      - Change the caret position to be positioned after the last pasted character.\r\n\t         */\n\t        var valueHasBeenSet = false;\n\t        var valueHasBeenClamped = false;\n\t        try {\n\t            $this.autoNumeric('set', result);\n\t            valueHasBeenSet = true;\n\t        } catch (error) {\n\t            var clampedValue = void 0;\n\t            switch (holder.settings.onInvalidPaste) {\n\t                case 'clamp':\n\t                    clampedValue = clampToRangeLimits(result, holder.settings);\n\t                    try {\n\t                        $this.autoNumeric('set', clampedValue);\n\t                    } catch (error) {\n\t                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n\t                    }\n\t\n\t                    valueHasBeenClamped = true;\n\t                    valueHasBeenSet = true;\n\t                    result = clampedValue; // This is used only for setting the caret position later\n\t                    break;\n\t                case 'error':\n\t                case 'truncate':\n\t                case 'replace':\n\t                    // Throw an error message\n\t                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n\t                // falls through\n\t                case 'ignore':\n\t                // Do nothing\n\t                // falls through\n\t                default:\n\t                    return; // ...and nothing else should be changed\n\t            }\n\t        }\n\t\n\t        // 7. Then lastly, set the caret position at the right logical place\n\t        var caretPositionInFormattedNumber = void 0;\n\t        if (valueHasBeenSet) {\n\t            switch (holder.settings.onInvalidPaste) {\n\t                case 'clamp':\n\t                    if (valueHasBeenClamped) {\n\t                        if (holder.settings.currencySymbolPlacement === 's') {\n\t                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n\t                        } else {\n\t                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n\t                        }\n\t\n\t                        break;\n\t                    } // else if the value has not been clamped, the default behavior is used...\n\t                // falls through\n\t                case 'error':\n\t                case 'ignore':\n\t                case 'truncate':\n\t                case 'replace':\n\t                default:\n\t                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n\t                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n\t                    setElementSelection(e.target, caretPositionInFormattedNumber);\n\t            }\n\t        }\n\t\n\t        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n\t        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n\t            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n\t            triggerEvent('input', e.target);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function _onBlur(holder, e) {\n\t        if (e.target.value !== holder.valueOnFocus) {\n\t            triggerEvent('change', e.target);\n\t            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'submit' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     */\n\t    function onSubmit($this, holder) {\n\t        $this.closest('form').on('submit.autoNumeric', function () {\n\t            if (holder) {\n\t                var $settings = holder.settingsClone;\n\t\n\t                if ($settings.unformatOnSubmit) {\n\t                    jQueryOriginalVal.call($this, $settings.rawValue);\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @returns {boolean|*}\r\n\t     */\n\t    function getInputIfSupportedTagAndType($this) {\n\t        // Supported input type\n\t        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t\n\t        // Checks for non-supported input types\n\t        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n\t            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n\t        }\n\t\n\t        // Checks for non-supported tags\n\t        var currentElementTag = $this.prop('tagName').toLowerCase();\n\t        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n\t            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n\t        }\n\t\n\t        return $input;\n\t    }\n\t\n\t    /**\r\n\t     * Formats the default value on page load.\r\n\t     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     * @param {object} $input jQuery-selected <input> element\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     */\n\t    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n\t        var setValue = true;\n\t\n\t        if ($input) {\n\t            var currentValue = jQueryOriginalVal.call($this);\n\t            /*\r\n\t             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n\t             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n\t             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n\t             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n\t             *\r\n\t             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n\t             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n\t             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n\t             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n\t             * we should ignore `defaultValueOverride` altogether.\r\n\t             */\n\t            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup oDec\n\t            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n\t                // Check if the `value` is valid or not\n\t                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n\t                    $this.autoNumeric('set', unLocalizedCurrentValue);\n\t                    setValue = false;\n\t                } else {\n\t                    // If not, inform the developer that nothing usable has been provided\n\t                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n\t                }\n\t            } else {\n\t                /* Checks for :\r\n\t                 * - page reload from back button, and\r\n\t                 * - ASP.net form post back\r\n\t                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n\t                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n\t                 */\n\t                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n\t                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n\t                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n\t                    }\n\t\n\t                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n\t                    if (!settings.saveValueToSessionStorage) {\n\t                        var toStrip = void 0;\n\t\n\t                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n\t                            settings.hasFocus = true;\n\t                            toStrip = toggleNegativeBracket(currentValue, settings);\n\t                        } else {\n\t                            toStrip = currentValue;\n\t                        }\n\t\n\t                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n\t                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n\t                        } else {\n\t                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n\t                        }\n\t                    }\n\t\n\t                    setValue = false;\n\t                }\n\t            }\n\t\n\t            if (currentValue === '') {\n\t                switch (settings.emptyInputBehavior) {\n\t                    case 'focus':\n\t                        setValue = false;\n\t                        break;\n\t                    case 'always':\n\t                        jQueryOriginalVal.call($this, settings.currencySymbol);\n\t                        setValue = false;\n\t                        break;\n\t                    case 'zero':\n\t                        $this.autoNumeric('set', '0');\n\t                        setValue = false;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (setValue && currentValue === $this.attr('value')) {\n\t                $this.autoNumeric('set', currentValue);\n\t            }\n\t        }\n\t\n\t        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n\t            if (settings.defaultValueOverride !== null) {\n\t                if (settings.defaultValueOverride === $this.text()) {\n\t                    $this.autoNumeric('set', $this.text());\n\t                }\n\t            } else {\n\t                $this.autoNumeric('set', $this.text());\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n\t     *\r\n\t     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n\t     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n\t     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n\t     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function correctNegativePositiveSignPlacementOption(settings) {\n\t        // If negativePositiveSignPlacement is already set, we do not overwrite it\n\t        if (!isNull(settings.negativePositiveSignPlacement)) {\n\t            return;\n\t        }\n\t\n\t        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n\t            switch (settings.currencySymbolPlacement) {\n\t                case 's':\n\t                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 \n\t                    break;\n\t                case 'p':\n\t                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n\t                    break;\n\t                default:\n\t                //\n\t            }\n\t        } else {\n\t            // Sets the default value if `negativePositiveSignPlacement` is `null`\n\t            settings.negativePositiveSignPlacement = 'l';\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function calculateVMinAndVMaxIntegerSizes(settings) {\n\t        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n\t            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n\t            maximumValueIntegerPart = _settings$maximumValu2[0];\n\t\n\t        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n\t            _ref4 = _slicedToArray(_ref3, 1),\n\t            minimumValueIntegerPart = _ref4[0];\n\t\n\t        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n\t        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\t\n\t        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n\t        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n\t    }\n\t\n\t    /**\r\n\t     * Modify `decimalPlacesOverride` as needed\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function correctDecimalPlacesOverrideOption(settings) {\n\t        if (isNull(settings.decimalPlacesOverride)) {\n\t            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n\t        }\n\t        settings.oDec = String(settings.decimalPlacesOverride);\n\t\n\t        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n\t        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n\t    }\n\t\n\t    /**\r\n\t     * Sets the alternative decimal separator key.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function setsAlternativeDecimalSeparatorCharacter(settings) {\n\t        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n\t            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n\t                settings.decimalCharacterAlternative = ',';\n\t            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n\t                settings.decimalCharacterAlternative = '.';\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Caches regular expressions for stripAllNonNumberCharacters\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function cachesUsualRegularExpressions(settings) {\n\t        var allNumbersReg = '[0-9]';\n\t        var noAllNumbersReg = '[^0-9]';\n\t\n\t        // Test if there is a negative character in the string\n\t        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n\t        settings.aNegRegAutoStrip = aNegReg;\n\t\n\t        var negativeSignRegPart = void 0;\n\t        if (settings.negativeSignCharacter) {\n\t            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n\t        } else {\n\t            negativeSignRegPart = '';\n\t        }\n\t        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n\t        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\t\n\t        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n\t        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n\t        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\t\n\t        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n\t        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n\t    }\n\t\n\t    /**\r\n\t     * Modify the user settings to make them 'exploitable' later.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function transformOptionsValuesToDefaultTypes(settings) {\n\t        $.each(settings, function (key, value) {\n\t            // Convert the string 'true' and 'false' to real Boolean\n\t            if (value === 'true' || value === 'false') {\n\t                settings[key] = value === 'true';\n\t            }\n\t\n\t            // Convert numbers in options to strings\n\t            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n\t            if (typeof value === 'number' && key !== 'aScale') {\n\t                settings[key] = value.toString();\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * Convert the old settings options name to new ones.\r\n\t     *\r\n\t     * @param {object} options\r\n\t     */\n\t    function convertOldOptionsToNewOnes(options) {\n\t        //TODO Delete this function once the old options are not used anymore\n\t        var oldOptionsConverter = {\n\t            // Old option name, with their corresponding new option\n\t            aSep: 'digitGroupSeparator',\n\t            nSep: 'noSeparatorOnFocus',\n\t            dGroup: 'digitalGroupSpacing',\n\t            aDec: 'decimalCharacter',\n\t            altDec: 'decimalCharacterAlternative',\n\t            aSign: 'currencySymbol',\n\t            pSign: 'currencySymbolPlacement',\n\t            pNeg: 'negativePositiveSignPlacement',\n\t            aSuffix: 'suffixText',\n\t            oLimits: 'overrideMinMaxLimits',\n\t            vMax: 'maximumValue',\n\t            vMin: 'minimumValue',\n\t            mDec: 'decimalPlacesOverride',\n\t            eDec: 'decimalPlacesShownOnFocus',\n\t            scaleDecimal: 'scaleDecimalPlaces',\n\t            aStor: 'saveValueToSessionStorage',\n\t            mRound: 'roundingMethod',\n\t            aPad: 'allowDecimalPadding',\n\t            nBracket: 'negativeBracketsTypeOnBlur',\n\t            wEmpty: 'emptyInputBehavior',\n\t            lZero: 'leadingZero',\n\t            aForm: 'formatOnPageLoad',\n\t            sNumber: 'selectNumberOnly',\n\t            anDefault: 'defaultValueOverride',\n\t            unSetOnSubmit: 'unformatOnSubmit',\n\t            outputType: 'outputFormat',\n\t            debug: 'showWarnings',\n\t            // Current options :\n\t            digitGroupSeparator: true,\n\t            noSeparatorOnFocus: true,\n\t            digitalGroupSpacing: true,\n\t            decimalCharacter: true,\n\t            decimalCharacterAlternative: true,\n\t            currencySymbol: true,\n\t            currencySymbolPlacement: true,\n\t            negativePositiveSignPlacement: true,\n\t            showPositiveSign: true,\n\t            suffixText: true,\n\t            overrideMinMaxLimits: true,\n\t            maximumValue: true,\n\t            minimumValue: true,\n\t            decimalPlacesOverride: true,\n\t            decimalPlacesShownOnFocus: true,\n\t            scaleDivisor: true,\n\t            scaleDecimalPlaces: true,\n\t            scaleSymbol: true,\n\t            saveValueToSessionStorage: true,\n\t            onInvalidPaste: true,\n\t            roundingMethod: true,\n\t            allowDecimalPadding: true,\n\t            negativeBracketsTypeOnBlur: true,\n\t            emptyInputBehavior: true,\n\t            leadingZero: true,\n\t            formatOnPageLoad: true,\n\t            selectNumberOnly: true,\n\t            defaultValueOverride: true,\n\t            unformatOnSubmit: true,\n\t            outputFormat: true,\n\t            showWarnings: true,\n\t            failOnUnknownOption: true,\n\t            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n\t            hasFocus: true,\n\t            runOnce: true,\n\t            rawValue: true,\n\t            trailingNegative: true,\n\t            caretFix: true,\n\t            throwInput: true,\n\t            strip: true,\n\t            tagList: true,\n\t            negativeSignCharacter: true,\n\t            positiveSignCharacter: true,\n\t            mIntPos: true,\n\t            mIntNeg: true,\n\t            oDec: true,\n\t            oPad: true,\n\t            oBracket: true,\n\t            oSep: true,\n\t            oSign: true,\n\t            oSuffix: true,\n\t            aNegRegAutoStrip: true,\n\t            skipFirstAutoStrip: true,\n\t            skipLastAutoStrip: true,\n\t            allowedAutoStrip: true,\n\t            numRegAutoStrip: true,\n\t            stripReg: true,\n\t            holder: true\n\t        };\n\t\n\t        for (var option in options) {\n\t            if (options.hasOwnProperty(option)) {\n\t                if (oldOptionsConverter[option] === true) {\n\t                    // If the option is a 'new' option, we continue looping\n\t                    continue;\n\t                }\n\t\n\t                if (oldOptionsConverter.hasOwnProperty(option)) {\n\t                    // Else we have an 'old' option name\n\t                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\t\n\t                    // Then we modify the initial option object to use the new options instead of the old ones\n\t                    options[oldOptionsConverter[option]] = options[option];\n\t                    delete options[option];\n\t                } else if (options.failOnUnknownOption) {\n\t                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n\t                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n\t     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n\t     *\r\n\t     * @param {object} options\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n\t     * @returns {object|null}\r\n\t     */\n\t    function getInitialSettings(options, $this) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n\t        var settings = $this.data('autoNumeric');\n\t\n\t        // If the user used old options, we convert them to new ones\n\t        if (update || !isNull(options)) {\n\t            convertOldOptionsToNewOnes(options);\n\t        }\n\t\n\t        if (update || isUndefined(settings)) {\n\t            if (update) {\n\t                // The settings are updated\n\t                settings = $.extend(settings, options);\n\t            } else {\n\t                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n\t                // The settings are generated for the first time\n\t                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n\t                var tagData = $this.data();\n\t                settings = $.extend({}, defaultSettings, tagData, options, {\n\t                    hasFocus: false,\n\t                    runOnce: false,\n\t                    rawValue: '',\n\t                    trailingNegative: false,\n\t                    caretFix: false,\n\t                    androidSelectionStart: null,\n\t                    throwInput: true, // Throw input event\n\t                    strip: true,\n\t                    tagList: allowedTagList\n\t                });\n\t            }\n\t\n\t            // Modify the user settings to make them 'exploitable'\n\t            transformOptionsValuesToDefaultTypes(settings);\n\t\n\t            // Improve the `negativePositiveSignPlacement` option if needed\n\t            correctNegativePositiveSignPlacementOption(settings);\n\t\n\t            // Set the negative and positive signs, as needed\n\t            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\t            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\t\n\t            // Additional changes to the settings object (from the original autoCode() function)\n\t            runCallbacksFoundInTheSettingsObject($this, settings);\n\t            calculateVMinAndVMaxIntegerSizes(settings);\n\t            correctDecimalPlacesOverrideOption(settings);\n\t            setsAlternativeDecimalSeparatorCharacter(settings);\n\t            cachesUsualRegularExpressions(settings);\n\t\n\t            // Validate the settings\n\t            validate(settings, false); // Throws if necessary\n\t\n\t            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n\t            keepAnOriginalSettingsCopy(settings);\n\t\n\t            // Save our new settings\n\t            $this.data('autoNumeric', settings);\n\t\n\t            return settings;\n\t        } else {\n\t            return null;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Convert the `value` parameter that can either be :\r\n\t     * - a real number,\r\n\t     * - a string representing a real number, or\r\n\t     * - a string representing a localized number (with specific group separators and decimal character),\r\n\t     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n\t     *\r\n\t     * This function returns `NaN` if such conversion fails.\r\n\t     *\r\n\t     * @param {int|float|string} value\r\n\t     * @param {object} settings\r\n\t     * @returns {string|NaN}\r\n\t     */\n\t    function toNumericValue(value, settings) {\n\t        var result = void 0;\n\t        if (isNumber(Number(value))) {\n\t            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n\t            result = value;\n\t        } else {\n\t            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n\t            // Convert the value to a numeric string, stripping unnecessary characters in the process\n\t            result = convertToNumericString(value.toString(), settings);\n\t\n\t            // If the result is still not a numeric string, then we throw a warning\n\t            if (!isNumber(Number(result))) {\n\t                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n\t                result = NaN;\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Methods supported by autoNumeric\r\n\t     */\n\t    var methods = {\n\t        /**\r\n\t         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n\t         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\r\n\t         *\r\n\t         * @example\r\n\t         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n\t         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n\t         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n\t         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n\t         *\r\n\t         * @param {object} options\r\n\t         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n\t         */\n\t        init: function init(options) {\n\t            return this.each(function () {\n\t                var _this2 = this;\n\t\n\t                var $this = $(this);\n\t                var $input = getInputIfSupportedTagAndType($this);\n\t\n\t                var settings = getInitialSettings(options, $this, false);\n\t                if (isNull(settings)) {\n\t                    return this;\n\t                }\n\t\n\t                // Create the AutoNumericHolder object that store the field properties\n\t                var holder = getAutoNumericHolder($this, settings, false);\n\t\n\t                if (!settings.runOnce && settings.formatOnPageLoad) {\n\t                    formatDefaultValueOnPageLoad(settings, $input, $this);\n\t                }\n\t\n\t                settings.runOnce = true;\n\t\n\t                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n\t                if ($input && $this.data('initialized') !== true) {\n\t                    (function () {\n\t                        var eventHandlers = {\n\t                            onFocusInAndMouseEnter: function onFocusInAndMouseEnter(e) {\n\t                                _onFocusInAndMouseEnter($this, holder, e);\n\t                            },\n\t                            onFocusOutAndMouseLeave: function onFocusOutAndMouseLeave(e) {\n\t                                _onFocusOutAndMouseLeave($this, holder, e);\n\t                            },\n\t                            onKeydown: function onKeydown(e) {\n\t                                _onKeydown(holder, e);\n\t                            },\n\t                            onKeypress: function onKeypress(e) {\n\t                                _onKeypress(holder, e);\n\t                            },\n\t                            onInput: function onInput(e) {\n\t                                _onInput(holder, e);\n\t                            },\n\t                            onKeyup: function onKeyup(e) {\n\t                                _onKeyup(holder, settings, e);\n\t                            },\n\t                            onBlur: function onBlur(e) {\n\t                                _onBlur(holder, e);\n\t                            },\n\t                            onPaste: function onPaste(e) {\n\t                                _onPaste($this, holder, e);\n\t                            }\n\t                        };\n\t                        var eventConfigs = [{ name: 'focusin', handler: eventHandlers.onFocusInAndMouseEnter }, { name: 'mouseenter', handler: eventHandlers.onFocusInAndMouseEnter }, { name: 'blur', handler: eventHandlers.onFocusOutAndMouseLeave }, { name: 'mouseleave', handler: eventHandlers.onFocusOutAndMouseLeave }, { name: 'keydown', handler: eventHandlers.onKeydown }, { name: 'keypress', handler: eventHandlers.onKeypress }, { name: 'input', handler: eventHandlers.onInput }, { name: 'keyup', handler: eventHandlers.onKeyup }, { name: 'blur', handler: eventHandlers.onBlur }, { name: 'paste', handler: eventHandlers.onPaste }];\n\t\n\t                        var _iteratorNormalCompletion = true;\n\t                        var _didIteratorError = false;\n\t                        var _iteratorError = undefined;\n\t\n\t                        try {\n\t                            for (var _iterator = eventConfigs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                                var eventConfig = _step.value;\n\t\n\t                                _this2.addEventListener(eventConfig.name, eventConfig.handler, false);\n\t                            }\n\t                        } catch (err) {\n\t                            _didIteratorError = true;\n\t                            _iteratorError = err;\n\t                        } finally {\n\t                            try {\n\t                                if (!_iteratorNormalCompletion && _iterator.return) {\n\t                                    _iterator.return();\n\t                                }\n\t                            } finally {\n\t                                if (_didIteratorError) {\n\t                                    throw _iteratorError;\n\t                                }\n\t                            }\n\t                        }\n\t\n\t                        onSubmit($this, holder); //TODO Switch to `addEventListener'\n\t\n\t                        $this.data({\n\t                            initialized: true,\n\t                            misc: {\n\t                                removeAllEvents: function removeAllEvents(el) {\n\t                                    var _iteratorNormalCompletion2 = true;\n\t                                    var _didIteratorError2 = false;\n\t                                    var _iteratorError2 = undefined;\n\t\n\t                                    try {\n\t                                        for (var _iterator2 = eventConfigs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                                            var eventConfig = _step2.value;\n\t\n\t                                            el.removeEventListener(eventConfig.name, eventConfig.handler, false);\n\t                                        }\n\t                                    } catch (err) {\n\t                                        _didIteratorError2 = true;\n\t                                        _iteratorError2 = err;\n\t                                    } finally {\n\t                                        try {\n\t                                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                                                _iterator2.return();\n\t                                            }\n\t                                        } finally {\n\t                                            if (_didIteratorError2) {\n\t                                                throw _iteratorError2;\n\t                                            }\n\t                                        }\n\t                                    }\n\t\n\t                                    $(el).closest('form').off('.autoNumeric');\n\t                                }\n\t                            }\n\t                        });\n\t                    })();\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to stop and remove autoNumeric for the current element.\r\n\t         * Note: this does not remove the formatting.\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n\t         *\r\n\t         * @param {Boolean} clearValue If TRUE, then this function clears the text box upon destruction.\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        destroy: function destroy() {\n\t            var clearValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    jQueryOriginalVal.call($this, clearValue === true ? '' : $this.autoNumeric('get'));\n\t                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                    $this.data('misc').removeAllEvents(this);\n\t                    $this.removeData('autoNumeric', 'initialized', 'removeAllEvents');\n\t                    $this.off('.autoNumeric');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        wipe: function wipe() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    jQueryOriginalVal.call($this, '');\n\t                    settings.rawValue = '';\n\t                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method that updates the autoNumeric settings.\r\n\t         * It can be called multiple times if needed.\r\n\t         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n\t         *\r\n\t         * @param {object} options\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        update: function update(options) {\n\t            return $(this).each(function () {\n\t                // Retrieve the current unformatted input value\n\t                var $this = getCurrentElement(this);\n\t                var strip = $this.autoNumeric('get');\n\t\n\t                // Update the settings\n\t                var settings = getInitialSettings(options, $this, true);\n\t\n\t                // Update the AutoNumericHolder object that store the field properties\n\t                getAutoNumericHolder($this, settings, true);\n\t\n\t                // Reformat the input value with the new settings\n\t                if (jQueryOriginalVal.call($this) !== '' || $this.text() !== '') {\n\t                    return $this.autoNumeric('set', strip);\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to format the value passed as a parameter.\r\n\t         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n\t         * and must contain only numbers and one decimal (period) character\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n\t         *\r\n\t         * @param {*} newValue\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        set: function set(newValue) {\n\t            return $(this).each(function () {\n\t                if (newValue === null || isUndefined(newValue)) {\n\t                    return;\n\t                }\n\t\n\t                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n\t                }\n\t                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n\t                settings.trailingNegative = false;\n\t\n\t                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t\n\t                var value = toNumericValue(newValue, settings);\n\t                if (isNaN(value)) {\n\t                    return jQueryOriginalVal.call($this, '');\n\t                }\n\t\n\t                if (value !== '') {\n\t                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n\t                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n\t                        minTest = _checkIfInRangeWithOv6[0],\n\t                        maxTest = _checkIfInRangeWithOv6[1];\n\t                    // This test is needed by the showPositiveSign option\n\t\n\t\n\t                    var isZero = isZeroOrHasNoValue(value);\n\t                    if (isZero) {\n\t                        value = '0';\n\t                    }\n\t\n\t                    if (minTest && maxTest) {\n\t                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                            // to ensure rounding does not happen twice\n\t                            var hasBeenRounded = false;\n\t\n\t                            // rounds the the extended decimal places\n\t                            var tempDecimal = void 0;\n\t                            if (settings.decimalPlacesShownOnFocus) {\n\t                                tempDecimal = settings.decimalPlacesOverride;\n\t                                settings.decimalPlacesOverride = Number(settings.decimalPlacesShownOnFocus);\n\t                                value = roundValue(value, settings);\n\t                                hasBeenRounded = true;\n\t                                settings.decimalPlacesOverride = tempDecimal;\n\t                            }\n\t\n\t                            if (settings.scaleDivisor && !settings.onOff) {\n\t                                value = roundValue(value, settings);\n\t                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\t                                value = toNumericValue(value, settings);\n\t                                value = value / settings.scaleDivisor;\n\t                                value = value.toString();\n\t                                if (settings.scaleDecimalPlaces) {\n\t                                    tempDecimal = settings.decimalPlacesOverride;\n\t                                    settings.decimalPlacesOverride = Number(settings.scaleDecimalPlaces);\n\t                                    value = roundValue(value, settings);\n\t                                    hasBeenRounded = true;\n\t                                }\n\t                            }\n\t\n\t                            // Rounds if this has not been done already\n\t                            if (!hasBeenRounded) {\n\t                                value = roundValue(value, settings);\n\t                            }\n\t\n\t                            // Stores rawValue including the decimalPlacesShownOnFocus\n\t                            if (!settings.scaleDivisor) {\n\t                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\t                            }\n\t\n\t                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n\t                            value = addGroupSeparators(value, settings);\n\t\n\t                            if (settings.scaleDivisor && settings.scaleDecimalPlaces && !settings.onOff) {\n\t                                settings.decimalPlacesOverride = tempDecimal;\n\t                            }\n\t                        }\n\t\n\t                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n\t                            saveValueToPersistentStorage($this[0], settings, 'set');\n\t                        }\n\t                    } else {\n\t                        settings.rawValue = '';\n\t                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                        var attemptedValue = value;\n\t                        value = '';\n\t                        if (!minTest) {\n\t                            $this.trigger('autoNumeric:minExceeded');\n\t                        }\n\t\n\t                        if (!maxTest) {\n\t                            $this.trigger('autoNumeric:maxExceeded');\n\t                        }\n\t\n\t                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\t\n\t                        return jQueryOriginalVal.call($this, '');\n\t                    }\n\t                } else {\n\t                    return jQueryOriginalVal.call($this, '');\n\t                }\n\t\n\t                if (!settings.hasFocus && settings.scaleSymbol) {\n\t                    value = value + settings.scaleSymbol;\n\t                }\n\t\n\t                if ($input) {\n\t                    return jQueryOriginalVal.call($this, value);\n\t                }\n\t\n\t                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                    return $this.text(value);\n\t                }\n\t\n\t                return false;\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to un-format inputs.\r\n\t         * This is handy to use right before form submission.\r\n\t         *\r\n\t         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n\t         * Please see option \"outputFormat\" for more details\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric('unSet');\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        unSet: function unSet() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    settings.hasFocus = true;\n\t                    jQueryOriginalVal.call($this, $this.autoNumeric('getLocalized'));\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to re-format inputs.\r\n\t         * This is handy to use right after form submission.\r\n\t         *\r\n\t         * This is called after the 'unSet' method to reformat the input\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric('reSet');\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        reSet: function reSet() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.autoNumeric('set', jQueryOriginalVal.call($this));\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Return the unformatted value as a string.\r\n\t         *\r\n\t         * @usage $(someSelector).autoNumeric('get');\r\n\t         *\r\n\t         * @returns {string}\r\n\t         */\n\t        get: function get() {\n\t            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n\t            var $this = getCurrentElement(this);\n\t            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t            var settings = $this.data('autoNumeric');\n\t            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n\t            }\n\t\n\t            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n\t            var value = '';\n\t            if ($input) {\n\t                value = jQueryOriginalVal.call($this.eq(0));\n\t            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                value = $this.eq(0).text();\n\t            } else {\n\t                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n\t                value = settings.rawValue;\n\t            } else {\n\t                // Test if the value is negative\n\t                var isValueNegative = isNegative(value);\n\t\n\t                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n\t                    return '';\n\t                }\n\t\n\t                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n\t                    settings.hasFocus = true;\n\t                    value = toggleNegativeBracket(value, settings);\n\t                }\n\t\n\t                if (settings.runOnce || settings.formatOnPageLoad === false) {\n\t                    // Strips trailing negative symbol\n\t                    value = stripAllNonNumberCharacters(value, settings, true);\n\t                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n\t                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\t\n\t                    // Places the negative symbol in front of the trailing negative\n\t                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n\t                        value = '-' + value;\n\t                    }\n\t                }\n\t\n\t                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n\t                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n\t                }\n\t            }\n\t\n\t            // Always return a numeric string\n\t            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n\t            return trimPaddedZerosFromDecimalPlaces(value);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n\t         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n\t         * - a plain number (if the setting 'number' is used).\r\n\t         *\r\n\t         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n\t         * Check the \"outputFormat\" option definition for more details.\r\n\t         *\r\n\t         * @usage $(someSelector).autoNumeric('getLocalized');\r\n\t         *\r\n\t         * @returns {*}\r\n\t         */\n\t        getLocalized: function getLocalized() {\n\t            var $this = getCurrentElement(this);\n\t            var value = $this.autoNumeric('get');\n\t            var settings = $this.data('autoNumeric');\n\t\n\t            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n\t                value = '0';\n\t            }\n\t\n\t            return toLocale(value, settings.outputFormat);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Return the input unformatted value as a real Javascript number.\r\n\t         *\r\n\t         * @usage $(someSelector).autoNumeric('getNumber');\r\n\t         *\r\n\t         * @returns {number}\r\n\t         */\n\t        getNumber: function getNumber() {\n\t            var $this = getCurrentElement(this);\n\t            var value = $this.autoNumeric('get');\n\t\n\t            return toLocale(value, 'number');\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Return the current formatted value of the autoNumeric element.\r\n\t         * @usage aNInput.autoNumeric('getFormatted'))\r\n\t         *\r\n\t         * @returns {string}\r\n\t         */\n\t        getFormatted: function getFormatted() {\n\t            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n\t            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n\t                throwError('Unable to get the formatted string from the element.');\n\t            }\n\t\n\t            return this[0].value;\n\t        },\n\t\n\t\n\t        /**\r\n\t         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n\t         *\r\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n\t         *\r\n\t         * @returns {string}\r\n\t         */\n\t        getString: function getString() {\n\t            return _getStringOrArray(false, this);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n\t         *\r\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n\t         *\r\n\t         * @returns {{}|[]}\r\n\t         */\n\t        getArray: function getArray() {\n\t            return _getStringOrArray(true, this);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n\t         *\r\n\t         * @example\r\n\t         * $(someSelector).autoNumeric('getSettings');\r\n\t         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n\t         *\r\n\t         * @returns {object}\r\n\t         */\n\t        getSettings: function getSettings() {\n\t            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n\t            return this.data('autoNumeric');\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n\t     * It initialize autoNumeric on the given element.\r\n\t     *\r\n\t     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n\t     * @param {*} args\r\n\t     * @returns {*}\r\n\t     */\n\t    $.fn.autoNumeric = function (method) {\n\t        if (methods[method]) {\n\t            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                args[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            return methods[method].apply(this, args);\n\t        }\n\t\n\t        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n\t            // The options have been passed directly, without using a named method\n\t            return methods.init.apply(this, [method]);\n\t        }\n\t\n\t        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n\t    };\n\t\n\t    /**\r\n\t     * Return the default autoNumeric settings.\r\n\t     *\r\n\t     * @returns {object}\r\n\t     */\n\t    getDefaultConfig = function getDefaultConfig() {\n\t        return defaultSettings;\n\t    };\n\t\n\t    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\t\n\t    /**\r\n\t     * Return all the predefined language options in one object.\r\n\t     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n\t     *\r\n\t     * @returns {object}\r\n\t     */\n\t    getLanguages = function getLanguages() {\n\t        return languageOption;\n\t    };\n\t\n\t    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\t\n\t    /**\r\n\t     * Public function that allows formatting without an element trigger.\r\n\t     *\r\n\t     * @param {number|string} value A number, or a string that represent a javascript number\r\n\t     * @param {object|null} options\r\n\t     * @returns {*}\r\n\t     */\n\t    autoFormat = function autoFormat(value) {\n\t        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        if (!isString(value) && !isNumber(value)) {\n\t            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n\t        }\n\t\n\t        // Initiate a very basic settings object\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        if (value < 0) {\n\t            settings.negativeSignCharacter = '-';\n\t        }\n\t\n\t        if (isNull(settings.decimalPlacesOverride)) {\n\t            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n\t        }\n\t\n\t        // Check the validity of the `value` parameter\n\t        // Convert the value to a numeric string, stripping unnecessary characters in the process\n\t        var valueString = toNumericValue(value, settings);\n\t        if (isNaN(valueString)) {\n\t            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n\t        }\n\t\n\t        // Basic tests to check if the given valueString is valid\n\t\n\t        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n\t            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n\t            minTest = _checkIfInRangeWithOv8[0],\n\t            maxTest = _checkIfInRangeWithOv8[1];\n\t\n\t        if (!minTest || !maxTest) {\n\t            // Throw a custom event\n\t            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n\t            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\t        }\n\t\n\t        // Everything is ok, proceed to rounding, formatting and grouping\n\t        valueString = roundValue(valueString, settings);\n\t        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n\t        valueString = addGroupSeparators(valueString, settings);\n\t\n\t        return valueString;\n\t    };\n\t\n\t    $.fn.autoFormat = autoFormat; // The jQuery export\n\t\n\t    /**\r\n\t     * Public function that allows unformatting without an element.\r\n\t     *\r\n\t     * @param {string|number} value\r\n\t     * @param {object} options\r\n\t     * @returns {*}\r\n\t     */\n\t    autoUnFormat = function autoUnFormat(value, options) {\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n\t        if (isNumber(value)) {\n\t            return Number(value);\n\t        }\n\t\n\t        if (isArray(value) || isObject(value)) {\n\t            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n\t            // Check the validity of the `value` parameter\n\t            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n\t        }\n\t\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n\t        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n\t        value = value.toString();\n\t\n\t        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n\t        if (isNegative(value)) {\n\t            settings.negativeSignCharacter = '-';\n\t        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n\t            settings.negativeSignCharacter = '-';\n\t            settings.hasFocus = true;\n\t            value = toggleNegativeBracket(value, settings);\n\t        }\n\t\n\t        value = value.replace(autoStrip, '');\n\t        value = value.replace(settings.decimalCharacter, '.');\n\t        value = toLocale(value, settings.outputFormat);\n\t\n\t        return value;\n\t    };\n\t\n\t    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\t\n\t    /**\r\n\t     * Validate the given option object.\r\n\t     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n\t     *\r\n\t     * This tests if the options are not conflicting and are well formatted.\r\n\t     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n\t     *\r\n\t     * @param {*} userOptions\r\n\t     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n\t     * @throws Error\r\n\t     */\n\t    validate = function validate(userOptions) {\n\t        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n\t            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n\t        }\n\t\n\t        // If the user used old options, we convert them to new ones\n\t        if (!isNull(userOptions)) {\n\t            convertOldOptionsToNewOnes(userOptions);\n\t        }\n\t\n\t        // The user can choose if the `userOptions` has already been extended with the default options, or not\n\t        var options = void 0;\n\t        if (shouldExtendDefaultOptions) {\n\t            options = $.extend({}, defaultSettings, userOptions);\n\t        } else {\n\t            options = userOptions;\n\t        }\n\t\n\t        // First things first, we test that the `showWarnings` option is valid\n\t        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n\t            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n\t        }\n\t\n\t        // Define the regular expressions needed for the following tests\n\t        var testPositiveInteger = /^[0-9]+$/;\n\t        var testNumericalCharacters = /[0-9]+/;\n\t        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n\t        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n\t        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\t\n\t        // Then tests the options individually\n\t        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n\t        '.', // Dot\n\t        ' ', // Normal space\n\t        '\\u2009', // Thin-space\n\t        '\\u202F', // Narrow no-break space\n\t        '\\xA0', // No-break space\n\t        '', // No separator\n\t        \"'\", // Apostrophe\n\t        '', // Arabic thousands separator\n\t        ''])) {\n\t            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n\t            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n\t        }\n\t\n\t        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n\t            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.decimalCharacter, [',', // Comma\n\t        '.', // Dot\n\t        '', // Middle-dot\n\t        '', // Arabic decimal separator\n\t        ''])) {\n\t            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n\t        }\n\t\n\t        // Checks if the decimal and thousand characters are the same\n\t        if (options.decimalCharacter === options.digitGroupSeparator) {\n\t            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n\t        }\n\t\n\t        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n\t            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n\t        }\n\t\n\t        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n\t            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n\t            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n\t            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n\t            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n\t        }\n\t\n\t        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n\t            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n\t            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n\t        }\n\t\n\t        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n\t            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n\t        }\n\t\n\t        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n\t            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n\t        }\n\t\n\t        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n\t            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n\t        }\n\t\n\t        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n\t        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n\t        ) {\n\t                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n\t            }\n\t\n\t        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n\t        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n\t        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n\t            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n\t        }\n\t\n\t        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n\t            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n\t        }\n\t\n\t        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n\t            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n\t        }\n\t\n\t        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n\t        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n\t            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n\t        }\n\t\n\t        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n\t            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n\t            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n\t            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n\t            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n\t            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n\t            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n\t            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n\t            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n\t            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n\t            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n\t            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n\t            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n\t            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n\t            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n\t            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n\t            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n\t        }\n\t    };\n\t\n\t    $.fn.autoValidate = validate;\n\t\n\t    /**\r\n\t     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n\t     *\r\n\t     * @param {object} options\r\n\t     * @returns {boolean}\r\n\t     */\n\t    areSettingsValid = function areSettingsValid(options) {\n\t        var isValid = true;\n\t        try {\n\t            validate(options);\n\t        } catch (error) {\n\t            isValid = false;\n\t        }\n\t\n\t        return isValid;\n\t    };\n\t\n\t    /**\r\n\t     * Take an arabic number as a string and return a javascript number.\r\n\t     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n\t     * This returns `NaN` is the conversion is not possible.\r\n\t     * Based on http://stackoverflow.com/a/17025392/2834898\r\n\t     *\r\n\t     * @param {string} arabicNumbers\r\n\t     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n\t     * @param {boolean} parseDecimalCharacter\r\n\t     * @param {boolean} parseThousandSeparator\r\n\t     * @returns {string|number|NaN}\r\n\t     */\n\t    function arabicToLatinNumbers(arabicNumbers) {\n\t        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\n\t        var result = arabicNumbers.toString();\n\t        if (result === '' || result.match(/[]/g) === null) {\n\t            // If no Arabic/Persian numbers are found, return the numeric string directly\n\t            return arabicNumbers;\n\t        }\n\t\n\t        if (parseDecimalCharacter) {\n\t            result = result.replace(//, '.'); // Decimal character\n\t        }\n\t\n\t        if (parseThousandSeparator) {\n\t            result = result.replace(//g, ''); // Thousand separator\n\t        }\n\t\n\t        // Replace the numbers only\n\t        result = result.replace(/[]/g, function (d) {\n\t            return d.charCodeAt(0) - 1632;\n\t        }) // Arabic numbers\n\t        .replace(/[]/g, function (d) {\n\t            return d.charCodeAt(0) - 1776;\n\t        }); // Persian numbers\n\t\n\t        // `NaN` has precedence over the string `'NaN'`\n\t        var resultAsNumber = Number(result);\n\t        if (isNaN(resultAsNumber)) {\n\t            return resultAsNumber;\n\t        }\n\t\n\t        if (returnANumber) {\n\t            result = resultAsNumber;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Create a custom event and immediately sent it from the given element.\r\n\t     * By default, if no element is given, the event is thrown from `document`.\r\n\t     *\r\n\t     * @param {string} eventName\r\n\t     * @param {Element} element\r\n\t     * @param {object} detail\r\n\t     */\n\t    function triggerEvent(eventName) {\n\t        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n\t        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t        var event = void 0;\n\t        if (window.CustomEvent) {\n\t            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n\t        } else {\n\t            event = document.createEvent('CustomEvent');\n\t            event.initCustomEvent(eventName, true, true, { detail: detail });\n\t        }\n\t\n\t        element.dispatchEvent(event);\n\t    }\n\t\n\t    /**\r\n\t     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n\t     */\n\t    (function () {\n\t        if (typeof window.CustomEvent === 'function') {\n\t            return false;\n\t        }\n\t\n\t        function CustomEvent(event, params) {\n\t            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n\t            var evt = document.createEvent('CustomEvent');\n\t            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t            return evt;\n\t        }\n\t\n\t        CustomEvent.prototype = window.Event.prototype;\n\t        window.CustomEvent = CustomEvent;\n\t    })();\n\t\n\t    $.extend(true, defaultSettings, $.fn.autoNumeric.lang.Turkish, { currencySymbol: '' });\n\t\n\t    // Hijack the original val fn in order to\n\t    // use $autoNumeric.val() and be able to get/set\n\t    // the unmasked value.\n\t    $.fn.val = function (value) {\n\t        var me = this;\n\t        var $me = $(me);\n\t\n\t        // If we're not dealing with an instance of autoNumeric,\n\t        // simply call the original jQuery.fn.val\n\t        if ($me.data('autoNumeric') === undefined) {\n\t            return jQueryOriginalVal.apply(me, arguments); // eslint-disable-line prefer-rest-params\n\t        }\n\t\n\t        if (!arguments.length) {\n\t            // We're trying to read the numeric value\n\t            return $me.autoNumeric('get');\n\t        } else {\n\t            // We're trying to set a value\n\t            var originalVal = value;\n\t            var numericValue = void 0;\n\t\n\t            if (typeof value === 'string') {\n\t                value = value.replace(',', '.');\n\t                numericValue = parseFloat(value, 10);\n\t\n\t                if (isNaN(numericValue)) {\n\t                    throw '\"' + originalVal + '\" is not a number.';\n\t                }\n\t            } else if (typeof value !== 'number') {\n\t                throw 'The type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is not supported.';\n\t            } else {\n\t                numericValue = value;\n\t            }\n\t\n\t            return $me.autoNumeric('set', numericValue);\n\t        }\n\t    };\n\t});\n\t\n\t/**\r\n\t * This exports the interface for the autoNumeric object\r\n\t */\n\texports.default = {\n\t    format: autoFormat,\n\t    unFormat: autoUnFormat,\n\t    getDefaultConfig: getDefaultConfig,\n\t    getLanguages: getLanguages,\n\t    validate: validate, // an.validate(options) : throws if necessary\n\t    areSettingsValid: areSettingsValid };\n\t}.call(window));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// autoNumeric.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 209cfc9fe2f703046b88","/**\r\n *               autoNumeric.js\r\n *\r\n * @version      2.0.12\r\n * @date         2017-04-07 UTC 07:00\r\n *\r\n * @author       Bob Knothe\r\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n *               cf. AUTHORS.md.\r\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n * @since        2009-08-09\r\n *\r\n * @summary      autoNumeric is a library that provides live as-you-type\r\n *               formatting for international numbers and currencies.\r\n *\r\n *               Note : Some functions are borrowed from big.js\r\n * @link         https://github.com/MikeMcl/big.js/\r\n *\r\n * Please report any bugs to https://github.com/autoNumeric/autoNumeric\r\n *\r\n * @license      Released under the MIT License\r\n * @link         http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/* global module, require, define */\r\n\r\n// Functions names for ES6 exports\r\nlet autoFormat;\r\nlet autoUnFormat;\r\nlet getDefaultConfig;\r\nlet getLanguages;\r\nlet validate;\r\nlet areSettingsValid;\r\n\r\n// AutoNumeric default settings\r\n/**\r\n * List of allowed tag on which autoNumeric can be used.\r\n */\r\nconst allowedTagList = [\r\n    'b',\r\n    'caption',\r\n    'cite',\r\n    'code',\r\n    'const',\r\n    'dd',\r\n    'del',\r\n    'div',\r\n    'dfn',\r\n    'dt',\r\n    'em',\r\n    'h1',\r\n    'h2',\r\n    'h3',\r\n    'h4',\r\n    'h5',\r\n    'h6',\r\n    'ins',\r\n    'kdb',\r\n    'label',\r\n    'li',\r\n    'option',\r\n    'output',\r\n    'p',\r\n    'q',\r\n    's',\r\n    'sample',\r\n    'span',\r\n    'strong',\r\n    'td',\r\n    'th',\r\n    'u',\r\n];\r\n\r\n/**\r\n * Defaults options are public - these can be overridden by the following method:\r\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" \">`)\r\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' ' });`)\r\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n */\r\nconst defaultSettings = {\r\n    /* Allowed thousand grouping separator characters :\r\n     * ','      // Comma\r\n     * '.'      // Dot\r\n     * ' '      // Normal space\r\n     * '\\u2009' // Thin-space\r\n     * '\\u202f' // Narrow no-break space\r\n     * '\\u00a0' // No-break space\r\n     * ''       // No separator\r\n     * \"'\"      // Apostrophe\r\n     * ''      // Arabic thousands separator\r\n     * ''      // Dot above\r\n     * Deprecated older option name : aSep\r\n     */\r\n    digitGroupSeparator: ',',\r\n\r\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n     * example if the input value \"$ 1,999.88 suffix\"\r\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n     * Deprecated older option name : nSep\r\n     */\r\n    noSeparatorOnFocus: false,\r\n\r\n    /* Digital grouping for the thousand separator used in Format\r\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n     * Deprecated older option name : dGroup\r\n     */\r\n    digitalGroupSpacing: '3',\r\n\r\n    /* Allowed decimal separator characters :\r\n     * ',' : Comma\r\n     * '.' : Dot\r\n     * '' : Middle-dot\r\n     * '' : Arabic decimal separator\r\n     * '' : Decimal separator key symbol\r\n     * Deprecated older option name : aDec\r\n     */\r\n    decimalCharacter: '.',\r\n\r\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n     * Deprecated older option name : altDec\r\n     */\r\n    decimalCharacterAlternative: null,\r\n\r\n    /* currencySymbol = allowed currency symbol\r\n     * Must be in quotes currencySymbol: \"$\"\r\n     * space to the right of the currency symbol currencySymbol: '$ '\r\n     * space to the left of the currency symbol currencySymbol: ' $'\r\n     * Deprecated older option name : aSign\r\n     */\r\n    currencySymbol: '',\r\n\r\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n     * for prefix currencySymbolPlacement: \"p\" (default)\r\n     * for suffix currencySymbolPlacement: \"s\"\r\n     * Deprecated older option name : pSign\r\n     */\r\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\r\n    currencySymbolPlacement: 'p',\r\n\r\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n     * -1,234.56  => default no options required\r\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n     * Deprecated older option name : pNeg\r\n     */\r\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\r\n    negativePositiveSignPlacement: null,\r\n\r\n\r\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n     * By default, this positive sign is not shown.\r\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n     */\r\n    showPositiveSign: false,\r\n\r\n    /* Additional suffix\r\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n     * Numeric characters and negative sign not allowed'\r\n     * Deprecated older option name : aSuffix\r\n     */\r\n    suffixText: '',\r\n\r\n    /* Override min max limits\r\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n     * Deprecated older option name : oLimits\r\n     */\r\n    overrideMinMaxLimits: null,\r\n\r\n    /* Maximum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be larger than minimumValue\r\n     * Deprecated older option name : vMax\r\n     */\r\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\r\n\r\n    /* Minimum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be smaller than maximumValue\r\n     * Deprecated older option name : vMin\r\n     */\r\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\r\n\r\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n     * Deprecated older option name : mDec\r\n     */\r\n    decimalPlacesOverride: null,\r\n\r\n    /* Expanded decimal places visible when input has focus - example:\r\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n     * the \"get\" method returns the extended decimal places\r\n     * Deprecated older option name : eDec\r\n     */\r\n    decimalPlacesShownOnFocus: null,\r\n\r\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n     */\r\n\r\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n     */\r\n    scaleDivisor: null,\r\n\r\n    /*\r\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n     * Deprecated older option name : scaleDecimal\r\n     */\r\n    scaleDecimalPlaces: null,\r\n\r\n    /*\r\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n     * This is optional too.\r\n     */\r\n    scaleSymbol: null,\r\n\r\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n     * if ie 6 or 7 the value will be saved as a session cookie\r\n     * Deprecated older option name : aStor\r\n     */\r\n    saveValueToSessionStorage: false,\r\n\r\n    /*\r\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n     *                The non-pasted numbers are dropped and therefore not used at all.\r\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n     *\r\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n     *          Only the first number will be used (here '123').\r\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n     */\r\n    //TODO Shouldn't we use `truncate` as the default value?\r\n    onInvalidPaste: 'error',\r\n\r\n    /* method used for rounding\r\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n     * roundingMethod: \"U05\" Rounds up to next .05\r\n     * roundingMethod: \"D05\" Rounds down to next .05\r\n     * Deprecated older option name : mRound\r\n     */\r\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\r\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\r\n    roundingMethod: 'S',\r\n\r\n    /* Allow padding the decimal places with zeros\r\n     * allowDecimalPadding: true - always Pad decimals with zeros\r\n     * allowDecimalPadding: false - does not pad with zeros.\r\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n     *\r\n     * thanks to Jonas Johansson for the suggestion\r\n     * Deprecated older option name : aPad\r\n     */\r\n    allowDecimalPadding: true,\r\n\r\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n     * Those brackets are visible only when the field does NOT have the focus.\r\n     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n     * This option can be of the following values :\r\n     * null, // This is the default value, which deactivate this feature\r\n     * '(,)',\r\n     * '[,]',\r\n     * '<,>' or\r\n     * '{,}'\r\n     * Deprecated older option name : nBracket\r\n     */\r\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\r\n    negativeBracketsTypeOnBlur: null,\r\n\r\n    /* Displayed on empty string \"\"\r\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n     * Deprecated older option name : wEmpty\r\n     */\r\n    emptyInputBehavior: 'focus',\r\n\r\n    /* Controls leading zero behavior\r\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n     * Deprecated older option name : lZero\r\n     */\r\n    leadingZero: 'deny',\r\n\r\n    /* Determine if the default value will be formatted on initialization.\r\n     * true = automatically formats the default value on initialization\r\n     * false = will not format the default value on initialization\r\n     * Deprecated older option name : aForm\r\n     */\r\n    formatOnPageLoad: true,\r\n\r\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n     * Deprecated older option name : sNumber\r\n     */\r\n    selectNumberOnly: false,\r\n\r\n    /* Helper option for ASP.NET postback\r\n     * should be the value of the unformatted default value\r\n     * examples:\r\n     * no default value=\"\" {defaultValueOverride: \"\"}\r\n     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n     * Deprecated older option name : anDefault\r\n     */\r\n    defaultValueOverride: null,\r\n\r\n    /* Removes formatting on submit event\r\n     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n     * review the 'unSet' method for other formats\r\n     * Deprecated older option name : unSetOnSubmit\r\n     */\r\n    unformatOnSubmit: false,\r\n\r\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n     * Deprecated older option name : outputType\r\n     */\r\n    outputFormat: null,\r\n\r\n    /* Defines if warnings should be shown\r\n     * Error handling function\r\n     * true => all warning are shown\r\n     * false => no warnings are shown, only the thrown errors\r\n     * Deprecated older option name : debug\r\n     */\r\n    showWarnings: true,\r\n\r\n    /*\r\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n     */\r\n    failOnUnknownOption: false,\r\n};\r\n\r\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n * //TODO Replace every call to this object with a call to `keyName`\r\n * @deprecated\r\n */\r\nconst keyCode = {\r\n    Backspace:      8,\r\n    Tab:            9,\r\n    Enter:          13,\r\n    Shift:          16,\r\n    Ctrl:           17,\r\n    Alt:            18,\r\n    PauseBreak:     19,\r\n    CapsLock:       20,\r\n    Esc:            27,\r\n    Space:          32,\r\n    PageUp:         33,\r\n    PageDown:       34,\r\n    End:            35,\r\n    Home:           36,\r\n    LeftArrow:      37,\r\n    UpArrow:        38,\r\n    RightArrow:     39,\r\n    DownArrow:      40,\r\n    Insert:         45,\r\n    Delete:         46,\r\n    num0:           48,\r\n    num1:           49,\r\n    num2:           50,\r\n    num3:           51,\r\n    num4:           52,\r\n    num5:           53,\r\n    num6:           54,\r\n    num7:           55,\r\n    num8:           56,\r\n    num9:           57,\r\n    a:              65,\r\n    b:              66,\r\n    c:              67,\r\n    d:              68,\r\n    e:              69,\r\n    f:              70,\r\n    g:              71,\r\n    h:              72,\r\n    i:              73,\r\n    j:              74,\r\n    k:              75,\r\n    l:              76,\r\n    m:              77,\r\n    n:              78,\r\n    o:              79,\r\n    p:              80,\r\n    q:              81,\r\n    r:              82,\r\n    s:              83,\r\n    t:              84,\r\n    u:              85,\r\n    v:              86,\r\n    w:              87,\r\n    x:              88,\r\n    y:              89,\r\n    z:              90,\r\n    Windows:        91,\r\n    RightClick:     93,\r\n    numpad0:        96,\r\n    numpad1:        97,\r\n    numpad2:        98,\r\n    numpad3:        99,\r\n    numpad4:        100,\r\n    numpad5:        101,\r\n    numpad6:        102,\r\n    numpad7:        103,\r\n    numpad8:        104,\r\n    numpad9:        105,\r\n    MultiplyNumpad: 106,\r\n    PlusNumpad:     107,\r\n    MinusNumpad:    109,\r\n    DotNumpad:      110,\r\n    SlashNumpad:    111,\r\n    F1:             112,\r\n    F2:             113,\r\n    F3:             114,\r\n    F4:             115,\r\n    F5:             116,\r\n    F6:             117,\r\n    F7:             118,\r\n    F8:             119,\r\n    F9:             120,\r\n    F10:            121,\r\n    F11:            122,\r\n    F12:            123,\r\n    NumLock:        144,\r\n    ScrollLock:     145,\r\n    MyComputer:     182,\r\n    MyCalculator:   183,\r\n    Semicolon:      186,\r\n    Equal:          187,\r\n    Comma:          188,\r\n    Hyphen:         189,\r\n    Dot:            190,\r\n    Slash:          191,\r\n    Backquote:      192,\r\n    LeftBracket:    219,\r\n    Backslash:      220,\r\n    RightBracket:   221,\r\n    Quote:          222,\r\n    Command:        224,\r\n    AndroidDefault: 229, // Android Chrome returns the same keycode number 229 for all keys pressed\r\n};\r\n\r\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n * Those names are listed here :\r\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n */\r\nconst keyName = {\r\n    // Special values\r\n    Unidentified:   'Unidentified',\r\n\r\n    // Modifier keys\r\n    Alt:            'Alt',\r\n    AltGr:          'AltGraph',\r\n    CapsLock:       'CapsLock', // Under Chrome, e.key is empty for CapsLock\r\n    Ctrl:           'Control',\r\n    Fn:             'Fn',\r\n    FnLock:         'FnLock',\r\n    Hyper:          'Hyper', // 'OS' under Firefox\r\n    Meta:           'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\r\n    Windows:        'Meta', // This is a non-official key name\r\n    Command:        'Meta', // This is a non-official key name\r\n    NumLock:        'NumLock',\r\n    ScrollLock:     'ScrollLock',\r\n    Shift:          'Shift',\r\n    Super:          'Super', // 'OS' under Firefox\r\n    Symbol:         'Symbol',\r\n    SymbolLock:     'SymbolLock',\r\n\r\n    // Whitespace keys\r\n    Enter:          'Enter',\r\n    Tab:            'Tab',\r\n    Space:          ' ', // 'Spacebar' for Firefox <37, and IE9\r\n\r\n    // Navigation keys\r\n    DownArrow:      'ArrowDown', // 'Down' for Firefox <=36, and IE9\r\n    LeftArrow:      'ArrowLeft', // 'Left' for Firefox <=36, and IE9\r\n    RightArrow:     'ArrowRight', // 'Right' for Firefox <=36, and IE9\r\n    UpArrow:        'ArrowUp', // 'Up' for Firefox <=36, and IE9\r\n    End:            'End',\r\n    Home:           'Home',\r\n    PageDown:       'PageDown',\r\n    PageUp:         'PageUp',\r\n\r\n    // Editing keys\r\n    Backspace:      'Backspace',\r\n    Clear:          'Clear',\r\n    Copy:           'Copy',\r\n    CrSel:          'CrSel', // 'Crsel' for Firefox <=36, and IE9\r\n    Cut:            'Cut',\r\n    Delete:         'Delete', // 'Del' for Firefox <=36, and IE9\r\n    EraseEof:       'EraseEof',\r\n    ExSel:          'ExSel', // 'Exsel' for Firefox <=36, and IE9\r\n    Insert:         'Insert',\r\n    Paste:          'Paste',\r\n    Redo:           'Redo',\r\n    Undo:           'Undo',\r\n\r\n    // UI keys\r\n    Accept:         'Accept',\r\n    Again:          'Again',\r\n    Attn:           'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\r\n    Cancel:         'Cancel',\r\n    ContextMenu:    'ContextMenu', // 'Apps' for Firefox <=36, and IE9\r\n    Esc:            'Escape', // 'Esc' for Firefox <=36, and IE9\r\n    Execute:        'Execute',\r\n    Find:           'Find',\r\n    Finish:         'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\r\n    Help:           'Help',\r\n    Pause:          'Pause',\r\n    Play:           'Play',\r\n    Props:          'Props',\r\n    Select:         'Select',\r\n    ZoomIn:         'ZoomIn',\r\n    ZoomOut:        'ZoomOut',\r\n\r\n    // Device keys\r\n    BrightnessDown: 'BrightnessDown',\r\n    BrightnessUp:   'BrightnessUp',\r\n    Eject:          'Eject',\r\n    LogOff:         'LogOff',\r\n    Power:          'Power',\r\n    PowerOff:       'PowerOff',\r\n    PrintScreen:    'PrintScreen',\r\n    Hibernate:      'Hibernate', // 'Unidentified' for Firefox <=37\r\n    Standby:        'Standby', // 'Unidentified' for Firefox <=36, and IE9\r\n    WakeUp:         'WakeUp',\r\n\r\n    // IME and composition keys\r\n    Compose:        'Compose',\r\n    Dead:           'Dead',\r\n\r\n    // Function keys\r\n    F1:             'F1',\r\n    F2:             'F2',\r\n    F3:             'F3',\r\n    F4:             'F4',\r\n    F5:             'F5',\r\n    F6:             'F6',\r\n    F7:             'F7',\r\n    F8:             'F8',\r\n    F9:             'F9',\r\n    F10:            'F10',\r\n    F11:            'F11',\r\n    F12:            'F12',\r\n\r\n    // Document keys\r\n    Print:          'Print',\r\n\r\n    // 'Normal' keys\r\n    num0:           '0',\r\n    num1:           '1',\r\n    num2:           '2',\r\n    num3:           '3',\r\n    num4:           '4',\r\n    num5:           '5',\r\n    num6:           '6',\r\n    num7:           '7',\r\n    num8:           '8',\r\n    num9:           '9',\r\n    numpad0:        '0',\r\n    numpad1:        '1',\r\n    numpad2:        '2',\r\n    numpad3:        '3',\r\n    numpad4:        '4',\r\n    numpad5:        '5',\r\n    numpad6:        '6',\r\n    numpad7:        '7',\r\n    numpad8:        '8',\r\n    numpad9:        '9',\r\n    a:              'a',\r\n    b:              'b',\r\n    c:              'c',\r\n    d:              'd',\r\n    e:              'e',\r\n    f:              'f',\r\n    g:              'g',\r\n    h:              'h',\r\n    i:              'i',\r\n    j:              'j',\r\n    k:              'k',\r\n    l:              'l',\r\n    m:              'm',\r\n    n:              'n',\r\n    o:              'o',\r\n    p:              'p',\r\n    q:              'q',\r\n    r:              'r',\r\n    s:              's',\r\n    t:              't',\r\n    u:              'u',\r\n    v:              'v',\r\n    w:              'w',\r\n    x:              'x',\r\n    y:              'y',\r\n    z:              'z',\r\n    MultiplyNumpad: '*',\r\n    PlusNumpad:     '+',\r\n    MinusNumpad:    '-',\r\n    DotNumpad:      '.',\r\n    SlashNumpad:    '/',\r\n    Semicolon:      ';',\r\n    Equal:          '=',\r\n    Comma:          ',',\r\n    Hyphen:         '-',\r\n    Minus:          '-',\r\n    Plus:           '+',\r\n    Dot:            '.',\r\n    Slash:          '/',\r\n    Backquote:      '`',\r\n    LeftBracket:    '[',\r\n    RightBracket:   ']',\r\n    Backslash:      '\\\\',\r\n    Quote:          \"'\",\r\n    NumpadDot:      '.',\r\n    NumpadDotAlt:   ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\r\n    NumpadMultiply: '*',\r\n    NumpadPlus:     '+',\r\n    NumpadMinus:    '-',\r\n    NumpadSlash:    '/',\r\n    NumpadDotObsoleteBrowsers:      'Decimal',\r\n    NumpadMultiplyObsoleteBrowsers: 'Multiply',\r\n    NumpadPlusObsoleteBrowsers:     'Add',\r\n    NumpadMinusObsoleteBrowsers:    'Subtract',\r\n    NumpadSlashObsoleteBrowsers:    'Divide',\r\n};\r\n\r\nconst defaultMinimumValue     = '-999999999999.99';\r\nconst defaultMaximumValue     = '999999999999.99';\r\nconst defaultRoundingMethod   = 'U';\r\nconst defaultLeadingZero      = 'deny';\r\nconst defaultSelectNumberOnly = true;\r\n\r\n/**\r\n * Predefined options for the most common languages\r\n */\r\nconst languageOption = {\r\n    French: { // Franais\r\n        digitGroupSeparator        : '.', // or '\\u202f'\r\n        decimalCharacter           : ',',\r\n        decimalCharacterAlternative: '.',\r\n        currencySymbol             : '\\u202f',\r\n        currencySymbolPlacement    : 's',\r\n        selectNumberOnly           : defaultSelectNumberOnly,\r\n        roundingMethod             : defaultRoundingMethod,\r\n        leadingZero                : defaultLeadingZero,\r\n        minimumValue               : defaultMinimumValue,\r\n        maximumValue               : defaultMaximumValue,\r\n    },\r\n    NorthAmerican: {\r\n        digitGroupSeparator    : ',',\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '$',\r\n        currencySymbolPlacement: 'p',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    British: {\r\n        digitGroupSeparator    : ',',\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '',\r\n        currencySymbolPlacement: 'p',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    Swiss: { // Suisse\r\n        digitGroupSeparator    : `'`,\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '\\u202fCHF',\r\n        currencySymbolPlacement: 's',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    Japanese: { // \r\n        digitGroupSeparator    : ',',\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '',\r\n        currencySymbolPlacement: 'p',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    Turkish: {\r\n        digitGroupSeparator: '.',\r\n        decimalCharacter: ',',\r\n        decimalCharacterAlternative: '.',\r\n        currencySymbol: '',\r\n        currencySymbolPlacement: 's',\r\n        selectNumberOnly: defaultSelectNumberOnly,\r\n        roundingMethod: defaultRoundingMethod,\r\n        leadingZero: defaultLeadingZero,\r\n        minimumValue: defaultMinimumValue,\r\n        maximumValue: defaultMaximumValue,\r\n        negativePositiveSignPlacement: 'p',\r\n    },\r\n};\r\nlanguageOption.Spanish = languageOption.French; // Espaol (idem French)\r\nlanguageOption.Chinese = languageOption.Japanese; //  (Chinese)\r\n\r\n/**\r\n * UMD structure\r\n */\r\n(function(factory) {\r\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\r\nif (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as an anonymous module.\r\n    define(['jquery'], factory);\r\n} else if (typeof module === 'object' && module.exports) {\r\n        // Node/CommonJS\r\n    module.exports = factory(require('jquery'));\r\n} else {\r\n        // Browser globals\r\n    factory(window.jQuery);\r\n}\r\n}($ => {\r\n    const jQueryOriginalVal = $.fn.val;\r\n\r\n    // Helper functions\r\n\r\n    /**\r\n     * Return TRUE if the `value` is null\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n     */\r\n    function isNull(value) {\r\n        return value === null;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n     */\r\n    function isUndefined(value) {\r\n        return value === void(0);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\r\n    function isUndefinedOrNullOrEmpty(value) {\r\n        return value === null || value === void(0) || '' === value;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given parameter is a String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\r\n    function isString(str) {\r\n        return (typeof str === 'string' || str instanceof String);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a boolean\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\r\n    function isBoolean(value) {\r\n        return typeof(value) === 'boolean';\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a string 'true' or 'false'\r\n     *\r\n     * This function accepts any cases for those strings.\r\n     * @param {string} value\r\n     * @returns {boolean}\r\n     */\r\n    function isTrueOrFalseString(value) {\r\n        const lowercaseValue = String(value).toLowerCase();\r\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is an object\r\n     *\r\n     * @param {*} reference\r\n     * @returns {boolean}\r\n     */\r\n    function isObject(reference) {\r\n        return typeof reference === 'object' && reference !== null && !Array.isArray(reference);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given object is empty\r\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n     *\r\n     * @param {object} obj\r\n     * @returns {boolean}\r\n     */\r\n    function isEmptyObj(obj) {\r\n        for (const prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a number (or a number written as a string).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\r\n    function isNumber(n) {\r\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is an integer (and not a float).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\r\n    function isInt(n) {\r\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\r\n    }\r\n\r\n    /**\r\n     * Return the pasted text that will be used.\r\n     *\r\n     * @param {string} text\r\n     * @param {AutoNumericHolder} holder\r\n     * @returns {string|void|XML|*}\r\n     */\r\n    function preparePastedText(text, holder) {\r\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\r\n    }\r\n\r\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\r\n    function contains(str, needle) {\r\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\r\n            return false;\r\n        }\r\n\r\n        return str.indexOf(needle) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {*} needle\r\n     * @param {Array} array\r\n     * @returns {boolean}\r\n     */\r\n    function isInArray(needle, array) {\r\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\r\n            return false;\r\n        }\r\n\r\n        return array.indexOf(needle) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\r\n    function isArray(arr) {\r\n        if (Object.prototype.toString.call([]) === '[object Array]') { // Make sure an array has a class attribute of [object Array]\r\n            // Test passed, now check if is an Array\r\n            return Array.isArray(arr) || (typeof arr === 'object' && Object.prototype.toString.call(arr) === '[object Array]');\r\n        }\r\n        else {\r\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n     *\r\n     * @param {string} str\r\n     * @returns {boolean}\r\n     */\r\n    // function hasDecimals(str) {\r\n    //     const [, decimalPart] = str.split('.');\r\n    //     return !isUndefined(decimalPart);\r\n    // }\r\n\r\n    /**\r\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n     *\r\n     * @param {string} str\r\n     * @returns {int}\r\n     */\r\n    function decimalPlaces(str) {\r\n        const [, decimalPart] = str.split('.');\r\n        if (!isUndefined(decimalPart)) {\r\n            return decimalPart.length;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Return the code for the key used to generate the given event.\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string|Number}\r\n     */\r\n    function keyCodeNumber(event) {\r\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\r\n        return (typeof event.which === 'undefined')?event.keyCode:event.which;\r\n    }\r\n\r\n    /**\r\n     * Return the character from the event key code.\r\n     * @example character(50) => '2'\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string}\r\n     */\r\n    function character(event) {\r\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\r\n            return String.fromCharCode(keyCodeNumber(event));\r\n        } else {\r\n            // Special case for obsolete browsers like IE that return the old names\r\n            let result;\r\n            switch (event.key) {\r\n                case 'Decimal':\r\n                    result = keyName.NumpadDot;\r\n                    break;\r\n                case 'Multiply':\r\n                    result = keyName.NumpadMultiply;\r\n                    break;\r\n                case 'Add':\r\n                    result = keyName.NumpadPlus;\r\n                    break;\r\n                case 'Subtract':\r\n                    result = keyName.NumpadMinus;\r\n                    break;\r\n                case 'Divide':\r\n                    result = keyName.NumpadSlash;\r\n                    break;\r\n                case 'Del':\r\n                    // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401 //FIXME  terminer\r\n                    result = keyName.Dot; // as of version 2.0.8 the character() function is only called on keypress event. The 'Del' does not throw the keypress event.\r\n                    break;\r\n                default:\r\n                    result = event.key;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n     * @returns {boolean}\r\n     */\r\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\r\n        const parsedValue = parseStr(value);\r\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given string contains a negative sign :\r\n     * - everywhere in the string (by default), or\r\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n     *\r\n     * @param {string} numericString A number represented by a string\r\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n     * @returns {boolean}\r\n     */\r\n    function isNegative(numericString, checkEverywhere = true) {\r\n        //TODO Use the `negativeSignCharacter` from the settings here\r\n        if (checkEverywhere) {\r\n            return contains(numericString, '-');\r\n        }\r\n\r\n        return isNegativeStrict(numericString);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n     *\r\n     * @example isNegativeStrict('1234.56')     => false\r\n     * @example isNegativeStrict('1234.56-')    => false\r\n     * @example isNegativeStrict('-1234.56')    => true\r\n     * @example isNegativeStrict('-1,234.56 ') => true\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\r\n    function isNegativeStrict(numericString) {\r\n        //TODO Using the `negativeSignCharacter` from the settings here\r\n        return numericString.charAt(0) === '-';\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 '), or is empty (' ').\r\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\r\n    function isZeroOrHasNoValue(numericString) {\r\n        return !(/[1-9]/g).test(numericString);\r\n    }\r\n\r\n    /**\r\n     * Return the negative version of the value (represented as a string) given as a parameter.\r\n     *\r\n     * @param {string} value\r\n     * @returns {*}\r\n     */\r\n    function setRawNegativeSign(value) {\r\n        if (!isNegativeStrict(value)) {\r\n            return `-${value}`;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n     *\r\n     * @param {string} string\r\n     * @param {int} index\r\n     * @param {string} newCharacter\r\n     * @returns {string}\r\n     */\r\n    function replaceCharAt(string, index, newCharacter) {\r\n        return `${string.substr(0, index)}${newCharacter}${string.substr(index + newCharacter.length)}`;\r\n    }\r\n\r\n    /**\r\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} settings\r\n     * @returns {number}\r\n     */\r\n    function clampToRangeLimits(value, settings) {\r\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\r\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\r\n    }\r\n\r\n    /**\r\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n     *\r\n     * @param {string} formattedNumberString\r\n     * @param {int} caretPosition This must be a positive integer\r\n     * @param {string} decimalCharacter\r\n     * @returns {number}\r\n     */\r\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\r\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\r\n        const numberDotOrNegativeSign = new RegExp(`[0-9${decimalCharacter}-]`); // No need to escape the decimal character here, since it's in `[]`\r\n\r\n        let numberDotAndNegativeSignCount = 0;\r\n        for (let i = 0; i < caretPosition; i++) {\r\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\r\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\r\n                numberDotAndNegativeSignCount++;\r\n            }\r\n        }\r\n\r\n        return numberDotAndNegativeSignCount;\r\n    }\r\n\r\n    /**\r\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n     *\r\n     * @example\r\n     * 1234567|89.01   : position 7 (rawNumberString)\r\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n     *\r\n     * @param {string} rawNumberString\r\n     * @param {int} caretPositionInRawValue\r\n     * @param {string} formattedNumberString\r\n     * @param {string} decimalCharacter\r\n     * @returns {*}\r\n     */\r\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\r\n        const formattedNumberStringSize = formattedNumberString.length;\r\n        const rawNumberStringSize = rawNumberString.length;\r\n\r\n        let formattedNumberStringIndex;\r\n        let rawNumberStringIndex = 0;\r\n        for (formattedNumberStringIndex = 0;\r\n             formattedNumberStringIndex < formattedNumberStringSize &&\r\n             rawNumberStringIndex < rawNumberStringSize &&\r\n             rawNumberStringIndex < caretPositionInRawValue;\r\n             formattedNumberStringIndex++) {\r\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] ||\r\n                (rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter)) {\r\n                rawNumberStringIndex++;\r\n            }\r\n        }\r\n\r\n        return formattedNumberStringIndex;\r\n    }\r\n\r\n    /**\r\n     * Count the number of occurrence of the given character, in the given text.\r\n     *\r\n     * @param {string} character\r\n     * @param {string} text\r\n     * @returns {number}\r\n     */\r\n    function countCharInText(character, text) {\r\n        let charCounter = 0;\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (text[i] === character) {\r\n                charCounter++;\r\n            }\r\n        }\r\n\r\n        return charCounter;\r\n    }\r\n\r\n    /**\r\n     * Return the index that can be used to set the caret position.\r\n     * This takes into account that the position is starting at '0', not 1.\r\n     *\r\n     * @param {int} characterCount\r\n     * @returns {number}\r\n     */\r\n    function convertCharacterCountToIndexPosition(characterCount) {\r\n        return Math.max(characterCount, characterCount - 1);\r\n    }\r\n\r\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @returns {{}}\r\n     */\r\n    function getElementSelection(that) {\r\n        const position = {};\r\n        if (isUndefined(that.selectionStart)) {\r\n            that.focus();\r\n            const select = document.selection.createRange();\r\n            position.length = select.text.length;\r\n            select.moveStart('character', -that.value.length);\r\n            position.end = select.text.length;\r\n            position.start = position.end - position.length;\r\n        } else {\r\n            position.start = that.selectionStart;\r\n            position.end = that.selectionEnd;\r\n            position.length = position.end - position.start;\r\n        }\r\n\r\n        return position;\r\n    }\r\n\r\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @param {int} start\r\n     * @param {int|null} end\r\n     */\r\n    function setElementSelection(that, start, end = null) {\r\n        if (isUndefinedOrNullOrEmpty(end)) {\r\n            end = start;\r\n        }\r\n\r\n        if (isUndefined(that.selectionStart)) {\r\n            that.focus();\r\n            const range = that.createTextRange();\r\n            range.collapse(true);\r\n            range.moveEnd('character', end);\r\n            range.moveStart('character', start);\r\n            range.select();\r\n        } else {\r\n            that.selectionStart = start;\r\n            that.selectionEnd = end;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function that throw error messages\r\n     *\r\n     * @param {string} message\r\n     */\r\n    function throwError(message) {\r\n        throw new Error(message);\r\n    }\r\n\r\n    /**\r\n     * Function that display a warning messages, according to the debug level.\r\n     *\r\n     * @param {string} message\r\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n     */\r\n    function warning(message, showWarning = true) {\r\n        if (showWarning) {\r\n            /* eslint no-console: 0 */\r\n            console.warn(`Warning: ${message}`);\r\n        }\r\n    }\r\n\r\n    // autoNumeric-specific functions\r\n\r\n    /**\r\n     * Run any callbacks found in the settings object.\r\n     * Any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     */\r\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\r\n        // Loops through the settings object (option array) to find the following\r\n        $.each(settings, (k, val) => {\r\n            if (typeof val === 'function') {\r\n                settings[k] = val($this, settings, k);\r\n            } else if (typeof $this.autoNumeric[val] === 'function') {\r\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\r\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n     *\r\n     * @param {string} minimumValue\r\n     * @param {string} maximumValue\r\n     * @returns {number}\r\n     */\r\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\r\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\r\n    }\r\n\r\n    /**\r\n     * Strip all unwanted non-number characters.\r\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} leftOrAll\r\n     * @returns {string|*}\r\n     */\r\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\r\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\r\n        //TODO Refactor this with `convertToNumericString()` if possible?\r\n        if (settings.currencySymbol !== '') {\r\n            // Remove currency sign\r\n            s = s.replace(settings.currencySymbol, '');\r\n        }\r\n        if (settings.suffixText) {\r\n            // Remove suffix\r\n            while (contains(s, settings.suffixText)) {\r\n                s = s.replace(settings.suffixText, '');\r\n            }\r\n        }\r\n\r\n        // First replace anything before digits\r\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\r\n\r\n        if ((settings.negativePositiveSignPlacement === 's' ||\r\n            (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p')) &&\r\n            isNegative(s) &&\r\n            s !== '') {\r\n            settings.trailingNegative = true;\r\n        }\r\n\r\n        // Then replace anything after digits\r\n        s = s.replace(settings.skipLastAutoStrip, '$1');\r\n\r\n        // Then remove any uninteresting characters\r\n        s = s.replace(settings.allowedAutoStrip, '');\r\n        if (settings.decimalCharacterAlternative) {\r\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\r\n        }\r\n\r\n        // Get only number string\r\n        const m = s.match(settings.numRegAutoStrip);\r\n        s = m ? [m[1], m[2], m[3]].join('') : '';\r\n\r\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\r\n            let nSign = '';\r\n            const [integerPart, decimalPart] = s.split(settings.decimalCharacter);\r\n            let modifiedIntegerPart = integerPart;\r\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\r\n                nSign = settings.negativeSignCharacter;\r\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\r\n            }\r\n\r\n            // Strip leading zero on positive value if need\r\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\r\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\r\n            }\r\n\r\n            // Strip leading zero on negative value if need\r\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\r\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\r\n            }\r\n\r\n            s = `${nSign}${modifiedIntegerPart}${isUndefined(decimalPart)?'':settings.decimalCharacter + decimalPart}`;\r\n        }\r\n\r\n        if ((leftOrAll && settings.leadingZero === 'deny') ||\r\n            (!settings.hasFocus && settings.leadingZero === 'allow')) {\r\n            s = s.replace(settings.stripReg, '$1$2');\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Sets or removes brackets on negative values, depending on the focus state.\r\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n     * //TODO Use another object to keep track of internal data that are not settings\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function toggleNegativeBracket(s, settings) {\r\n        if ((settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l') ||\r\n            (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p')) {\r\n            //TODO Split the first and last bracket only once during the settings initialization\r\n            const [firstBracket, lastBracket] = settings.negativeBracketsTypeOnBlur.split(',');\r\n            if (!settings.hasFocus) {\r\n                // Add brackets\r\n                s = s.replace(settings.negativeSignCharacter, '');\r\n                s = firstBracket + s + lastBracket;\r\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\r\n                // Remove brackets\r\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\r\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\r\n                s = s.replace(lastBracket, '');\r\n            }\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n     *\r\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n     * Lastly, it also put the negative sign back to its normal position if needed.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string|void|XML|*}\r\n     */\r\n    function convertToNumericString(s, settings) {\r\n        // Remove the currency symbol\r\n        s = s.replace(settings.currencySymbol, '');\r\n\r\n        // Remove the grouping separators (thousands separators usually)\r\n        s = s.replace(settings.digitGroupSeparator, '');\r\n\r\n        // Replace the decimal character by a dot\r\n        if (settings.decimalCharacter !== '.') {\r\n            s = s.replace(settings.decimalCharacter, '.');\r\n        }\r\n\r\n        // Move the trailing negative sign to the right position, if any\r\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\r\n            s = s.replace('-', '');\r\n            s = '-' + s;\r\n        }\r\n\r\n        // Convert any arabic numbers to latin ones\r\n        const temp = arabicToLatinNumbers(s, true, false, false);\r\n        if (!isNaN(temp)) {\r\n            s = temp.toString();\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n     * See the \"outputFormat\" option definition for more details.\r\n     *\r\n     * @param {string|null} value\r\n     * @param {string} locale\r\n     * @returns {*}\r\n     */\r\n    function toLocale(value, locale) {\r\n        if (isNull(locale) || locale === 'string') {\r\n            return value;\r\n        }\r\n\r\n        let result;\r\n        switch (locale) {\r\n            case 'number':\r\n                result = Number(value);\r\n                break;\r\n            case '.-':\r\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\r\n                break;\r\n            case ',':\r\n            case '-,':\r\n                result = value.replace('.', ',');\r\n                break;\r\n            case ',-':\r\n                result = value.replace('.', ',');\r\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\r\n                break;\r\n            // The default case\r\n            case '.':\r\n            case '-.':\r\n                result = value;\r\n                break;\r\n            default :\r\n                throwError(`The given outputFormat [${locale}] option is not recognized.`);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\r\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\r\n        if (settings.decimalCharacter !== '.') {\r\n            s = s.replace(settings.decimalCharacter, '.');\r\n        }\r\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\r\n            s = s.replace(settings.negativeSignCharacter, '-');\r\n        }\r\n        if (!s.match(/\\d/)) {\r\n            // The default value returned by `get` is not formatted with decimals\r\n            s += '0';\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\r\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\r\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\r\n            s = s.replace('-', settings.negativeSignCharacter);\r\n        }\r\n        if (settings.decimalCharacter !== '.') {\r\n            s = s.replace('.', settings.decimalCharacter);\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Private function to check for empty value\r\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @param {boolean} signOnEmpty\r\n     * @returns {*}\r\n     */\r\n    function checkEmpty(inputValue, settings, signOnEmpty) {\r\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\r\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\r\n                return (settings.negativePositiveSignPlacement === 'l') ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\r\n            }\r\n\r\n            return inputValue;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Modify the input value by adding the group separators, as defined in the settings.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function addGroupSeparators(inputValue, settings) {\r\n        if (settings.strip) {\r\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\r\n        }\r\n\r\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\r\n        if (settings.trailingNegative && !isNegative(inputValue)) {\r\n            inputValue = '-' + inputValue;\r\n        }\r\n\r\n        const empty = checkEmpty(inputValue, settings, true);\r\n        const isValueNegative = isNegative(inputValue);\r\n        const isZero = isZeroOrHasNoValue(inputValue);\r\n        if (isValueNegative) {\r\n            inputValue = inputValue.replace('-', '');\r\n        }\r\n\r\n        if (!isNull(empty)) {\r\n            return empty;\r\n        }\r\n\r\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\r\n        let digitalGroup;\r\n        switch (settings.digitalGroupSpacing) {\r\n            case '2':\r\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\r\n                break;\r\n            case '2s':\r\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\r\n                break;\r\n            case '4':\r\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\r\n                break;\r\n            default :\r\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\r\n        }\r\n\r\n        // Splits the string at the decimal string\r\n        let [integerPart, decimalPart] = inputValue.split(settings.decimalCharacter);\r\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\r\n            [integerPart, decimalPart] = inputValue.split(settings.decimalCharacterAlternative);\r\n        }\r\n\r\n        if (settings.digitGroupSeparator !== '') {\r\n            // Re-inserts the thousand separator via a regular expression\r\n            while (digitalGroup.test(integerPart)) {\r\n                integerPart = integerPart.replace(digitalGroup, `$1${settings.digitGroupSeparator}$2`);\r\n            }\r\n        }\r\n\r\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\r\n            if (decimalPart.length > settings.decimalPlacesOverride) {\r\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\r\n            }\r\n\r\n            // Joins the whole number with the decimal value\r\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\r\n        } else {\r\n            // Otherwise if it's an integer\r\n            inputValue = integerPart;\r\n        }\r\n\r\n        settings.trailingNegative = false;\r\n\r\n        if (settings.currencySymbolPlacement === 'p') {\r\n            if (isValueNegative) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'l':\r\n                        inputValue = `${settings.negativeSignCharacter}${settings.currencySymbol}${inputValue}`;\r\n                        break;\r\n                    case 'r':\r\n                        inputValue = `${settings.currencySymbol}${settings.negativeSignCharacter}${inputValue}`;\r\n                        break;\r\n                    case 's':\r\n                        inputValue = `${settings.currencySymbol}${inputValue}${settings.negativeSignCharacter}`;\r\n                        settings.trailingNegative = true;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else if (settings.showPositiveSign && !isZero) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'l':\r\n                        inputValue = `${settings.positiveSignCharacter}${settings.currencySymbol}${inputValue}`;\r\n                        break;\r\n                    case 'r':\r\n                        inputValue = `${settings.currencySymbol}${settings.positiveSignCharacter}${inputValue}`;\r\n                        break;\r\n                    case 's':\r\n                        inputValue = `${settings.currencySymbol}${inputValue}${settings.positiveSignCharacter}`;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else {\r\n                inputValue = settings.currencySymbol + inputValue;\r\n            }\r\n        }\r\n\r\n        if (settings.currencySymbolPlacement === 's') {\r\n            if (isValueNegative) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'r':\r\n                        inputValue = `${inputValue}${settings.currencySymbol}${settings.negativeSignCharacter}`;\r\n                        settings.trailingNegative = true;\r\n                        break;\r\n                    case 'l':\r\n                        inputValue = `${inputValue}${settings.negativeSignCharacter}${settings.currencySymbol}`;\r\n                        settings.trailingNegative = true;\r\n                        break;\r\n                    case 'p':\r\n                        inputValue = `${settings.negativeSignCharacter}${inputValue}${settings.currencySymbol}`;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else if (settings.showPositiveSign && !isZero) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'r':\r\n                        inputValue = `${inputValue}${settings.currencySymbol}${settings.positiveSignCharacter}`;\r\n                        break;\r\n                    case 'l':\r\n                        inputValue = `${inputValue}${settings.positiveSignCharacter}${settings.currencySymbol}`;\r\n                        break;\r\n                    case 'p':\r\n                        inputValue = `${settings.positiveSignCharacter}${inputValue}${settings.currencySymbol}`;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else {\r\n                inputValue = inputValue + settings.currencySymbol;\r\n            }\r\n        }\r\n\r\n        // Removes the negative sign and places brackets\r\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\r\n            inputValue = toggleNegativeBracket(inputValue, settings);\r\n        }\r\n\r\n        return inputValue + settings.suffixText;\r\n    }\r\n\r\n    /**\r\n     * Truncate not needed zeros\r\n     *\r\n     * @param {string} roundedInputValue\r\n     * @param {int} temporaryDecimalPlacesOverride\r\n     * @returns {void|XML|string|*}\r\n     */\r\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\r\n        let regex;\r\n        switch (temporaryDecimalPlacesOverride) {\r\n            case 0:\r\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\r\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\r\n                break;\r\n            case 1:\r\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\r\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\r\n                break;\r\n            default :\r\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\r\n                regex = new RegExp(`(\\\\.\\\\d{${temporaryDecimalPlacesOverride}}(?:\\\\d*[1-9])?)0*`);\r\n        }\r\n\r\n        // If there are no decimal places, we don't need a decimal point at the end\r\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\r\n        if (temporaryDecimalPlacesOverride === 0) {\r\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\r\n        }\r\n\r\n        return roundedInputValue;\r\n    }\r\n\r\n    /**\r\n     * Round the input value using the rounding method defined in the settings.\r\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n     *\r\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function roundValue(inputValue, settings) {\r\n        inputValue = (inputValue === '') ? '0' : inputValue.toString();\r\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\r\n            switch (settings.roundingMethod) {\r\n                case 'N05':\r\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\r\n                    break;\r\n                case 'U05':\r\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\r\n                    break;\r\n                default :\r\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\r\n            }\r\n\r\n            let result;\r\n            if (!contains(inputValue, '.')) {\r\n                result = inputValue + '.00';\r\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\r\n                result = inputValue + '0';\r\n            } else {\r\n                result = inputValue;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        let ivRounded = '';\r\n        let i = 0;\r\n        let nSign = '';\r\n        let temporaryDecimalPlacesOverride;\r\n\r\n        // sets the truncate zero method\r\n        if (settings.allowDecimalPadding) {\r\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\r\n        } else {\r\n            temporaryDecimalPlacesOverride = 0;\r\n        }\r\n\r\n        // Checks if the inputValue (input Value) is a negative value\r\n        if (isNegativeStrict(inputValue)) {\r\n            nSign = '-';\r\n\r\n            // Removes the negative sign that will be added back later if required\r\n            inputValue = inputValue.replace('-', '');\r\n        }\r\n\r\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\r\n        if (!inputValue.match(/^\\d/)) {\r\n            inputValue = '0' + inputValue;\r\n        }\r\n\r\n        // Determines if the value is equal to zero. If it is, remove the negative sign\r\n        if (Number(inputValue) === 0) {\r\n            nSign = '';\r\n        }\r\n\r\n        // Trims leading zero's as needed\r\n        if ((Number(inputValue) > 0 && settings.leadingZero !== 'keep') || (inputValue.length > 0 && settings.leadingZero === 'allow')) {\r\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\r\n        }\r\n\r\n        const dPos = inputValue.lastIndexOf('.');\r\n        const inputValueHasADot = dPos === -1;\r\n\r\n        // Virtual decimal position\r\n        const vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\r\n\r\n        // Checks decimal places to determine if rounding is required :\r\n        // Check if no rounding is required\r\n        let cDec = (inputValue.length - 1) - vdPos;\r\n\r\n        if (cDec <= settings.decimalPlacesOverride) {\r\n            // Check if we need to pad with zeros\r\n            ivRounded = inputValue;\r\n            if (cDec < temporaryDecimalPlacesOverride) {\r\n                if (inputValueHasADot) {\r\n                    ivRounded += settings.decimalCharacter;\r\n                }\r\n\r\n                let zeros = '000000';\r\n                while (cDec < temporaryDecimalPlacesOverride) {\r\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\r\n                    ivRounded += zeros;\r\n                    cDec += zeros.length;\r\n                }\r\n            } else if (cDec > temporaryDecimalPlacesOverride) {\r\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\r\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\r\n                ivRounded = ivRounded.replace(/\\.$/, '');\r\n            }\r\n\r\n            return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\r\n        }\r\n\r\n        // Rounded length of the string after rounding\r\n        let rLength;\r\n        if (inputValueHasADot) {\r\n            rLength = settings.decimalPlacesOverride - 1;\r\n        } else {\r\n            rLength = settings.decimalPlacesOverride + dPos;\r\n        }\r\n\r\n        const tRound = Number(inputValue.charAt(rLength + 1));\r\n        const odd = (inputValue.charAt(rLength) === '.') ? (inputValue.charAt(rLength - 1) % 2) : (inputValue.charAt(rLength) % 2);\r\n        let ivArray = inputValue.substring(0, rLength + 1).split('');\r\n\r\n        if ((tRound > 4 && settings.roundingMethod === 'S')                  || // Round half up symmetric\r\n            (tRound > 4 && settings.roundingMethod === 'A' && nSign === '')  || // Round half up asymmetric positive values\r\n            (tRound > 5 && settings.roundingMethod === 'A' && nSign === '-') || // Round half up asymmetric negative values\r\n            (tRound > 5 && settings.roundingMethod === 's')                  || // Round half down symmetric\r\n            (tRound > 5 && settings.roundingMethod === 'a' && nSign === '')  || // Round half down asymmetric positive values\r\n            (tRound > 4 && settings.roundingMethod === 'a' && nSign === '-') || // Round half down asymmetric negative values\r\n            (tRound > 5 && settings.roundingMethod === 'B')                  || // Round half even \"Banker's Rounding\"\r\n            (tRound === 5 && settings.roundingMethod === 'B' && odd === 1)   || // Round half even \"Banker's Rounding\"\r\n            (tRound > 0 && settings.roundingMethod === 'C' && nSign === '')  || // Round to ceiling toward positive infinite\r\n            (tRound > 0 && settings.roundingMethod === 'F' && nSign === '-') || // Round to floor toward negative infinite\r\n            (tRound > 0 && settings.roundingMethod === 'U')) {                  // Round up away from zero\r\n            // Round up the last digit if required, and continue until no more 9's are found\r\n            for (i = (ivArray.length - 1); i >= 0; i -= 1) {\r\n                if (ivArray[i] !== '.') {\r\n                    ivArray[i] = +ivArray[i] + 1;\r\n                    if (ivArray[i] < 10) {\r\n                        break;\r\n                    }\r\n\r\n                    if (i > 0) {\r\n                        ivArray[i] = '0';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reconstruct the string, converting any 10's to 0's\r\n        ivArray = ivArray.slice(0, rLength + 1);\r\n\r\n        // Return the rounded value\r\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\r\n\r\n        return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\r\n    }\r\n\r\n    /**\r\n     * Truncates the decimal part of a number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} isPaste\r\n     * @returns {*}\r\n     */\r\n    function truncateDecimal(s, settings, isPaste) {\r\n        s = (isPaste) ? roundValue(s, settings) : s;\r\n\r\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\r\n            const [integerPart, decimalPart] = s.split(settings.decimalCharacter);\r\n\r\n            // truncate decimal part to satisfying length since we would round it anyway\r\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\r\n                if (settings.decimalPlacesOverride > 0) {\r\n                    const modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\r\n                    s = `${integerPart}${settings.decimalCharacter}${modifiedDecimalPart}`;\r\n                } else {\r\n                    s = integerPart;\r\n                }\r\n            }\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {number|string} n A numeric value.\r\n     * @returns {{}}\r\n     */\r\n    function parseStr(n) {\r\n        const x = {}; // A Big number instance.\r\n        let e;\r\n        let i;\r\n        let nL;\r\n        let j;\r\n\r\n        // Minus zero?\r\n        if (n === 0 && 1 / n < 0) {\r\n            n = '-0';\r\n        }\r\n\r\n        // Determine sign. 1 positive, -1 negative\r\n        n = n.toString();\r\n        if (isNegativeStrict(n)) {\r\n            n = n.slice(1);\r\n            x.s = -1;\r\n        } else {\r\n            x.s = 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        e = n.indexOf('.');\r\n        if (e > -1) {\r\n            n = n.replace('.', '');\r\n        }\r\n\r\n        // length of string if no decimal character\r\n        if (e < 0) {\r\n            // Integer\r\n            e = n.length;\r\n        }\r\n\r\n        // Determine leading zeros\r\n        i = (n.search(/[1-9]/i) === -1) ? n.length : n.search(/[1-9]/i);\r\n        nL = n.length;\r\n        if (i === nL) {\r\n            // Zero\r\n            x.e = 0;\r\n            x.c = [0];\r\n        } else {\r\n            // Determine trailing zeros\r\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\r\n                nL -= 1;\r\n            }\r\n            nL -= 1;\r\n\r\n            // Decimal location\r\n            x.e = e - i - 1;\r\n            x.c = [];\r\n\r\n            // Convert string to array of digits without leading/trailing zeros\r\n            for (e = 0; i <= nL; i += 1) {\r\n                x.c[e] = +n.charAt(i);\r\n                e += 1;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings.\r\n     * This uses the parsed strings for the above parseStr function.\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {object} y Big number instance\r\n     * @param {object} x Big number instance\r\n     * @returns {*}\r\n     */\r\n    function testMinMax(y, x) {\r\n        const xc = x.c;\r\n        const yc = y.c;\r\n        let i = x.s;\r\n        let j = y.s;\r\n        let k = x.e;\r\n        let l = y.e;\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n            let result;\r\n            if (!xc[0]) {\r\n                result = !yc[0]?0:-j;\r\n            } else {\r\n                result = i;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Signs differ?\r\n        if (i !== j) {\r\n            return i;\r\n        }\r\n        const xNeg = i < 0;\r\n\r\n        // Compare exponents\r\n        if (k !== l) {\r\n            return (k > l ^ xNeg)?1:-1;\r\n        }\r\n        i = -1;\r\n        k = xc.length;\r\n        l = yc.length;\r\n        j = (k < l) ? k : l;\r\n\r\n        // Compare digit by digit\r\n        for (i += 1; i < j; i += 1) {\r\n            if (xc[i] !== yc[i]) {\r\n                return (xc[i] > yc[i] ^ xNeg)?1:-1;\r\n            }\r\n        }\r\n\r\n        // Compare lengths\r\n        let result;\r\n        if (k === l) {\r\n            result = 0;\r\n        } else {\r\n            result = (k > l ^ xNeg)?1:-1;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check that the number satisfy the format conditions\r\n     * and lays between settings.minimumValue and settings.maximumValue\r\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function checkIfInRangeWithOverrideOption(s, settings) {\r\n        s = s.toString();\r\n        s = s.replace(',', '.');\r\n        const minParse = parseStr(settings.minimumValue);\r\n        const maxParse = parseStr(settings.maximumValue);\r\n        const valParse = parseStr(s);\r\n\r\n        let result;\r\n        switch (settings.overrideMinMaxLimits) {\r\n            case 'floor':\r\n                result = [testMinMax(minParse, valParse) > -1, true];\r\n                break;\r\n            case 'ceiling':\r\n                result = [true, testMinMax(maxParse, valParse) < 1];\r\n                break;\r\n            case 'ignore':\r\n                result = [true, true];\r\n                break;\r\n            default:\r\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Thanks to Anthony & Evan C\r\n     *\r\n     * @param {Element|string} element\r\n     * @returns {*|jQuery|HTMLElement}\r\n     */\r\n    function getCurrentElement(element) {\r\n        /*\r\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n         * for jQuery to be able to parse the selector correctly.\r\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n         */\r\n        if (isString(element)) {\r\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\r\n            element = `#${element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1')}`;\r\n        }\r\n\r\n        return $(element);\r\n    }\r\n\r\n    /**\r\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     * @param {boolean} update\r\n     * @returns {*}\r\n     */\r\n    function getAutoNumericHolder($this, settings, update = false) {\r\n        let data = $this.data('autoNumeric');\r\n        if (!data) {\r\n            data = {};\r\n            $this.data('autoNumeric', data);\r\n        }\r\n\r\n        let holder = data.holder;\r\n        if (update || (isUndefined(holder) && settings)) {\r\n            holder = new AutoNumericHolder($this.get(0), settings);\r\n            data.holder = holder;\r\n        }\r\n\r\n        return holder;\r\n    }\r\n\r\n    /**\r\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function keepAnOriginalSettingsCopy(settings) {\r\n        //TODO Rename the old option names to the new ones\r\n        settings.oDec     = settings.decimalPlacesOverride;\r\n        settings.oPad     = settings.allowDecimalPadding;\r\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\r\n        settings.oSep     = settings.digitGroupSeparator;\r\n        settings.oSign    = settings.currencySymbol;\r\n        settings.oSuffix  = settings.suffixText;\r\n    }\r\n\r\n    /**\r\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n     * This is taken from Quirksmode.\r\n     *\r\n     * @param {string} name\r\n     * @returns {*}\r\n     */\r\n    function readCookie(name) {\r\n        const nameEQ = name + '=';\r\n        const ca = document.cookie.split(';');\r\n        let c = '';\r\n        for (let i = 0; i < ca.length; i += 1) {\r\n            c = ca[i];\r\n            while (c.charAt(0) === ' ') {\r\n                c = c.substring(1, c.length);\r\n            }\r\n            if (c.indexOf(nameEQ) === 0) {\r\n                return c.substring(nameEQ.length, c.length);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test if sessionStorage is supported.\r\n     * This is taken from Modernizr.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function storageTest() {\r\n        const mod = 'modernizr';\r\n        try {\r\n            sessionStorage.setItem(mod, mod);\r\n            sessionStorage.removeItem(mod);\r\n            return true;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\r\n    function cleanLeadingTrailingZeros(value, settings) {\r\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\r\n        if (value === '') {\r\n            return '';\r\n        }\r\n\r\n        // Return '0' if the value is zero\r\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\r\n            return '0';\r\n        }\r\n\r\n        if (settings.leadingZero !== 'keep') {\r\n            // Trim leading zero's - leaves one zero to the left of the decimal point\r\n            value = value.replace(/^(-)?0+(?=\\d)/g,'$1');\r\n\r\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\r\n            if (contains(value, '.')) {\r\n                // Trims trailing zeros after the decimal point\r\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\r\n            }\r\n        }\r\n        // Strips trailing decimal point\r\n        value = value.replace(/\\.$/, '');\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Remove the trailing zeros in the decimal part of a number.\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {*}\r\n     */\r\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\r\n        const [integerPart, decimalPart] = numericString.split('.');\r\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\r\n            return integerPart;\r\n        }\r\n\r\n        const trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\r\n\r\n        let result;\r\n        if (trimmedDecimalPart === '') {\r\n            result = integerPart;\r\n        } else {\r\n            result = `${integerPart}.${trimmedDecimalPart}`;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n     *\r\n     * @param {Element|EventTarget} element\r\n     * @param {object} settings\r\n     * @param {string} action\r\n     * @returns {*}\r\n     */\r\n    function saveValueToPersistentStorage(element, settings, action) {\r\n        if (settings.saveValueToSessionStorage) {\r\n            const storedName = (element.name !== '' && !isUndefined(element.name)) ?`AUTO_${decodeURIComponent(element.name)}` :`AUTO_${element.id}`;\r\n            let date;\r\n            let expires;\r\n\r\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\r\n            if (storageTest() === false) {\r\n                switch (action) {\r\n                    case 'set':\r\n                        document.cookie = `${storedName}=${settings.rawValue}; expires= ; path=/`;\r\n                        break;\r\n                    case 'wipe':\r\n                        date = new Date();\r\n                        date.setTime(date.getTime() + (-1 * 24 * 60 * 60 * 1000));\r\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\r\n                        document.cookie = `${storedName}='' ;${expires}; path=/`;\r\n                        break;\r\n                    case 'get':\r\n                        return readCookie(storedName);\r\n                }\r\n            } else {\r\n                switch (action) {\r\n                    case 'set':\r\n                        sessionStorage.setItem(storedName, settings.rawValue);\r\n                        break;\r\n                    case 'wipe':\r\n                        sessionStorage.removeItem(storedName);\r\n                        break;\r\n                    case 'get':\r\n                        return sessionStorage.getItem(storedName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Holder object for field properties\r\n     */\r\n    class AutoNumericHolder {\r\n        /**\r\n         * Class constructor\r\n         *\r\n         * @param {HTMLElement} that - A reference to the current DOM element\r\n         * @param {object} settings\r\n         */\r\n        constructor(that, settings) {\r\n            this.settings = settings;\r\n            this.that = that;\r\n            this.$that = $(that);\r\n            this.formatted = false;\r\n            this.settingsClone = settings;\r\n            this.value = that.value;\r\n        }\r\n\r\n        /**\r\n         * Update the value and the selection values inside the AutoNumericHolder object.\r\n         * This keeps tracks of the input value, as well as the current selection.\r\n         * This also resets the 'processed' and 'formatted' state.\r\n         *\r\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n         *        this function is called on each event handler.\r\n         *\r\n         * @private\r\n         */\r\n        _updateAutoNumericHolderProperties() {\r\n            this.value = this.that.value;\r\n            this.selection = getElementSelection(this.that);\r\n            this.processed = false;\r\n            this.formatted = false;\r\n        }\r\n\r\n        /**\r\n         * Update the keycode of the key that triggered the given event.\r\n         * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n         *\r\n         * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n         * e.key describe the key name used to trigger the event.\r\n         * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n         * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n         * The key list is described here\r\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n         *\r\n         * @param {Event} e\r\n         * @private\r\n         */\r\n        _updateAutoNumericHolderEventKeycode(e) {\r\n            // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\r\n            this.eventKeyCode = keyCodeNumber(e);\r\n        }\r\n\r\n        /**\r\n         * Set the text selection inside the input with the given start and end position.\r\n         *\r\n         * @param {int} start\r\n         * @param {int} end\r\n         * @param {undefined|boolean} setReal\r\n         * @private\r\n         */\r\n        _setSelection(start, end, setReal) {\r\n            //TODO Modify setReal to be more explicit (and a boolean)\r\n            start = Math.max(start, 0);\r\n            end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\r\n            this.selection = {\r\n                start,\r\n                end,\r\n                length: end - start,\r\n            };\r\n\r\n            if (isUndefined(setReal) || setReal) {\r\n                setElementSelection(this.that, start, end);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the caret position inside the input at the given position.\r\n         *\r\n         * @param {int} pos\r\n         * @param {undefined|boolean} setReal\r\n         * @private\r\n         */\r\n        _setCaretPosition(pos, setReal) {\r\n            //TODO Modify setReal to be more explicit (and a boolean)\r\n            this._setSelection(pos, pos, setReal);\r\n        }\r\n\r\n        /**\r\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n         * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n         *\r\n         * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n         * @private\r\n         */\r\n        _getLeftAndRightPartAroundTheSelection() {\r\n            const value = this.value;\r\n            const left = value.substring(0, this.selection.start);\r\n            const right = value.substring(this.selection.end, value.length);\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n         * Those parts are unformatted (stripped) of any non-numbers characters.\r\n         *\r\n         * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n         * @private\r\n         */\r\n        _getUnformattedLeftAndRightPartAroundTheSelection() {\r\n            const settingsClone = this.settingsClone;\r\n            let [left, right] = this._getLeftAndRightPartAroundTheSelection();\r\n            if (left === '' && right === '') {\r\n                settingsClone.trailingNegative = false;\r\n            }\r\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\r\n            let stripZeros = true;\r\n            if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\r\n                stripZeros = false;\r\n            }\r\n            left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\r\n            right = stripAllNonNumberCharacters(right, this.settingsClone, false);\r\n\r\n            if (settingsClone.trailingNegative && !isNegative(left)) {\r\n                left = '-' + left;\r\n                right = (right === '-') ? '' : right;\r\n                settingsClone.trailingNegative = false;\r\n            }\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Strip parts from excess characters and leading zeros.\r\n         *\r\n         * @param {string} left\r\n         * @param {string} right\r\n         * @returns {[*,*]}\r\n         * @private\r\n         */\r\n        _normalizeParts(left, right) {\r\n            const settingsClone = this.settingsClone;\r\n\r\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\r\n            let stripZeros = true;\r\n            if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\r\n                stripZeros = false;\r\n            }\r\n            left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\r\n\r\n            // If right is not empty and first character is not decimalCharacter\r\n            right = stripAllNonNumberCharacters(right, settingsClone, false);\r\n\r\n            // Prevents multiple leading zeros from being entered\r\n            if (settingsClone.leadingZero === 'deny' &&\r\n                (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) &&\r\n                Number(left) === 0 &&\r\n                !contains(left, settingsClone.decimalCharacter)  && right !== '') {\r\n                left = left.substring(0, left.length - 1);\r\n            }\r\n\r\n            if (settingsClone.trailingNegative && !isNegative(left)) {\r\n                left = '-' + left;\r\n                settingsClone.trailingNegative = false;\r\n            }\r\n\r\n            // Insert zero if has leading dot\r\n            this.newValue = left + right;\r\n            if (settingsClone.decimalCharacter) {\r\n                const m = this.newValue.match(new RegExp(`^${settingsClone.aNegRegAutoStrip}\\\\${settingsClone.decimalCharacter}`));\r\n                if (m) {\r\n                    left = left.replace(m[1], m[1] + '0');\r\n                    this.newValue = left + right;\r\n                }\r\n            }\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n         *\r\n         * @param {string} left\r\n         * @param {string} right\r\n         * @param {boolean} isPaste\r\n         * @returns {boolean}\r\n         * @private\r\n         */\r\n        _setValueParts(left, right, isPaste = false) {\r\n            const settingsClone = this.settingsClone;\r\n            const parts = this._normalizeParts(left, right);\r\n            const [minTest, maxTest] = checkIfInRangeWithOverrideOption(this.newValue, settingsClone);\r\n            let position = parts[0].length;\r\n            this.newValue = parts.join('');\r\n\r\n            if (minTest && maxTest) {\r\n                this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\r\n                //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\r\n                const testValue = (contains(this.newValue, ',')) ? this.newValue.replace(',', '.') : this.newValue;\r\n                if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\r\n                    settingsClone.rawValue = (settingsClone.emptyInputBehavior === 'zero') ? '0' : '';\r\n                } else {\r\n                    settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\r\n                }\r\n\r\n                if (position > this.newValue.length) {\r\n                    position = this.newValue.length;\r\n                }\r\n\r\n                // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\r\n                if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\r\n                    // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\r\n                    if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\r\n                        position = 1;\r\n                    } else {\r\n                        position = 0;\r\n                    }\r\n                }\r\n\r\n                this.value = this.newValue;\r\n                this._setCaretPosition(position, false);\r\n\r\n                return true;\r\n            }\r\n\r\n            if (!minTest) {\r\n                this.$that.trigger('autoNumeric:minExceeded');\r\n            } else if (!maxTest) {\r\n                this.$that.trigger('autoNumeric:maxExceeded');\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Helper function for `_expandSelectionOnSign()`.\r\n         *\r\n         * @returns {*} Sign position of a formatted value\r\n         * @private\r\n         */\r\n        _getSignPosition() {\r\n            const settingsClone = this.settingsClone;\r\n            const currencySymbol = settingsClone.currencySymbol;\r\n            const that = this.that;\r\n\r\n            if (currencySymbol) {\r\n                const currencySymbolLen = currencySymbol.length;\r\n                if (settingsClone.currencySymbolPlacement === 'p') {\r\n                    const hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\r\n                    return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\r\n                }\r\n                const valueLen = that.value.length;\r\n                return [valueLen - currencySymbolLen, valueLen];\r\n            }\r\n\r\n            return [1000, -1];\r\n        }\r\n\r\n        /**\r\n         * Expands selection to cover whole sign\r\n         * Prevents partial deletion/copying/overwriting of a sign\r\n         *\r\n         * @param {undefined|boolean} setReal\r\n         * @private\r\n         */\r\n        _expandSelectionOnSign(setReal) {\r\n            //TODO Modify setReal to be more explicit (and a boolean only)\r\n            //TODO Use array destructuring here to set signPosition to more explicit variables\r\n            const signPosition = this._getSignPosition();\r\n            const selection = this.selection;\r\n\r\n            // If selection catches something except sign and catches only space from sign\r\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\r\n                // Then select without empty space\r\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\r\n                    if (selection.start < signPosition[0]) {\r\n                        this._setSelection(selection.start, signPosition[0], setReal);\r\n                    } else {\r\n                        this._setSelection(signPosition[1], selection.end, setReal);\r\n                    }\r\n                } else {\r\n                    // Else select with whole sign\r\n                    this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Try to strip pasted value to digits\r\n         */\r\n        _checkPaste() {\r\n            if (!isUndefined(this.valuePartsBeforePaste)) {\r\n                const oldParts = this.valuePartsBeforePaste;\r\n                const [left, right] = this._getLeftAndRightPartAroundTheSelection();\r\n\r\n                // Try to strip the pasted value first\r\n                delete this.valuePartsBeforePaste;\r\n\r\n                const modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\r\n                if (!this._setValueParts(modifiedLeftPart, right, true)) {\r\n                    this.value = oldParts.join('');\r\n                    this._setCaretPosition(oldParts[0].length, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Process pasting, cursor moving and skipping of not interesting keys.\r\n         * If this function returns TRUE, then further processing is not performed.\r\n         *\r\n         * @param {Event} e\r\n         * @returns {boolean}\r\n         * @private\r\n         */\r\n        _skipAlways(e) {\r\n            // Catch the ctrl up on ctrl-v\r\n            if (((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste)) || (e.shiftKey && this.eventKeyCode === keyCode.Insert)) {\r\n                //TODO Move this test inside the `onKeyup` handler\r\n                this._checkPaste();\r\n                return false;\r\n            }\r\n\r\n            // Skip all function keys (F1-F12), Windows keys, tab and other special keys\r\n            if ((this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12) ||\r\n                (this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick) ||\r\n                (this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space) ||\r\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\r\n                (this.eventKeyCode < keyCode.Backspace &&\r\n                (e.which === 0 || e.which === this.eventKeyCode)) ||\r\n                this.eventKeyCode === keyCode.NumLock ||\r\n                this.eventKeyCode === keyCode.ScrollLock ||\r\n                this.eventKeyCode === keyCode.Insert ||\r\n                this.eventKeyCode === keyCode.Command) {\r\n                return true;\r\n            }\r\n\r\n            // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\r\n            if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\r\n                if (this.settings.selectNumberOnly) {\r\n                    // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\r\n                    e.preventDefault();\r\n                    const valueLen = this.that.value.length;\r\n                    const currencySymbolLen = this.settings.currencySymbol.length;\r\n                    const negLen = (!isNegative(this.that.value))?0:1;\r\n                    const suffixTextLen = this.settings.suffixText.length;\r\n                    const currencySymbolPlacement = this.settings.currencySymbolPlacement;\r\n                    const negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\r\n\r\n                    let start;\r\n                    if (currencySymbolPlacement === 's') {\r\n                        start = 0;\r\n                    } else {\r\n                        start = (negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0)?currencySymbolLen + 1:currencySymbolLen;\r\n                    }\r\n\r\n                    let end;\r\n                    if (currencySymbolPlacement === 'p') {\r\n                        end = valueLen - suffixTextLen;\r\n                    } else {\r\n                        switch (negativePositiveSignPlacement) {\r\n                            case 'l':\r\n                                end = valueLen - (suffixTextLen + currencySymbolLen);\r\n                                break;\r\n                            case 'r':\r\n                                end = (currencySymbolLen > 0)?valueLen - (currencySymbolLen + negLen + suffixTextLen):valueLen - (currencySymbolLen + suffixTextLen);\r\n                                break;\r\n                            default :\r\n                                end = valueLen - (currencySymbolLen + suffixTextLen);\r\n                        }\r\n                    }\r\n\r\n                    setElementSelection(this.that, start, end);\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\r\n            if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\r\n                if (e.type === 'keydown') {\r\n                    this._expandSelectionOnSign();\r\n                }\r\n\r\n                // Try to prevent wrong paste\r\n                if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\r\n                    if (e.type === 'keydown' || e.type === 'keypress') {\r\n                        if (isUndefined(this.valuePartsBeforePaste)) {\r\n                            this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\r\n                        }\r\n                    } else {\r\n                        this._checkPaste();\r\n                    }\r\n                }\r\n\r\n                return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\r\n            }\r\n\r\n            if (e.ctrlKey || e.metaKey) {\r\n                return true;\r\n            }\r\n\r\n            // Jump over thousand separator\r\n            //TODO Move this test inside the `onKeydown` handler\r\n            if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\r\n                if (e.type === 'keydown' && !e.shiftKey) {\r\n                    if (this.eventKeyCode === keyCode.LeftArrow &&\r\n                        (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator ||\r\n                        this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\r\n                        this._setCaretPosition(this.selection.start - 1);\r\n                    } else if (this.eventKeyCode === keyCode.RightArrow &&\r\n                        (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator ||\r\n                        this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\r\n                        this._setCaretPosition(this.selection.start + 1);\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n\r\n            return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\r\n        }\r\n\r\n        /**\r\n         * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n         *\r\n         * @param {string} left The part on the left of the caret or selection\r\n         * @param {string} right The part on the right of the caret or selection\r\n         * @returns {[string, string]}\r\n         * @private\r\n         */\r\n        _processCharacterDeletionIfTrailingNegativeSign([left, right]) {\r\n            const settingsClone = this.settingsClone;\r\n            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\r\n                if (this.eventKeyCode === keyCode.Backspace) {\r\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '');\r\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\r\n                        left = left.substring(1);\r\n                    } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    }\r\n                } else {\r\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '');\r\n                    if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n                    if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\r\n                        left = left.substring(1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\r\n            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\r\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length);\r\n                if (this.eventKeyCode === keyCode.Backspace) {\r\n                    if (this.selection.start === (this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) && contains(this.value, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1);\r\n                    } else if (left !== '-' && ((this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter)) || !contains(this.value, settingsClone.negativeSignCharacter))) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    }\r\n                } else {\r\n                    if (left[0] === '-') {\r\n                        right = right.substring(1);\r\n                    }\r\n                    if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\r\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length);\r\n                if (this.eventKeyCode === keyCode.Backspace) {\r\n                    if (this.selection.start === (this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length)) {\r\n                        left = left.substring(1);\r\n                    } else if (left !== '-' && this.selection.start <= (this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length)) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    }\r\n                } else {\r\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '');\r\n                    if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1);\r\n                    }\r\n                    right = right.substring(1);\r\n                }\r\n            }\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Process the deletion of characters.\r\n         */\r\n        _processCharacterDeletion() {\r\n            const settingsClone = this.settingsClone;\r\n\r\n            let left;\r\n            let right;\r\n\r\n            if (!this.selection.length) {\r\n                [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n                if (left === '' && right === '') {\r\n                    settingsClone.throwInput = false;\r\n                }\r\n\r\n                if (((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') ||\r\n                    (settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r'))) &&\r\n                    isNegative(this.value)) { //TODO Change `this.value` to `this.that.value`?\r\n                    [left, right] = this._processCharacterDeletionIfTrailingNegativeSign([left, right]);\r\n                } else {\r\n                    if (this.eventKeyCode === keyCode.Backspace) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    } else {\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n                }\r\n            } else {\r\n                this._expandSelectionOnSign(false);\r\n                [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n            }\r\n\r\n            this._setValueParts(left, right);\r\n        }\r\n\r\n        /**\r\n         * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n         * Returns TRUE if the keycode is allowed.\r\n         * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n         *\r\n         * @param {Event|string} eventOrChar The event object, or the character entered (from an android device)\r\n         * @returns {boolean}\r\n         */\r\n        _processCharacterInsertion(eventOrChar) {\r\n            const settingsClone = this.settingsClone;\r\n            let [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n\r\n            let eventCharacter;\r\n            if (isString(eventOrChar)) {\r\n                // Android browsers\r\n                eventCharacter = eventOrChar;\r\n            } else {\r\n                // Normal browsers\r\n                settingsClone.throwInput = true;\r\n\r\n                // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\r\n                eventCharacter = character(eventOrChar);\r\n            }\r\n\r\n            // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\r\n            // Do not allow decimal character if no decimal part allowed\r\n            if (eventCharacter === settingsClone.decimalCharacter ||\r\n                (settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative) ||\r\n                ((eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad)) {\r\n                if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\r\n                    return true;\r\n                }\r\n\r\n                // Do not allow decimal character before negativeSignCharacter character\r\n                if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\r\n                    return true;\r\n                }\r\n\r\n                // Do not allow decimal character if other decimal character present\r\n                if (contains(left, settingsClone.decimalCharacter)) {\r\n                    return true;\r\n                }\r\n\r\n                if (right.indexOf(settingsClone.decimalCharacter) > 0) {\r\n                    return true;\r\n                }\r\n\r\n                if (right.indexOf(settingsClone.decimalCharacter) === 0) {\r\n                    right = right.substr(1);\r\n                }\r\n\r\n                this._setValueParts(left + settingsClone.decimalCharacter, right);\r\n\r\n                return true;\r\n            }\r\n\r\n            // Prevent minus if not allowed\r\n            if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\r\n                if (!settingsClone) {\r\n                    return true;\r\n                }\r\n\r\n                // Caret is always after minus\r\n                if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') || (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p')) {\r\n                    if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\r\n                        left = settingsClone.negativeSignCharacter;\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n\r\n                    // Change number sign, remove part if should\r\n                    if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1, left.length);\r\n                    } else {\r\n                        left = (eventCharacter === '-') ? settingsClone.negativeSignCharacter + left : left;\r\n                    }\r\n                } else {\r\n                    if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\r\n                        left = settingsClone.negativeSignCharacter;\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n\r\n                    // Change number sign, remove part if should\r\n                    if (left.charAt(0) === settingsClone.negativeSignCharacter) {\r\n                        left = left.substring(1, left.length);\r\n                    } else {\r\n                        left = (eventCharacter === '-') ? settingsClone.negativeSignCharacter + left : left;\r\n                    }\r\n                }\r\n\r\n                this._setValueParts(left, right);\r\n\r\n                return true;\r\n            }\r\n\r\n            // If the user tries to insert digit before minus sign\r\n            const eventNumber = Number(eventCharacter);\r\n            if (eventNumber >= 0 && eventNumber <= 9) {\r\n                if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\r\n                    left = settingsClone.negativeSignCharacter;\r\n                    right = right.substring(1, right.length);\r\n                }\r\n\r\n                if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\r\n                    left = settingsClone.negativeSignCharacter + left;\r\n                }\r\n\r\n                this._setValueParts(left + eventCharacter, right);\r\n\r\n                return true;\r\n            }\r\n\r\n            // Prevent any other character\r\n            settingsClone.throwInput = false;\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Formatting of just processed value while keeping the cursor position\r\n         *\r\n         * @param {Event} e\r\n         * @private\r\n         */\r\n        _formatValue(e) {\r\n            const settingsClone = this.settingsClone;\r\n            const leftLength = this.value;\r\n            let [left] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n\r\n            // No grouping separator and no currency sign\r\n            if ((settingsClone.digitGroupSeparator  === '' || (settingsClone.digitGroupSeparator !== ''  && !contains(leftLength, settingsClone.digitGroupSeparator))) &&\r\n                (settingsClone.currencySymbol === '' || (settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol)))) {\r\n                let [subParts] = leftLength.split(settingsClone.decimalCharacter);\r\n                let nSign = '';\r\n                if (isNegative(subParts)) {\r\n                    nSign = '-';\r\n                    subParts = subParts.replace('-', '');\r\n                    left = left.replace('-', '');\r\n                }\r\n\r\n                // Strip leading zero on positive value if needed\r\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\r\n                    left = left.slice(1);\r\n                }\r\n\r\n                // Strip leading zero on negative value if needed\r\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\r\n                    left = left.slice(1);\r\n                }\r\n\r\n                left = nSign + left;\r\n            }\r\n\r\n            const value = addGroupSeparators(this.value, this.settingsClone);\r\n            let position = value.length;\r\n            if (value) {\r\n                // Prepare regexp which searches for cursor position from unformatted left part\r\n                const leftAr = left.split('');\r\n\r\n                // Fixes caret position with trailing minus sign\r\n                if ((settingsClone.negativePositiveSignPlacement === 's' || (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p')) &&\r\n                    leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\r\n                    leftAr.shift();\r\n\r\n                    if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) &&\r\n                        settingsClone.caretFix) {\r\n                        if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\r\n                            leftAr.push('-');\r\n                            settingsClone.caretFix = e.type === 'keydown';\r\n                        }\r\n\r\n                        if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\r\n                            leftAr.push('-');\r\n                            settingsClone.caretFix = e.type === 'keydown';\r\n                        }\r\n\r\n                        if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\r\n                            const signParts = settingsClone.currencySymbol.split('');\r\n                            const escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\r\n                            const escapedParts = [];\r\n                            $.each(signParts, (i, miniParts) => {\r\n                                miniParts = signParts[i];\r\n                                if (isInArray(miniParts, escapeChr)) {\r\n                                    escapedParts.push('\\\\' + miniParts);\r\n                                } else {\r\n                                    escapedParts.push(miniParts);\r\n                                }\r\n                            });\r\n\r\n                            if (this.eventKeyCode === keyCode.Backspace) {\r\n                                escapedParts.push('-');\r\n                            }\r\n\r\n                            // Pushing the escaped sign\r\n                            leftAr.push(escapedParts.join(''));\r\n                            settingsClone.caretFix = e.type === 'keydown';\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < leftAr.length; i++) {\r\n                    if (!leftAr[i].match('\\\\d')) {\r\n                        leftAr[i] = '\\\\' + leftAr[i];\r\n                    }\r\n                }\r\n\r\n                const leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\r\n\r\n                // Search cursor position in formatted value\r\n                const newLeft = value.match(leftReg);\r\n                if (newLeft) {\r\n                    position = newLeft[0].length;\r\n\r\n                    // If the positive sign is shown, calculate the caret position accordingly\r\n                    if (settingsClone.showPositiveSign) {\r\n                        if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\r\n                            position = (newLeft.input.indexOf(settingsClone.currencySymbol) === 1) ? settingsClone.currencySymbol.length + 1 : 1;\r\n                        }\r\n\r\n                        if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\r\n                            position = settingsClone.currencySymbol.length + 1;\r\n                        }\r\n                    }\r\n\r\n                    // If we are just before the sign which is in prefix position\r\n                    if (((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter) || (position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter)) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\r\n                        // Place caret after prefix sign\r\n                        //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\r\n                        position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\r\n                    }\r\n                } else {\r\n                    if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\r\n                        // If we could not find a place for cursor and have a sign as a suffix\r\n                        // Place caret before suffix currency sign\r\n                        position -= settingsClone.currencySymbol.length;\r\n                    }\r\n\r\n                    if (settingsClone.suffixText) {\r\n                        // If we could not find a place for cursor and have a suffix\r\n                        // Place caret before suffix\r\n                        position -= settingsClone.suffixText.length;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Only update the value if it has changed. This prevents modifying the selection, if any.\r\n            if (value !== this.that.value ||\r\n                value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\r\n                this.that.value = value;\r\n                this._setCaretPosition(position);\r\n            }\r\n\r\n            if (settingsClone.androidSelectionStart !== null) {\r\n                // If an Android browser is detected, fix the caret position\r\n                // Unfortunately this does not fix all android browsers, only Android Chrome currently.\r\n                // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\r\n                this._setCaretPosition(settingsClone.androidSelectionStart);\r\n            }\r\n\r\n            this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @param {HTMLElement} that - A reference to the current DOM element\r\n     * @returns {*}\r\n     * @private\r\n     */\r\n    function _getStringOrArray(getArrayBehavior = true, that) {\r\n        const $this = getCurrentElement(that);\r\n        const formIndex = $('form').index($this);\r\n        const allFormElements = $(`form:eq(${formIndex})`)[0];\r\n        const aiIndex = [];\r\n\r\n        // all input index\r\n        const scIndex = [];\r\n\r\n        // successful control index\r\n        const rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\r\n\r\n        // from jQuery serialize method\r\n        const rSubmittable = /^(?:input|select|textarea|keygen)/i;\r\n\r\n        // from jQuery serialize method\r\n        const rCheckableType = /^(?:checkbox|radio)$/i;\r\n        const rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\r\n\r\n        let count = 0;\r\n\r\n        // index of successful elements\r\n        $.each(allFormElements, (i, field) => {\r\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\r\n                scIndex.push(count);\r\n                count++;\r\n            } else {\r\n                scIndex.push(-1);\r\n            }\r\n        });\r\n\r\n        // index of all inputs tags except checkbox\r\n        count = 0;\r\n        $.each(allFormElements, (i, field) => {\r\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\r\n                aiIndex.push(count);\r\n                count++;\r\n            } else {\r\n                aiIndex.push(-1);\r\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\r\n                    count++;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (getArrayBehavior) {\r\n            const formFields = $this.serializeArray();\r\n\r\n            $.each(formFields, (i, field) => {\r\n                const scElement = scIndex.indexOf(i);\r\n\r\n                if (scElement > -1 && aiIndex[scElement] > -1) {\r\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\r\n                    const settings = testInput.data('autoNumeric');\r\n\r\n                    if (typeof settings === 'object') {\r\n                        field.value = testInput.autoNumeric('getLocalized').toString();\r\n                    }\r\n                }\r\n            });\r\n\r\n            return formFields;\r\n        }\r\n        else {\r\n            // getString() behavior\r\n            const formFields = $this.serialize();\r\n            const formParts = formFields.split('&');\r\n\r\n            $.each(formParts, i => {\r\n                const [inputName, inputValue] = formParts[i].split('=');\r\n                const scElement = scIndex.indexOf(i);\r\n\r\n                // If the current element is a valid element\r\n                if (scElement > -1 && aiIndex[scElement] > -1) {\r\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\r\n                    const settings = testInput.data('autoNumeric');\r\n\r\n                    if (typeof settings === 'object') {\r\n                        if (inputValue !== null) {\r\n                            const modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\r\n                            formParts[i] = `${inputName}=${modifiedInputValue}`;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            return formParts.join('&');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'focusin' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onFocusInAndMouseEnter($this, holder, e) {\r\n        const settings = holder.settingsClone;\r\n\r\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\r\n            settings.hasFocus = true;\r\n\r\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\r\n                jQueryOriginalVal.call($this, toggleNegativeBracket(e.target.value, settings));\r\n            }\r\n\r\n            // clean the value to compare to rawValue\r\n            let result = stripAllNonNumberCharacters(e.target.value, settings, true);\r\n            result = convertToNumericString(result, settings);\r\n            result = cleanLeadingTrailingZeros(result, settings);\r\n            if (settings.trailingNegative) {\r\n                result = '-' + result;\r\n            }\r\n\r\n            let roundedValue;\r\n            if (settings.decimalPlacesShownOnFocus) {\r\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\r\n                roundedValue = roundValue(settings.rawValue, settings);\r\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\r\n            } else if (settings.scaleDivisor) {\r\n                settings.decimalPlacesOverride = Number(settings.oDec);\r\n                roundedValue = roundValue(settings.rawValue, settings);\r\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\r\n            } else if (settings.noSeparatorOnFocus) {\r\n                settings.digitGroupSeparator = '';\r\n                settings.currencySymbol = '';\r\n                settings.suffixText = '';\r\n                roundedValue = roundValue(settings.rawValue, settings);\r\n                jQueryOriginalVal.call($this, addGroupSeparators(roundedValue, settings));\r\n            } else if (result !== settings.rawValue) {\r\n                // updates the rawValue\r\n                $this.autoNumeric('set', result);\r\n            }\r\n\r\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\r\n            holder.valueOnFocus = e.target.value;\r\n            holder.lastVal = holder.valueOnFocus;\r\n            const onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\r\n            if ((onEmpty !== null && onEmpty !== '') && settings.emptyInputBehavior === 'focus') {\r\n                jQueryOriginalVal.call($this, onEmpty);\r\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\r\n                    setElementSelection(e.target, 0, 0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'keydown' events.\r\n     * The user just started pushing any key, hence one event is sent.\r\n     *\r\n     * Note :\r\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n     * - keydown\r\n     * - keypress\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * ...when inputting a modifier key (ie. 'ctrl') :\r\n     * - keydown\r\n     * - keyup\r\n     *\r\n     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - change\r\n     * - keyup\r\n     *\r\n     * When a paste is done, the following events are sent :\r\n     * - input (if paste is done with the mouse)\r\n     *\r\n     * - keydown (if paste is done with ctrl+v)\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     * - keyup\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onKeydown(holder, e) {\r\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\r\n        holder._updateAutoNumericHolderEventKeycode(e);\r\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\r\n\r\n        if (holder.that.readOnly) {\r\n            holder.processed = true;\r\n\r\n            return;\r\n        }\r\n\r\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\r\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\r\n            triggerEvent('change', e.target);\r\n            holder.valueOnFocus = e.target.value;\r\n        }\r\n\r\n        holder._updateAutoNumericHolderProperties(e);\r\n\r\n        if (holder._skipAlways(e)) {\r\n            holder.processed = true;\r\n\r\n            return;\r\n        }\r\n\r\n        // Check if the key is a delete/backspace key\r\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\r\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\r\n            holder.processed = true;\r\n            holder._formatValue(e);\r\n\r\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\r\n            if ((e.target.value !== holder.lastVal) && holder.settingsClone.throwInput) {\r\n                // Throw an input event when a character deletion is detected\r\n                triggerEvent('input', e.target);\r\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\r\n            }\r\n\r\n            holder.lastVal = e.target.value;\r\n            holder.settingsClone.throwInput = true;\r\n\r\n            return;\r\n        }\r\n\r\n        holder.formatted = false; //TODO Is this line needed?\r\n    }\r\n\r\n    /**\r\n     * Handler for 'keypress' events.\r\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onKeypress(holder, e) {\r\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\r\n        const eventCharacter = character(e);\r\n\r\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\r\n        if (eventCharacter === keyName.Insert) {\r\n            return;\r\n        }\r\n\r\n        const processed = holder.processed;\r\n        holder._updateAutoNumericHolderProperties(e);\r\n\r\n        if (holder._skipAlways(e)) {\r\n            return;\r\n        }\r\n\r\n        if (processed) {\r\n            e.preventDefault();\r\n\r\n            return;\r\n        }\r\n\r\n        const isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\r\n        if (isCharacterInsertionAllowed) {\r\n            holder._formatValue(e);\r\n            if ((e.target.value !== holder.lastVal) && holder.settingsClone.throwInput) {\r\n                // Throws input event on adding a character\r\n                triggerEvent('input', e.target);\r\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\r\n            }\r\n            else {\r\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) &&\r\n                    (getElementSelection(e.target).start === getElementSelection(e.target).end) &&\r\n                    getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\r\n                    const position = getElementSelection(e.target).start + 1;\r\n                    setElementSelection(e.target, position, position);\r\n                }\r\n                e.preventDefault();\r\n            }\r\n\r\n            holder.lastVal = e.target.value;\r\n            holder.settingsClone.throwInput = true;\r\n\r\n            return;\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        holder.formatted = false;\r\n    }\r\n\r\n    /**\r\n     * Handler for 'input' events.\r\n     * added to support android devices with mobile chrome browsers and others\r\n     * Has the potential to replace the keypress event.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onInput(holder, e) {\r\n        const value = e.target.value;\r\n\r\n        // Fix the caret position on keyup in the `_formatValue()` function\r\n        holder.settings.androidSelectionStart = null;\r\n\r\n        if (holder.eventKeyCode === keyCode.AndroidDefault) {\r\n            // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\r\n            if (value.length > holder.lastVal.length || value.length >= holder.lastVal.length - holder.selection.length) {\r\n                // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\r\n                holder.eventKeyCode = value.charCodeAt(holder.selection.start);\r\n\r\n                // Capture the actual character entered\r\n                const androidCharEntered = value.charAt(holder.selection.start);\r\n\r\n                // Check if the given character should be inserted, and if so, do insert it into the current element value\r\n                const isCharacterInsertionAllowed = holder._processCharacterInsertion(androidCharEntered);\r\n\r\n                if (isCharacterInsertionAllowed) {\r\n                    // Allowed character entered (number, decimal or plus/minus sign)\r\n                    holder._formatValue(e);\r\n\r\n                    // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\r\n                    //TODO Check if this is an Android bug or an autoNumeric one\r\n                    holder.settings.androidSelectionStart = holder.selection.start;\r\n\r\n                    const decimalCharacterPosition = e.target.value.indexOf(holder.settings.decimalCharacter);\r\n                    const hasDecimalCharacter = decimalCharacterPosition === -1;\r\n\r\n                    // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\r\n                    if (androidCharEntered === holder.settings.decimalCharacter ||\r\n                        !hasDecimalCharacter && decimalCharacterPosition < holder.settings.androidSelectionStart) {\r\n                        holder.settings.androidSelectionStart = holder.selection.start + 1;\r\n                    }\r\n\r\n                    if (e.target.value.length > value.length) {\r\n                        // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\r\n                        setElementSelection(e.target, holder.settings.androidSelectionStart, holder.settings.androidSelectionStart);\r\n                    }\r\n\r\n                    holder.lastVal = e.target.value;\r\n\r\n                    return;\r\n                } else {\r\n                    // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\r\n                    e.target.value = holder.lastVal;\r\n                    setElementSelection(e.target, holder.selection.start, holder.selection.end);\r\n                    holder.settings.androidSelectionStart = holder.selection.start;\r\n                }\r\n\r\n                e.preventDefault(); //FIXME How does that affects the normal trigger of the input event?\r\n\r\n                holder.formatted = false;\r\n            } else {\r\n                // Character deleted\r\n                //TODO What about the `Delete` key?\r\n                holder.eventKeyCode = keyCode.Backspace;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'keyup' events.\r\n     * The user just released any key, hence one event is sent.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {object} settings\r\n     * @param {Event} e\r\n     */\r\n    function onKeyup(holder, settings, e) {\r\n        holder._updateAutoNumericHolderProperties(e);\r\n\r\n        const skip = holder._skipAlways(e);\r\n        delete holder.valuePartsBeforePaste;\r\n        const isOnAndroid = holder.settingsClone.androidSelectionStart !== null;\r\n        if (skip && !isOnAndroid || e.target.value === '') {\r\n            return;\r\n        }\r\n\r\n        // Added to properly place the caret when only the currency sign is present\r\n        if (e.target.value === holder.settingsClone.currencySymbol) {\r\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\r\n                setElementSelection(e.target, 0, 0);\r\n            } else {\r\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\r\n            }\r\n        } else if (holder.eventKeyCode === keyCode.Tab) {\r\n            setElementSelection(e.target, 0, e.target.value.length);\r\n        }\r\n\r\n        if ((e.target.value === holder.settingsClone.suffixText) ||\r\n            (holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '')) {\r\n            setElementSelection(e.target, 0, 0);\r\n        }\r\n\r\n        // Saves the extended decimal to preserve the data when navigating away from the page\r\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\r\n            saveValueToPersistentStorage(e.target, settings, 'set');\r\n        }\r\n\r\n        if (!holder.formatted) {\r\n            holder._formatValue(e);\r\n        }\r\n\r\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\r\n        if (e.target.value !== holder.initialValueOnKeydown) {\r\n            triggerEvent('autoNumeric:formatted', e.target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'focusout' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onFocusOutAndMouseLeave($this, holder, e) {\r\n        if (!$this.is(':focus')) {\r\n            let value = e.target.value;\r\n            const origValue = value;\r\n            const settings = holder.settingsClone;\r\n            settings.hasFocus = false;\r\n\r\n            if (settings.saveValueToSessionStorage) {\r\n                saveValueToPersistentStorage(e.target, settings, 'set');\r\n            }\r\n\r\n            if (settings.noSeparatorOnFocus === true) {\r\n                settings.digitGroupSeparator = settings.oSep;\r\n                settings.currencySymbol = settings.oSign;\r\n                settings.suffixText = settings.oSuffix;\r\n            }\r\n\r\n            if (settings.decimalPlacesShownOnFocus !== null) {\r\n                settings.decimalPlacesOverride = settings.oDec;\r\n                settings.allowDecimalPadding = settings.oPad;\r\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\r\n            }\r\n\r\n            value = stripAllNonNumberCharacters(value, settings, true);\r\n\r\n            if (value !== '') {\r\n                if (settings.trailingNegative && !isNegative(value)) {\r\n                    value = '-' + value;\r\n                    settings.trailingNegative = false;\r\n                }\r\n\r\n                const [minTest, maxTest] = checkIfInRangeWithOverrideOption(value, settings);\r\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\r\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\r\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\r\n\r\n                    if (settings.scaleDivisor) {\r\n                        value = value / settings.scaleDivisor;\r\n                        value = value.toString();\r\n                    }\r\n\r\n                    settings.decimalPlacesOverride = (settings.scaleDivisor && settings.scaleDecimalPlaces) ? Number(settings.scaleDecimalPlaces) : settings.decimalPlacesOverride;\r\n                    value = roundValue(value, settings);\r\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\r\n                } else {\r\n                    if (!minTest) {\r\n                        $this.trigger('autoNumeric:minExceeded');\r\n                    }\r\n                    if (!maxTest) {\r\n                        $this.trigger('autoNumeric:maxExceeded');\r\n                    }\r\n\r\n                    value = settings.rawValue;\r\n                }\r\n            } else {\r\n                if (settings.emptyInputBehavior === 'zero') {\r\n                    settings.rawValue = '0';\r\n                    value = roundValue('0', settings);\r\n                } else {\r\n                    settings.rawValue = '';\r\n                }\r\n            }\r\n\r\n            let groupedValue = checkEmpty(value, settings, false);\r\n            if (groupedValue === null) {\r\n                groupedValue = addGroupSeparators(value, settings);\r\n            }\r\n\r\n            if (groupedValue !== origValue) {\r\n                groupedValue = (settings.scaleSymbol) ? groupedValue + settings.scaleSymbol : groupedValue;\r\n                jQueryOriginalVal.call($this, groupedValue);\r\n            }\r\n\r\n            if (groupedValue !== holder.valueOnFocus) {\r\n                $this.change();\r\n                delete holder.valueOnFocus;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'paste' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onPaste($this, holder, e) {\r\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\r\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\r\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\r\n        e.preventDefault();\r\n\r\n        let rawPastedText = e.clipboardData.getData('text/plain');\r\n\r\n        // 0. Special case if the user has selected all the input text before pasting\r\n        const initialFormattedValue = e.target.value;\r\n        const selectionStart = e.target.selectionStart || 0;\r\n        const selectionEnd = e.target.selectionEnd || 0;\r\n        const selectionSize = selectionEnd - selectionStart;\r\n        let isAllInputTextSelected = false;\r\n\r\n        if (selectionSize === initialFormattedValue.length) {\r\n            isAllInputTextSelected = true;\r\n        }\r\n\r\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\r\n        const isPasteNegative = isNegativeStrict(rawPastedText);\r\n        if (isPasteNegative) {\r\n            // 1a. Remove the negative sign from the pasted text\r\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\r\n        }\r\n\r\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\r\n        const untranslatedPastedText = preparePastedText(rawPastedText, holder);\r\n\r\n        let pastedText;\r\n        if (untranslatedPastedText === '.') {\r\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\r\n            pastedText = '.';\r\n        } else {\r\n            // Normal case\r\n            // Allow pasting arabic numbers\r\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\r\n        }\r\n\r\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\r\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\r\n            if (holder.settings.onInvalidPaste === 'error') {\r\n                //TODO Should we send a warning instead of throwing an error?\r\n                throwError(`The pasted value '${rawPastedText}' is not a valid paste content.`);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // 4. Calculate the paste result\r\n        let caretPositionOnInitialTextAfterPasting;\r\n        let initialUnformattedNumber;\r\n        if (e.target.value === '') {\r\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\r\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\r\n            initialUnformattedNumber = '';\r\n        } else {\r\n            initialUnformattedNumber = $this.autoNumeric('get');\r\n        }\r\n        let isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\r\n        let isPasteNegativeAndInitialValueIsPositive;\r\n        let result;\r\n\r\n        // If the pasted content is negative, then the result will be negative too\r\n        if (isPasteNegative && !isInitialValueNegative) {\r\n            initialUnformattedNumber = `-${initialUnformattedNumber}`;\r\n            isInitialValueNegative = true;\r\n            isPasteNegativeAndInitialValueIsPositive = true;\r\n        }\r\n        else {\r\n            isPasteNegativeAndInitialValueIsPositive = false;\r\n        }\r\n\r\n        let leftPartContainedADot = false;\r\n        let leftPart;\r\n        let rightPart;\r\n        switch (holder.settings.onInvalidPaste) {\r\n            /* 4a. Truncate paste behavior:\r\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n             * Otherwise paste all the numbers in the clipboard.\r\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n             *\r\n             * 4b. Replace paste behavior:\r\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n             */\r\n            /* eslint no-case-declarations: 0 */\r\n            case 'truncate':\r\n            case 'replace':\r\n                const leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\r\n                const rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\r\n\r\n                if (selectionStart !== selectionEnd) {\r\n                    // a. If there is a selection, remove the selected part, and return the left and right part\r\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\r\n                } else {\r\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\r\n                    result = preparePastedText(initialFormattedValue, holder);\r\n                }\r\n\r\n                // Add back the negative sign if needed\r\n                if (isInitialValueNegative) {\r\n                    result = setRawNegativeSign(result);\r\n                }\r\n\r\n                // Build the unformatted result string\r\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\r\n                if (isPasteNegativeAndInitialValueIsPositive) {\r\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\r\n                    caretPositionOnInitialTextAfterPasting++;\r\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\r\n                }\r\n\r\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\r\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\r\n                if (pastedText === '.') {\r\n                    if (contains(leftPart, '.')) {\r\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\r\n                        // To do so, we keep that info in order to modify the caret position later\r\n                        leftPartContainedADot = true;\r\n                        leftPart = leftPart.replace('.', '');\r\n                    }\r\n                    rightPart = rightPart.replace('.', '');\r\n                }\r\n                // -- Here, we are good to go to continue on the same basis\r\n\r\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\r\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\r\n                const minParse = parseStr(holder.settings.minimumValue);\r\n                const maxParse = parseStr(holder.settings.maximumValue);\r\n                let lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\r\n                let pastedTextIndex = 0;\r\n                let modifiedLeftPart = leftPart;\r\n\r\n                while (pastedTextIndex < pastedText.length) {\r\n                    // Modify the result with another pasted character\r\n                    modifiedLeftPart += pastedText[pastedTextIndex];\r\n                    result = modifiedLeftPart + rightPart;\r\n\r\n                    // Check the range limits\r\n                    if (!checkIfInRange(result, minParse, maxParse)) {\r\n                        // The result is out of the range limits, stop the loop here\r\n                        break;\r\n                    }\r\n\r\n                    // Save the last good known result\r\n                    lastGoodKnownResult = result;\r\n\r\n                    // Update the local variables for the next loop\r\n                    pastedTextIndex++;\r\n                }\r\n\r\n                // Update the last caret position where to insert a new number\r\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\r\n\r\n                //XXX Here we have the result for the `truncate` option\r\n                if (holder.settings.onInvalidPaste === 'truncate') {\r\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\r\n                    result = lastGoodKnownResult;\r\n\r\n                    if (leftPartContainedADot) {\r\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\r\n                        caretPositionOnInitialTextAfterPasting--;\r\n                    }\r\n                    break;\r\n                }\r\n                //XXX ...else we need to continue modifying the result for the 'replace' option\r\n\r\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\r\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\r\n                //    If you do get to the range limits, use the previous known good value within those limits.\r\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\r\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\r\n                let lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\r\n                const lastGoodKnownResultSize = lastGoodKnownResult.length;\r\n\r\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\r\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\r\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\r\n                        lastGoodKnownResultIndex++;\r\n                        continue;\r\n                    }\r\n\r\n                    // This replace one character at a time\r\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\r\n\r\n                    // Check the range limits\r\n                    if (!checkIfInRange(result, minParse, maxParse)) {\r\n                        // The result is out of the range limits, stop the loop here\r\n                        break;\r\n                    }\r\n\r\n                    // Save the last good known result\r\n                    lastGoodKnownResult = result;\r\n\r\n                    // Update the local variables for the next loop\r\n                    pastedTextIndex++;\r\n                    lastGoodKnownResultIndex++;\r\n                }\r\n\r\n                // Update the last caret position where to insert a new number\r\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\r\n\r\n                if (leftPartContainedADot) {\r\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\r\n                    caretPositionOnInitialTextAfterPasting--;\r\n                }\r\n\r\n                result = lastGoodKnownResult;\r\n\r\n                break;\r\n            /* 4c. Normal paste behavior:\r\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n             */\r\n            case 'error':\r\n            case 'ignore':\r\n            case 'clamp':\r\n            default:\r\n                // 1. Generate the unformatted result\r\n                const leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\r\n                const rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\r\n\r\n                if (selectionStart !== selectionEnd) {\r\n                    // a. If there is a selection, remove the selected part, and return the left and right part\r\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\r\n                } else {\r\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\r\n                    result = preparePastedText(initialFormattedValue, holder);\r\n                }\r\n\r\n                // Add back the negative sign if needed\r\n                if (isInitialValueNegative) {\r\n                    result = setRawNegativeSign(result);\r\n                }\r\n\r\n                // Build the unformatted result string\r\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\r\n                if (isPasteNegativeAndInitialValueIsPositive) {\r\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\r\n                    caretPositionOnInitialTextAfterPasting++;\r\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\r\n                }\r\n\r\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\r\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\r\n                if (pastedText === '.') {\r\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\r\n                    if (contains(leftPart, '.')) {\r\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\r\n                        // To do so, we keep that info in order to modify the caret position later\r\n                        leftPartContainedADot = true;\r\n                        leftPart = leftPart.replace('.', '');\r\n                    }\r\n                    rightPart = rightPart.replace('.', '');\r\n                }\r\n                // -- Here, we are good to go to continue on the same basis\r\n\r\n                // Generate the unformatted result\r\n                result = `${leftPart}${pastedText}${rightPart}`;\r\n\r\n                // 2. Calculate the caret position in the unformatted value, for later use\r\n                if (selectionStart === selectionEnd) {\r\n                    // There is no selection, then the caret position is set after the pasted text\r\n                    const indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\r\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\r\n                } else {\r\n                    if (isAllInputTextSelected) {\r\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\r\n                        caretPositionOnInitialTextAfterPasting = result.length;\r\n                    } else if (rightPart === '') {\r\n                        // If the user selected from the caret position to the end of the input (on the far right)\r\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\r\n                    } else {\r\n                        // Normal case\r\n                        const indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\r\n\r\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\r\n                        const selectedText = e.target.value.slice(selectionStart, selectionEnd);\r\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\r\n                    }\r\n                }\r\n\r\n                // Modify the caret position for special cases, only if the whole input has not been selected\r\n                if (!isAllInputTextSelected) {\r\n                    if (isPasteNegativeAndInitialValueIsPositive) {\r\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\r\n                        caretPositionOnInitialTextAfterPasting++;\r\n                    }\r\n\r\n                    if (leftPartContainedADot) {\r\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\r\n                        caretPositionOnInitialTextAfterPasting--;\r\n                    }\r\n                }\r\n        }\r\n\r\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\r\n        if (!isNumber(result) || result === '') {\r\n            if (holder.settings.onInvalidPaste === 'error') {\r\n                throwError(`The pasted value '${rawPastedText}' would result into an invalid content '${result}'.`); //TODO Should we send a warning instead of throwing an error?\r\n                //TODO This is not DRY ; refactor with above\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\r\n        /*\r\n         * If 'error' (this is the default) :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'ignore' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, do nothing more.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'clamp' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n         *        paste result.\r\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n         * If 'truncate' :\r\n         *      - Truncate paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         * If 'replace' :\r\n         *      - Replace paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         */\r\n        let valueHasBeenSet = false;\r\n        let valueHasBeenClamped = false;\r\n        try {\r\n            $this.autoNumeric('set', result);\r\n            valueHasBeenSet = true;\r\n        }\r\n        catch (error) {\r\n            let clampedValue;\r\n            switch (holder.settings.onInvalidPaste) {\r\n                case 'clamp':\r\n                    clampedValue = clampToRangeLimits(result, holder.settings);\r\n                    try {\r\n                        $this.autoNumeric('set', clampedValue);\r\n                    }\r\n                    catch (error) {\r\n                        throwError(`Fatal error: Unable to set the clamped value '${clampedValue}'.`);\r\n                    }\r\n\r\n                    valueHasBeenClamped = true;\r\n                    valueHasBeenSet = true;\r\n                    result = clampedValue; // This is used only for setting the caret position later\r\n                    break;\r\n                case 'error':\r\n                case 'truncate':\r\n                case 'replace':\r\n                    // Throw an error message\r\n                    throwError(`The pasted value '${rawPastedText}' results in a value '${result}' that is outside of the minimum [${holder.settings.minimumValue}] and maximum [${holder.settings.maximumValue}] value range.`);\r\n                // falls through\r\n                case 'ignore':\r\n                // Do nothing\r\n                // falls through\r\n                default :\r\n                    return; // ...and nothing else should be changed\r\n            }\r\n        }\r\n\r\n        // 7. Then lastly, set the caret position at the right logical place\r\n        let caretPositionInFormattedNumber;\r\n        if (valueHasBeenSet) {\r\n            switch (holder.settings.onInvalidPaste) {\r\n                case 'clamp':\r\n                    if (valueHasBeenClamped) {\r\n                        if (holder.settings.currencySymbolPlacement === 's') {\r\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\r\n                        } else {\r\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\r\n                        }\r\n\r\n                        break;\r\n                    } // else if the value has not been clamped, the default behavior is used...\r\n                // falls through\r\n                case 'error':\r\n                case 'ignore':\r\n                case 'truncate':\r\n                case 'replace':\r\n                default :\r\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\r\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\r\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\r\n            }\r\n        }\r\n\r\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\r\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\r\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\r\n            triggerEvent('input', e.target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onBlur(holder, e) {\r\n        if (e.target.value !== holder.valueOnFocus) {\r\n            triggerEvent('change', e.target);\r\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'submit' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     */\r\n    function onSubmit($this, holder) {\r\n        $this.closest('form').on('submit.autoNumeric', () => {\r\n            if (holder) {\r\n                const $settings = holder.settingsClone;\r\n\r\n                if ($settings.unformatOnSubmit) {\r\n                    jQueryOriginalVal.call($this, $settings.rawValue);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @returns {boolean|*}\r\n     */\r\n    function getInputIfSupportedTagAndType($this) {\r\n        // Supported input type\r\n        const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\r\n\r\n        // Checks for non-supported input types\r\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\r\n            throwError(`The input type \"${$this.prop('type')}\" is not supported by autoNumeric`);\r\n        }\r\n\r\n        // Checks for non-supported tags\r\n        const currentElementTag = $this.prop('tagName').toLowerCase();\r\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\r\n            throwError(`The <${currentElementTag}> tag is not supported by autoNumeric`);\r\n        }\r\n\r\n        return $input;\r\n    }\r\n\r\n    /**\r\n     * Formats the default value on page load.\r\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n     *\r\n     * @param {object} settings\r\n     * @param {object} $input jQuery-selected <input> element\r\n     * @param {object} $this jQuery-selected DOM element\r\n     */\r\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\r\n        let setValue = true;\r\n\r\n        if ($input) {\r\n            const currentValue = jQueryOriginalVal.call($this);\r\n            /*\r\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n             *\r\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n             * we should ignore `defaultValueOverride` altogether.\r\n             */\r\n            const unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup oDec\r\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\r\n                // Check if the `value` is valid or not\r\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\r\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\r\n                    setValue = false;\r\n                } else {\r\n                    // If not, inform the developer that nothing usable has been provided\r\n                    throwError(`The value [${currentValue}] used in the input is not a valid value autoNumeric can work with.`);\r\n                }\r\n            } else {\r\n                /* Checks for :\r\n                 * - page reload from back button, and\r\n                 * - ASP.net form post back\r\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                 */\r\n                if ((settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue) ||\r\n                    (settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value')) ||\r\n                    (currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue))) {\r\n                    if ((settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage) ||\r\n                        (settings.scaleDivisor && settings.saveValueToSessionStorage)) {\r\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\r\n                    }\r\n\r\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\r\n                    if (!settings.saveValueToSessionStorage) {\r\n                        let toStrip;\r\n\r\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\r\n                            settings.hasFocus = true;\r\n                            toStrip = toggleNegativeBracket(currentValue, settings);\r\n                        } else {\r\n                            toStrip = currentValue;\r\n                        }\r\n\r\n                        if ((settings.negativePositiveSignPlacement === 's' ||\r\n                            (settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's')) &&\r\n                            settings.negativeSignCharacter !== '' &&\r\n                            isNegative(currentValue)) {\r\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\r\n                        } else {\r\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\r\n                        }\r\n                    }\r\n\r\n                    setValue = false;\r\n                }\r\n            }\r\n\r\n            if (currentValue === '') {\r\n                switch (settings.emptyInputBehavior) {\r\n                    case 'focus':\r\n                        setValue = false;\r\n                        break;\r\n                    case 'always':\r\n                        jQueryOriginalVal.call($this, settings.currencySymbol);\r\n                        setValue = false;\r\n                        break;\r\n                    case 'zero':\r\n                        $this.autoNumeric('set', '0');\r\n                        setValue = false;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else if (setValue && currentValue === $this.attr('value')) {\r\n                $this.autoNumeric('set', currentValue);\r\n            }\r\n        }\r\n\r\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\r\n            if (settings.defaultValueOverride !== null) {\r\n                if (settings.defaultValueOverride === $this.text()) {\r\n                    $this.autoNumeric('set', $this.text());\r\n                }\r\n            } else {\r\n                $this.autoNumeric('set', $this.text());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n     *\r\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function correctNegativePositiveSignPlacementOption(settings) {\r\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\r\n        if (!isNull(settings.negativePositiveSignPlacement)) {\r\n            return;\r\n        }\r\n\r\n        if (!isUndefined(settings) &&\r\n            isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) &&\r\n            !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\r\n            switch (settings.currencySymbolPlacement) {\r\n                case 's':\r\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 \r\n                    break;\r\n                case 'p':\r\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\r\n                    break;\r\n                default :\r\n                //\r\n            }\r\n        } else {\r\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\r\n            settings.negativePositiveSignPlacement = 'l';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function calculateVMinAndVMaxIntegerSizes(settings) {\r\n        let [maximumValueIntegerPart] = settings.maximumValue.toString().split('.');\r\n        let [minimumValueIntegerPart] = (!settings.minimumValue && settings.minimumValue !== 0)?[]:settings.minimumValue.toString().split('.');\r\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\r\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\r\n\r\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\r\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\r\n    }\r\n\r\n    /**\r\n     * Modify `decimalPlacesOverride` as needed\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function correctDecimalPlacesOverrideOption(settings) {\r\n        if (isNull(settings.decimalPlacesOverride)) {\r\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\r\n        }\r\n        settings.oDec = String(settings.decimalPlacesOverride);\r\n\r\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\r\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\r\n    }\r\n\r\n    /**\r\n     * Sets the alternative decimal separator key.\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\r\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\r\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\r\n                settings.decimalCharacterAlternative = ',';\r\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\r\n                settings.decimalCharacterAlternative = '.';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Caches regular expressions for stripAllNonNumberCharacters\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function cachesUsualRegularExpressions(settings) {\r\n        const allNumbersReg = '[0-9]';\r\n        const noAllNumbersReg = '[^0-9]';\r\n\r\n        // Test if there is a negative character in the string\r\n        const aNegReg = settings.negativeSignCharacter?`([-\\\\${settings.negativeSignCharacter}]?)`:'(-?)';\r\n        settings.aNegRegAutoStrip = aNegReg;\r\n\r\n        let negativeSignRegPart;\r\n        if (settings.negativeSignCharacter) {\r\n            negativeSignRegPart = `\\\\${settings.negativeSignCharacter}`;\r\n        } else {\r\n            negativeSignRegPart = '';\r\n        }\r\n        settings.skipFirstAutoStrip = new RegExp(`${aNegReg}[^-${negativeSignRegPart}\\\\${settings.decimalCharacter}${allNumbersReg}].*?(${allNumbersReg}|\\\\${settings.decimalCharacter}${allNumbersReg})`);\r\n        settings.skipLastAutoStrip = new RegExp(`(${allNumbersReg}\\\\${settings.decimalCharacter}?)[^\\\\${settings.decimalCharacter}${allNumbersReg}]${noAllNumbersReg}*$`);\r\n\r\n        const allowed = `-0123456789\\\\${settings.decimalCharacter}`;\r\n        settings.allowedAutoStrip = new RegExp(`[^${allowed}]`, 'g');\r\n        settings.numRegAutoStrip = new RegExp(`${aNegReg}(?:\\\\${settings.decimalCharacter}?(${allNumbersReg}+\\\\${settings.decimalCharacter}${allNumbersReg}+)|(${allNumbersReg}*(?:\\\\${settings.decimalCharacter}${allNumbersReg}*)?))`);\r\n\r\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\r\n        settings.stripReg = new RegExp(`^${settings.aNegRegAutoStrip}0*(${allNumbersReg})`);\r\n    }\r\n\r\n    /**\r\n     * Modify the user settings to make them 'exploitable' later.\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function transformOptionsValuesToDefaultTypes(settings) {\r\n        $.each(settings, (key, value) => {\r\n            // Convert the string 'true' and 'false' to real Boolean\r\n            if (value === 'true' || value === 'false') {\r\n                settings[key] = value === 'true';\r\n            }\r\n\r\n            // Convert numbers in options to strings\r\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\r\n            if (typeof value === 'number' && key !== 'aScale') {\r\n                settings[key] = value.toString();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Convert the old settings options name to new ones.\r\n     *\r\n     * @param {object} options\r\n     */\r\n    function convertOldOptionsToNewOnes(options) {\r\n        //TODO Delete this function once the old options are not used anymore\r\n        const oldOptionsConverter = {\r\n            // Old option name, with their corresponding new option\r\n            aSep                         : 'digitGroupSeparator',\r\n            nSep                         : 'noSeparatorOnFocus',\r\n            dGroup                       : 'digitalGroupSpacing',\r\n            aDec                         : 'decimalCharacter',\r\n            altDec                       : 'decimalCharacterAlternative',\r\n            aSign                        : 'currencySymbol',\r\n            pSign                        : 'currencySymbolPlacement',\r\n            pNeg                         : 'negativePositiveSignPlacement',\r\n            aSuffix                      : 'suffixText',\r\n            oLimits                      : 'overrideMinMaxLimits',\r\n            vMax                         : 'maximumValue',\r\n            vMin                         : 'minimumValue',\r\n            mDec                         : 'decimalPlacesOverride',\r\n            eDec                         : 'decimalPlacesShownOnFocus',\r\n            scaleDecimal                 : 'scaleDecimalPlaces',\r\n            aStor                        : 'saveValueToSessionStorage',\r\n            mRound                       : 'roundingMethod',\r\n            aPad                         : 'allowDecimalPadding',\r\n            nBracket                     : 'negativeBracketsTypeOnBlur',\r\n            wEmpty                       : 'emptyInputBehavior',\r\n            lZero                        : 'leadingZero',\r\n            aForm                        : 'formatOnPageLoad',\r\n            sNumber                      : 'selectNumberOnly',\r\n            anDefault                    : 'defaultValueOverride',\r\n            unSetOnSubmit                : 'unformatOnSubmit',\r\n            outputType                   : 'outputFormat',\r\n            debug                        : 'showWarnings',\r\n            // Current options :\r\n            digitGroupSeparator          : true,\r\n            noSeparatorOnFocus           : true,\r\n            digitalGroupSpacing          : true,\r\n            decimalCharacter             : true,\r\n            decimalCharacterAlternative  : true,\r\n            currencySymbol               : true,\r\n            currencySymbolPlacement      : true,\r\n            negativePositiveSignPlacement: true,\r\n            showPositiveSign             : true,\r\n            suffixText                   : true,\r\n            overrideMinMaxLimits         : true,\r\n            maximumValue                 : true,\r\n            minimumValue                 : true,\r\n            decimalPlacesOverride        : true,\r\n            decimalPlacesShownOnFocus    : true,\r\n            scaleDivisor                 : true,\r\n            scaleDecimalPlaces           : true,\r\n            scaleSymbol                  : true,\r\n            saveValueToSessionStorage    : true,\r\n            onInvalidPaste               : true,\r\n            roundingMethod               : true,\r\n            allowDecimalPadding          : true,\r\n            negativeBracketsTypeOnBlur   : true,\r\n            emptyInputBehavior           : true,\r\n            leadingZero                  : true,\r\n            formatOnPageLoad             : true,\r\n            selectNumberOnly             : true,\r\n            defaultValueOverride         : true,\r\n            unformatOnSubmit             : true,\r\n            outputFormat                 : true,\r\n            showWarnings                 : true,\r\n            failOnUnknownOption          : true,\r\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\r\n            hasFocus             : true,\r\n            runOnce              : true,\r\n            rawValue             : true,\r\n            trailingNegative     : true,\r\n            caretFix             : true,\r\n            throwInput           : true,\r\n            strip                : true,\r\n            tagList              : true,\r\n            negativeSignCharacter: true,\r\n            positiveSignCharacter: true,\r\n            mIntPos              : true,\r\n            mIntNeg              : true,\r\n            oDec                 : true,\r\n            oPad                 : true,\r\n            oBracket             : true,\r\n            oSep                 : true,\r\n            oSign                : true,\r\n            oSuffix              : true,\r\n            aNegRegAutoStrip     : true,\r\n            skipFirstAutoStrip   : true,\r\n            skipLastAutoStrip    : true,\r\n            allowedAutoStrip     : true,\r\n            numRegAutoStrip      : true,\r\n            stripReg             : true,\r\n            holder               : true,\r\n        };\r\n\r\n        for (const option in options) {\r\n            if (options.hasOwnProperty(option)) {\r\n                if (oldOptionsConverter[option] === true) {\r\n                    // If the option is a 'new' option, we continue looping\r\n                    continue;\r\n                }\r\n\r\n                if (oldOptionsConverter.hasOwnProperty(option)) {\r\n                    // Else we have an 'old' option name\r\n                    warning(`You are using the deprecated option name '${option}'. Please use '${oldOptionsConverter[option]}' instead from now on. The old option name will be dropped soon.`, true);\r\n\r\n                    // Then we modify the initial option object to use the new options instead of the old ones\r\n                    options[oldOptionsConverter[option]] = options[option];\r\n                    delete options[option];\r\n                } else if (options.failOnUnknownOption) {\r\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\r\n                    throwError(`Option name '${option}' is unknown. Please fix the options passed to autoNumeric`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n     *\r\n     * @param {object} options\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n     * @returns {object|null}\r\n     */\r\n    function getInitialSettings(options, $this, update = false) {\r\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\r\n        let settings = $this.data('autoNumeric');\r\n\r\n        // If the user used old options, we convert them to new ones\r\n        if (update || !isNull(options)) {\r\n            convertOldOptionsToNewOnes(options);\r\n        }\r\n\r\n        if (update || isUndefined(settings)) {\r\n            if (update) {\r\n                // The settings are updated\r\n                settings = $.extend(settings, options);\r\n            } else {\r\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\r\n                // The settings are generated for the first time\r\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\r\n                const tagData = $this.data();\r\n                settings = $.extend({}, defaultSettings, tagData, options, {\r\n                    hasFocus             : false,\r\n                    runOnce              : false,\r\n                    rawValue             : '',\r\n                    trailingNegative     : false,\r\n                    caretFix             : false,\r\n                    androidSelectionStart: null,\r\n                    throwInput           : true, // Throw input event\r\n                    strip                : true,\r\n                    tagList              : allowedTagList,\r\n                });\r\n            }\r\n\r\n            // Modify the user settings to make them 'exploitable'\r\n            transformOptionsValuesToDefaultTypes(settings);\r\n\r\n            // Improve the `negativePositiveSignPlacement` option if needed\r\n            correctNegativePositiveSignPlacementOption(settings);\r\n\r\n            // Set the negative and positive signs, as needed\r\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\r\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\r\n\r\n            // Additional changes to the settings object (from the original autoCode() function)\r\n            runCallbacksFoundInTheSettingsObject($this, settings);\r\n            calculateVMinAndVMaxIntegerSizes(settings);\r\n            correctDecimalPlacesOverrideOption(settings);\r\n            setsAlternativeDecimalSeparatorCharacter(settings);\r\n            cachesUsualRegularExpressions(settings);\r\n\r\n            // Validate the settings\r\n            validate(settings, false); // Throws if necessary\r\n\r\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\r\n            keepAnOriginalSettingsCopy(settings);\r\n\r\n            // Save our new settings\r\n            $this.data('autoNumeric', settings);\r\n\r\n            return settings;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert the `value` parameter that can either be :\r\n     * - a real number,\r\n     * - a string representing a real number, or\r\n     * - a string representing a localized number (with specific group separators and decimal character),\r\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n     *\r\n     * This function returns `NaN` if such conversion fails.\r\n     *\r\n     * @param {int|float|string} value\r\n     * @param {object} settings\r\n     * @returns {string|NaN}\r\n     */\r\n    function toNumericValue(value, settings) {\r\n        let result;\r\n        if (isNumber(Number(value))) {\r\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\r\n            result = value;\r\n        } else {\r\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\r\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\r\n            result = convertToNumericString(value.toString(), settings);\r\n\r\n            // If the result is still not a numeric string, then we throw a warning\r\n            if (!isNumber(Number(result))) {\r\n                warning(`The value \"${value}\" being \"set\" is not numeric and therefore cannot be used appropriately.`, settings.showWarnings);\r\n                result = NaN;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\r\n    const methods = {\r\n        /**\r\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n         */\r\n        init(options) {\r\n            return this.each(function() {\r\n                const $this = $(this);\r\n                const $input = getInputIfSupportedTagAndType($this);\r\n\r\n                const settings = getInitialSettings(options, $this, false);\r\n                if (isNull(settings)) {\r\n                    return this;\r\n                }\r\n\r\n                // Create the AutoNumericHolder object that store the field properties\r\n                const holder = getAutoNumericHolder($this, settings, false);\r\n\r\n                if (!settings.runOnce && settings.formatOnPageLoad) {\r\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\r\n                }\r\n\r\n                settings.runOnce = true;\r\n\r\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\r\n                if ($input && $this.data('initialized') !== true) {\r\n                    const eventHandlers = {\r\n                        onFocusInAndMouseEnter: e => { onFocusInAndMouseEnter($this, holder, e); },\r\n                        onFocusOutAndMouseLeave: e => { onFocusOutAndMouseLeave($this, holder, e); },\r\n                        onKeydown: e => { onKeydown(holder, e); },\r\n                        onKeypress: e => { onKeypress(holder, e); },\r\n                        onInput: e => { onInput(holder, e); },\r\n                        onKeyup: e => { onKeyup(holder, settings, e); },\r\n                        onBlur: e => { onBlur(holder, e); },\r\n                        onPaste: e => { onPaste($this, holder, e); },\r\n                    };\r\n                    const eventConfigs = [\r\n                        { name: 'focusin', handler: eventHandlers.onFocusInAndMouseEnter },\r\n                        { name: 'mouseenter', handler: eventHandlers.onFocusInAndMouseEnter },\r\n                        { name: 'blur', handler: eventHandlers.onFocusOutAndMouseLeave },\r\n                        { name: 'mouseleave', handler: eventHandlers.onFocusOutAndMouseLeave },\r\n                        { name: 'keydown', handler: eventHandlers.onKeydown },\r\n                        { name: 'keypress', handler: eventHandlers.onKeypress },\r\n                        { name: 'input', handler: eventHandlers.onInput },\r\n                        { name: 'keyup', handler: eventHandlers.onKeyup },\r\n                        { name: 'blur', handler: eventHandlers.onBlur },\r\n                        { name: 'paste', handler: eventHandlers.onPaste },\r\n                    ];\r\n\r\n                    for (const eventConfig of eventConfigs) {\r\n                        this.addEventListener(eventConfig.name, eventConfig.handler, false);\r\n                    }\r\n\r\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\r\n                    \r\n                    $this.data({\r\n                        initialized: true,\r\n                        misc: {\r\n                            removeAllEvents: el => {\r\n                                for (const eventConfig of eventConfigs) {\r\n                                    el.removeEventListener(eventConfig.name, eventConfig.handler, false);\r\n                                }\r\n\r\n                                $(el).closest('form')\r\n                                    .off('.autoNumeric');\r\n                            },\r\n                        },\r\n                    });\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to stop and remove autoNumeric for the current element.\r\n         * Note: this does not remove the formatting.\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n         *\r\n         * @param {Boolean} clearValue If TRUE, then this function clears the text box upon destruction.\r\n         * @returns {*|jQuery}\r\n         */\r\n        destroy(clearValue = false) {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    jQueryOriginalVal.call($this, clearValue === true ? '' : $this.autoNumeric('get'));\r\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\r\n                    $this.data('misc').removeAllEvents(this);\r\n                    $this.removeData('autoNumeric', 'initialized', 'removeAllEvents');\r\n                    $this.off('.autoNumeric');\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        wipe() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    jQueryOriginalVal.call($this, '');\r\n                    settings.rawValue = '';\r\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method that updates the autoNumeric settings.\r\n         * It can be called multiple times if needed.\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|jQuery}\r\n         */\r\n        update(options) {\r\n            return $(this).each(function() {\r\n                // Retrieve the current unformatted input value\r\n                const $this = getCurrentElement(this);\r\n                const strip = $this.autoNumeric('get');\r\n\r\n                // Update the settings\r\n                const settings = getInitialSettings(options, $this, true);\r\n\r\n                // Update the AutoNumericHolder object that store the field properties\r\n                getAutoNumericHolder($this, settings, true);\r\n\r\n                // Reformat the input value with the new settings\r\n                if (jQueryOriginalVal.call($this) !== '' || $this.text() !== '') {\r\n                    return $this.autoNumeric('set', strip);\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         *\r\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n         *\r\n         * @param {*} newValue\r\n         * @returns {*|jQuery}\r\n         */\r\n        set(newValue) {\r\n            return $(this).each(function() {\r\n                if (newValue === null || isUndefined(newValue)) {\r\n                    return;\r\n                }\r\n\r\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings !== 'object') {\r\n                    throwError(`Initializing autoNumeric is required prior to calling the \"set\" method.`);\r\n                }\r\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\r\n                settings.trailingNegative = false;\r\n\r\n                const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\r\n\r\n                let value = toNumericValue(newValue, settings);\r\n                if (isNaN(value)) {\r\n                    return jQueryOriginalVal.call($this, '');\r\n                }\r\n\r\n                if (value !== '') {\r\n                    const [minTest, maxTest] = checkIfInRangeWithOverrideOption(value, settings);\r\n                    // This test is needed by the showPositiveSign option\r\n                    const isZero = isZeroOrHasNoValue(value);\r\n                    if (isZero) {\r\n                        value = '0';\r\n                    }\r\n\r\n                    if (minTest && maxTest) {\r\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\r\n                            // to ensure rounding does not happen twice\r\n                            let hasBeenRounded = false;\r\n\r\n                            // rounds the the extended decimal places\r\n                            let tempDecimal;\r\n                            if (settings.decimalPlacesShownOnFocus) {\r\n                                tempDecimal = settings.decimalPlacesOverride;\r\n                                settings.decimalPlacesOverride = Number(settings.decimalPlacesShownOnFocus);\r\n                                value = roundValue(value, settings);\r\n                                hasBeenRounded = true;\r\n                                settings.decimalPlacesOverride = tempDecimal;\r\n                            }\r\n\r\n                            if (settings.scaleDivisor && !settings.onOff) {\r\n                                value = roundValue(value, settings);\r\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\r\n                                value = toNumericValue(value, settings);\r\n                                value = value / settings.scaleDivisor;\r\n                                value = value.toString();\r\n                                if (settings.scaleDecimalPlaces) {\r\n                                    tempDecimal = settings.decimalPlacesOverride;\r\n                                    settings.decimalPlacesOverride = Number(settings.scaleDecimalPlaces);\r\n                                    value = roundValue(value, settings);\r\n                                    hasBeenRounded = true;\r\n                                }\r\n                            }\r\n\r\n                            // Rounds if this has not been done already\r\n                            if (!hasBeenRounded) {\r\n                                value = roundValue(value, settings);\r\n                            }\r\n\r\n                            // Stores rawValue including the decimalPlacesShownOnFocus\r\n                            if (!settings.scaleDivisor) {\r\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\r\n                            }\r\n\r\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\r\n                            value = addGroupSeparators(value, settings);\r\n\r\n                            if (settings.scaleDivisor && settings.scaleDecimalPlaces && !settings.onOff) {\r\n                                settings.decimalPlacesOverride = tempDecimal;\r\n                            }\r\n                        }\r\n\r\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\r\n                            saveValueToPersistentStorage($this[0], settings, 'set');\r\n                        }\r\n                    } else {\r\n                        settings.rawValue = '';\r\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\r\n                        const attemptedValue = value;\r\n                        value = '';\r\n                        if (!minTest) {\r\n                            $this.trigger('autoNumeric:minExceeded');\r\n                        }\r\n\r\n                        if (!maxTest) {\r\n                            $this.trigger('autoNumeric:maxExceeded');\r\n                        }\r\n\r\n                        throwError(`The value [${attemptedValue}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);\r\n\r\n                        return jQueryOriginalVal.call($this, '');\r\n                    }\r\n                } else {\r\n                    return jQueryOriginalVal.call($this, '');\r\n                }\r\n\r\n                if (!settings.hasFocus && settings.scaleSymbol) {\r\n                    value = value + settings.scaleSymbol;\r\n                }\r\n\r\n                if ($input) {\r\n                    return jQueryOriginalVal.call($this, value);\r\n                }\r\n\r\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\r\n                    return $this.text(value);\r\n                }\r\n\r\n                return false;\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to un-format inputs.\r\n         * This is handy to use right before form submission.\r\n         *\r\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n         * Please see option \"outputFormat\" for more details\r\n         *\r\n         * @example $(someSelector).autoNumeric('unSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        unSet() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    settings.hasFocus = true;\r\n                    jQueryOriginalVal.call($this, $this.autoNumeric('getLocalized'));\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to re-format inputs.\r\n         * This is handy to use right after form submission.\r\n         *\r\n         * This is called after the 'unSet' method to reformat the input\r\n         *\r\n         * @example $(someSelector).autoNumeric('reSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        reSet() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    $this.autoNumeric('set', jQueryOriginalVal.call($this));\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Return the unformatted value as a string.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('get');\r\n         *\r\n         * @returns {string}\r\n         */\r\n        get() {\r\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\r\n            const $this = getCurrentElement(this);\r\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\r\n            const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\r\n            const settings = $this.data('autoNumeric');\r\n            if (typeof settings !== 'object') {\r\n                throwError(`Initializing autoNumeric is required prior to calling the \"get\" method.`);\r\n            }\r\n\r\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\r\n            let value = '';\r\n            if ($input) {\r\n                value = jQueryOriginalVal.call($this.eq(0));\r\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\r\n                value = $this.eq(0).text();\r\n            } else {\r\n                throwError(`The \"<${$this.prop('tagName').toLowerCase()}>\" tag is not supported by autoNumeric`);\r\n            }\r\n\r\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\r\n                value = settings.rawValue;\r\n            } else {\r\n                // Test if the value is negative\r\n                const isValueNegative = isNegative(value);\r\n\r\n                if (!(/\\d/).test(value) && settings.emptyInputBehavior === 'focus') {\r\n                    return '';\r\n                }\r\n\r\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\r\n                    settings.hasFocus = true;\r\n                    value = toggleNegativeBracket(value, settings);\r\n                }\r\n\r\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\r\n                    // Strips trailing negative symbol\r\n                    value = stripAllNonNumberCharacters(value, settings, true);\r\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\r\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\r\n\r\n                    // Places the negative symbol in front of the trailing negative\r\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\r\n                        value = '-' + value;\r\n                    }\r\n                }\r\n\r\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\r\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\r\n                }\r\n            }\r\n\r\n            // Always return a numeric string\r\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\r\n            return trimPaddedZerosFromDecimalPlaces(value);\r\n        },\r\n\r\n        /**\r\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n         * - a plain number (if the setting 'number' is used).\r\n         *\r\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n         * Check the \"outputFormat\" option definition for more details.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getLocalized');\r\n         *\r\n         * @returns {*}\r\n         */\r\n        getLocalized() {\r\n            const $this = getCurrentElement(this);\r\n            let value = $this.autoNumeric('get');\r\n            const settings = $this.data('autoNumeric');\r\n\r\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\r\n                value = '0';\r\n            }\r\n\r\n            return toLocale(value, settings.outputFormat);\r\n        },\r\n\r\n        /**\r\n         * Return the input unformatted value as a real Javascript number.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getNumber');\r\n         *\r\n         * @returns {number}\r\n         */\r\n        getNumber() {\r\n            const $this = getCurrentElement(this);\r\n            const value = $this.autoNumeric('get');\r\n\r\n            return toLocale(value, 'number');\r\n        },\r\n\r\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\r\n        getFormatted() {\r\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\r\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\r\n                throwError('Unable to get the formatted string from the element.');\r\n            }\r\n\r\n            return this[0].value;\r\n        },\r\n\r\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {string}\r\n         */\r\n        getString() {\r\n            return _getStringOrArray(false, this);\r\n        },\r\n\r\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {{}|[]}\r\n         */\r\n        getArray() {\r\n            return _getStringOrArray(true, this);\r\n        },\r\n\r\n        /**\r\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('getSettings');\r\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n         *\r\n         * @returns {object}\r\n         */\r\n        getSettings() {\r\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\r\n            return this.data('autoNumeric');\r\n        },\r\n    };\r\n\r\n    /**\r\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n     * It initialize autoNumeric on the given element.\r\n     *\r\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n     * @param {*} args\r\n     * @returns {*}\r\n     */\r\n    $.fn.autoNumeric = function(method, ...args) {\r\n        if (methods[method]) {\r\n            return methods[method].apply(this, args);\r\n        }\r\n\r\n        if (typeof method === 'object' || !method) {\r\n            // The options have been passed directly, without using a named method\r\n            return methods.init.apply(this, [method]);\r\n        }\r\n\r\n        throwError(`Method \"${method}\" is not supported by autoNumeric`);\r\n    };\r\n\r\n    /**\r\n     * Return the default autoNumeric settings.\r\n     *\r\n     * @returns {object}\r\n     */\r\n    getDefaultConfig = () => defaultSettings;\r\n\r\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\r\n\r\n    /**\r\n     * Return all the predefined language options in one object.\r\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n     *\r\n     * @returns {object}\r\n     */\r\n    getLanguages = () => languageOption;\r\n\r\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\r\n\r\n    /**\r\n     * Public function that allows formatting without an element trigger.\r\n     *\r\n     * @param {number|string} value A number, or a string that represent a javascript number\r\n     * @param {object|null} options\r\n     * @returns {*}\r\n     */\r\n    autoFormat = (value, options = null) => {\r\n        if (isUndefined(value) || value === null) {\r\n            return null;\r\n        }\r\n\r\n        if (!isString(value) && !isNumber(value)) {\r\n            throwError(`The value \"${value}\" being \"set\" is not numeric and therefore cannot be used appropriately.`);\r\n        }\r\n\r\n        // Initiate a very basic settings object\r\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\r\n        if (value < 0) {\r\n            settings.negativeSignCharacter = '-';\r\n        }\r\n\r\n        if (isNull(settings.decimalPlacesOverride)) {\r\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\r\n        }\r\n\r\n        // Check the validity of the `value` parameter\r\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\r\n        let valueString = toNumericValue(value, settings);\r\n        if (isNaN(valueString)) {\r\n            throwError(`The value [${valueString}] that you are trying to format is not a recognized number.`);\r\n        }\r\n\r\n        // Basic tests to check if the given valueString is valid\r\n        const [minTest, maxTest] = checkIfInRangeWithOverrideOption(valueString, settings);\r\n        if (!minTest || !maxTest) {\r\n            // Throw a custom event\r\n            triggerEvent('autoFormat.autoNumeric', document, `Range test failed`);\r\n            throwError(`The value [${valueString}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);\r\n        }\r\n\r\n        // Everything is ok, proceed to rounding, formatting and grouping\r\n        valueString = roundValue(valueString, settings);\r\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\r\n        valueString = addGroupSeparators(valueString, settings);\r\n\r\n        return valueString;\r\n    };\r\n\r\n    $.fn.autoFormat = autoFormat; // The jQuery export\r\n\r\n    /**\r\n     * Public function that allows unformatting without an element.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} options\r\n     * @returns {*}\r\n     */\r\n    autoUnFormat = (value, options) => {\r\n        if (isUndefined(value) || value === null) {\r\n            return null;\r\n        }\r\n\r\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\r\n        if (isNumber(value)) {\r\n            return Number(value);\r\n        }\r\n\r\n        if (isArray(value) || isObject(value)) { //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\r\n            // Check the validity of the `value` parameter\r\n            throwError(`A number or a string representing a number is needed to be able to unformat it, [${value}] given.`);\r\n        }\r\n\r\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\r\n        const allowed = `-0123456789\\\\${settings.decimalCharacter}`;\r\n        const autoStrip = new RegExp(`[^${allowed}]`, 'gi');\r\n        value = value.toString();\r\n\r\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\r\n        if (isNegative(value)) {\r\n            settings.negativeSignCharacter = '-';\r\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\r\n            settings.negativeSignCharacter = '-';\r\n            settings.hasFocus = true;\r\n            value = toggleNegativeBracket(value, settings);\r\n        }\r\n\r\n        value = value.replace(autoStrip, '');\r\n        value = value.replace(settings.decimalCharacter, '.');\r\n        value = toLocale(value, settings.outputFormat);\r\n\r\n        return value;\r\n    };\r\n\r\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\r\n\r\n    /**\r\n     * Validate the given option object.\r\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n     *\r\n     * This tests if the options are not conflicting and are well formatted.\r\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n     *\r\n     * @param {*} userOptions\r\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n     * @throws Error\r\n     */\r\n    validate = (userOptions, shouldExtendDefaultOptions = true) => {\r\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\r\n            throwError(`The userOptions are invalid ; it should be a valid object, [${userOptions}] given.`);\r\n        }\r\n\r\n        // If the user used old options, we convert them to new ones\r\n        if (!isNull(userOptions)) {\r\n            convertOldOptionsToNewOnes(userOptions);\r\n        }\r\n\r\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\r\n        let options;\r\n        if (shouldExtendDefaultOptions) {\r\n            options = $.extend({}, defaultSettings, userOptions);\r\n        } else {\r\n            options = userOptions;\r\n        }\r\n\r\n        // First things first, we test that the `showWarnings` option is valid\r\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\r\n            throwError(`The debug option 'showWarnings' is invalid ; it should be either 'false' or 'true', [${options.showWarnings}] given.`);\r\n        }\r\n\r\n        // Define the regular expressions needed for the following tests\r\n        const testPositiveInteger = /^[0-9]+$/;\r\n        const testNumericalCharacters = /[0-9]+/;\r\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\r\n        const testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\r\n        const testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\r\n\r\n        // Then tests the options individually\r\n        if (!isInArray(options.digitGroupSeparator, [\r\n            ',',      // Comma\r\n            '.',      // Dot\r\n            ' ',      // Normal space\r\n            '\\u2009', // Thin-space\r\n            '\\u202f', // Narrow no-break space\r\n            '\\u00a0', // No-break space\r\n            '',       // No separator\r\n            \"'\",      // Apostrophe\r\n            '',      // Arabic thousands separator\r\n            '',      // Dot above\r\n        ])) {\r\n            throwError(`The thousand separator character option 'digitGroupSeparator' is invalid ; it should be ',', '.', '', '', \"'\", ' ', '\\u2009', '\\u202f', '\\u00a0' or empty (''), [${options.digitGroupSeparator}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\r\n            throwError(`The 'noSeparatorOnFocus' option is invalid ; it should be either 'false' or 'true', [${options.noSeparatorOnFocus}] given.`);\r\n        }\r\n\r\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\r\n            throwError(`The digital grouping for thousand separator option 'digitalGroupSpacing' is invalid ; it should be a positive integer, [${options.digitalGroupSpacing}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.decimalCharacter, [\r\n            ',', // Comma\r\n            '.', // Dot\r\n            '', // Middle-dot\r\n            '', // Arabic decimal separator\r\n            '', // Decimal separator key symbol\r\n        ])) {\r\n            throwError(`The decimal separator character option 'decimalCharacter' is invalid ; it should be '.', ',', '', '' or '', [${options.decimalCharacter}] given.`);\r\n        }\r\n\r\n        // Checks if the decimal and thousand characters are the same\r\n        if (options.decimalCharacter === options.digitGroupSeparator) {\r\n            throwError(`autoNumeric will not function properly when the decimal character 'decimalCharacter' [${options.decimalCharacter}] and the thousand separator 'digitGroupSeparator' [${options.digitGroupSeparator}] are the same character.`);\r\n        }\r\n\r\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\r\n            throwError(`The alternate decimal separator character option 'decimalCharacterAlternative' is invalid ; it should be a string, [${options.decimalCharacterAlternative}] given.`);\r\n        }\r\n\r\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\r\n            throwError(`The currency symbol option 'currencySymbol' is invalid ; it should be a string, [${options.currencySymbol}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\r\n            throwError(`The placement of the currency sign option 'currencySymbolPlacement' is invalid ; it should either be 'p' (prefix) or 's' (suffix), [${options.currencySymbolPlacement}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\r\n            throwError(`The placement of the negative sign option 'negativePositiveSignPlacement' is invalid ; it should either be 'p' (prefix), 's' (suffix), 'l' (left), 'r' (right) or 'null', [${options.negativePositiveSignPlacement}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\r\n            throwError(`The show positive sign option 'showPositiveSign' is invalid ; it should be either 'false' or 'true', [${options.showPositiveSign}] given.`);\r\n        }\r\n\r\n        if (!isString(options.suffixText) || (options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText)))) {\r\n            throwError(`The additional suffix option 'suffixText' is invalid ; it should not contains the negative sign '-' nor any numerical characters, [${options.suffixText}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\r\n            throwError(`The override min & max limits option 'overrideMinMaxLimits' is invalid ; it should either be 'ceiling', 'floor' or 'ignore', [${options.overrideMinMaxLimits}] given.`);\r\n        }\r\n\r\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\r\n            throwError(`The maximum possible value option 'maximumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.maximumValue}] given.`);\r\n        }\r\n\r\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\r\n            throwError(`The minimum possible value option 'minimumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.minimumValue}] given.`);\r\n        }\r\n\r\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\r\n            throwError(`The minimum possible value option is greater than the maximum possible value option ; 'minimumValue' [${options.minimumValue}] should be smaller than 'maximumValue' [${options.maximumValue}].`);\r\n        }\r\n\r\n        if (!(isNull(options.decimalPlacesOverride) ||\r\n            (isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0) || // If integer option\r\n            (isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)))  // If string option\r\n        ) {\r\n            throwError(`The maximum number of decimal places option 'decimalPlacesOverride' is invalid ; it should be a positive integer, [${options.decimalPlacesOverride}] given.`);\r\n        }\r\n\r\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\r\n        const vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\r\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\r\n            warning(`Setting 'decimalPlacesOverride' to [${options.decimalPlacesOverride}] will override the decimals declared in 'minimumValue' [${options.minimumValue}] and 'maximumValue' [${options.maximumValue}].`, options.showWarnings);\r\n        }\r\n\r\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\r\n            warning(`Setting 'allowDecimalPadding' to [false] will override the current 'decimalPlacesOverride' setting [${options.decimalPlacesOverride}].`, options.showWarnings);\r\n        }\r\n\r\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\r\n            throwError(`The number of expanded decimal places option 'decimalPlacesShownOnFocus' is invalid ; it should be a positive integer, [${options.decimalPlacesShownOnFocus}] given.`);\r\n        }\r\n\r\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\r\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\r\n            warning(`The extended decimal places 'decimalPlacesShownOnFocus' [${options.decimalPlacesShownOnFocus}] should be greater than the 'decimalPlacesOverride' [${options.decimalPlacesOverride}] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?`, options.showWarnings);\r\n        }\r\n\r\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\r\n            throwError(`The scale divisor option 'scaleDivisor' is invalid ; it should be a positive number, preferably an integer, [${options.scaleDivisor}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\r\n            throwError(`The scale number of decimals option 'scaleDecimalPlaces' is invalid ; it should be a positive integer, [${options.scaleDecimalPlaces}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\r\n            throwError(`The scale symbol option 'scaleSymbol' is invalid ; it should be a string, [${options.scaleSymbol}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\r\n            throwError(`The save to session storage option 'saveValueToSessionStorage' is invalid ; it should be either 'false' or 'true', [${options.saveValueToSessionStorage}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.onInvalidPaste, [\r\n            'error',\r\n            'ignore',\r\n            'clamp',\r\n            'truncate',\r\n            'replace',\r\n        ])) {\r\n            throwError(`The paste behavior option 'onInvalidPaste' is invalid ; it should either be 'error', 'ignore', 'clamp', 'truncate' or 'replace' (cf. documentation), [${options.onInvalidPaste}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.roundingMethod, [\r\n            'S',\r\n            'A',\r\n            's',\r\n            'a',\r\n            'B',\r\n            'U',\r\n            'D',\r\n            'C',\r\n            'F',\r\n            'N05',\r\n            'CHF',\r\n            'U05',\r\n            'D05',\r\n        ])) {\r\n            throwError(`The rounding method option 'roundingMethod' is invalid ; it should either be 'S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05' or 'D05' (cf. documentation), [${options.roundingMethod}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\r\n            throwError(`The control decimal padding option 'allowDecimalPadding' is invalid ; it should be either 'false' or 'true', [${options.allowDecimalPadding}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\r\n            throwError(`The brackets for negative values option 'negativeBracketsTypeOnBlur' is invalid ; it should either be '(,)', '[,]', '<,>' or '{,}', [${options.negativeBracketsTypeOnBlur}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\r\n            throwError(`The display on empty string option 'emptyInputBehavior' is invalid ; it should either be 'focus', 'press', 'always' or 'zero', [${options.emptyInputBehavior}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\r\n            throwError(`The leading zero behavior option 'leadingZero' is invalid ; it should either be 'allow', 'deny' or 'keep', [${options.leadingZero}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\r\n            throwError(`The format on initialization option 'formatOnPageLoad' is invalid ; it should be either 'false' or 'true', [${options.formatOnPageLoad}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\r\n            throwError(`The select number only option 'selectNumberOnly' is invalid ; it should be either 'false' or 'true', [${options.selectNumberOnly}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.defaultValueOverride) && (options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride))) {\r\n            throwError(`The unformatted default value option 'defaultValueOverride' is invalid ; it should be a string that represents a positive or negative number, [${options.defaultValueOverride}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\r\n            throwError(`The remove formatting on submit option 'unformatOnSubmit' is invalid ; it should be either 'false' or 'true', [${options.unformatOnSubmit}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, [\r\n            'string',\r\n            'number',\r\n            '.',\r\n            '-.',\r\n            ',',\r\n            '-,',\r\n            '.-',\r\n            ',-',\r\n        ])) {\r\n            throwError(`The custom locale format option 'outputFormat' is invalid ; it should either be null, 'string', 'number', '.', '-.', ',', '-,', '.-' or ',-', [${options.outputFormat}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\r\n            throwError(`The debug option 'failOnUnknownOption' is invalid ; it should be either 'false' or 'true', [${options.failOnUnknownOption}] given.`);\r\n        }\r\n    };\r\n\r\n    $.fn.autoValidate = validate;\r\n\r\n    /**\r\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n     *\r\n     * @param {object} options\r\n     * @returns {boolean}\r\n     */\r\n    areSettingsValid = function(options) {\r\n        let isValid = true;\r\n        try {\r\n            validate(options);\r\n        }\r\n        catch (error) {\r\n            isValid = false;\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    /**\r\n     * Take an arabic number as a string and return a javascript number.\r\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n     * This returns `NaN` is the conversion is not possible.\r\n     * Based on http://stackoverflow.com/a/17025392/2834898\r\n     *\r\n     * @param {string} arabicNumbers\r\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n     * @param {boolean} parseDecimalCharacter\r\n     * @param {boolean} parseThousandSeparator\r\n     * @returns {string|number|NaN}\r\n     */\r\n    function arabicToLatinNumbers(arabicNumbers, returnANumber = true, parseDecimalCharacter = false, parseThousandSeparator = false) {\r\n        let result = arabicNumbers.toString();\r\n        if (result === '' || result.match(/[]/g) === null) {\r\n            // If no Arabic/Persian numbers are found, return the numeric string directly\r\n            return arabicNumbers;\r\n        }\r\n\r\n        if (parseDecimalCharacter) {\r\n            result = result.replace(//, '.'); // Decimal character\r\n        }\r\n\r\n        if (parseThousandSeparator) {\r\n            result = result.replace(//g, ''); // Thousand separator\r\n        }\r\n\r\n        // Replace the numbers only\r\n        result = result.replace(/[]/g, d => d.charCodeAt(0) - 1632) // Arabic numbers\r\n                       .replace(/[]/g, d => d.charCodeAt(0) - 1776); // Persian numbers\r\n\r\n        // `NaN` has precedence over the string `'NaN'`\r\n        const resultAsNumber = Number(result);\r\n        if (isNaN(resultAsNumber)) {\r\n            return resultAsNumber;\r\n        }\r\n\r\n        if (returnANumber) {\r\n            result = resultAsNumber;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a custom event and immediately sent it from the given element.\r\n     * By default, if no element is given, the event is thrown from `document`.\r\n     *\r\n     * @param {string} eventName\r\n     * @param {Element} element\r\n     * @param {object} detail\r\n     */\r\n    function triggerEvent(eventName, element = document, detail = null) {\r\n        let event;\r\n        if (window.CustomEvent) {\r\n            event = new CustomEvent(eventName, { detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\r\n        } else {\r\n            event = document.createEvent('CustomEvent');\r\n            event.initCustomEvent(eventName, true, true, { detail });\r\n        }\r\n\r\n        element.dispatchEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\r\n    (function() {\r\n        if (typeof window.CustomEvent === 'function') {\r\n            return false;\r\n        }\r\n\r\n        function CustomEvent(event, params) {\r\n            params = params || { bubbles: false, cancelable: false, detail: void(0) };\r\n            const evt = document.createEvent('CustomEvent');\r\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n            return evt;\r\n        }\r\n\r\n        CustomEvent.prototype = window.Event.prototype;\r\n        window.CustomEvent = CustomEvent;\r\n    })();\r\n\r\n    $.extend(true, defaultSettings, $.fn.autoNumeric.lang.Turkish, { currencySymbol: '' });\r\n\r\n    // Hijack the original val fn in order to\r\n    // use $autoNumeric.val() and be able to get/set\r\n    // the unmasked value.\r\n    $.fn.val = function(value) {\r\n        const me = this;\r\n        const $me = $(me);\r\n\r\n        // If we're not dealing with an instance of autoNumeric,\r\n        // simply call the original jQuery.fn.val\r\n        if ($me.data('autoNumeric') === undefined) {\r\n            return jQueryOriginalVal.apply(me, arguments); // eslint-disable-line prefer-rest-params\r\n        }\r\n\r\n        if (!arguments.length) { // We're trying to read the numeric value\r\n            return $me.autoNumeric('get');\r\n        }\r\n        else { // We're trying to set a value\r\n            const originalVal = value;\r\n            let numericValue;\r\n\r\n            if (typeof value === 'string') {\r\n                value = value.replace(',', '.');\r\n                numericValue = parseFloat(value, 10);\r\n\r\n                if (isNaN(numericValue)) {\r\n                    throw `\"${originalVal}\" is not a number.`;\r\n                }\r\n            }\r\n            else if (typeof value !== 'number') {\r\n                throw `The type \"${typeof value}\" is not supported.`;\r\n            }\r\n            else {\r\n                numericValue = value;\r\n            }\r\n\r\n            return $me.autoNumeric('set', numericValue);\r\n        }\r\n    };\r\n}));\r\n\r\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\r\nexport default {\r\n    format  : autoFormat,\r\n    unFormat: autoUnFormat,\r\n    getDefaultConfig,\r\n    getLanguages,\r\n    validate, // an.validate(options) : throws if necessary\r\n    areSettingsValid, // an.areSettingsValid(options) : return true or false //TODO Is this redundant? Should we let the developers wrap each autoNumeric.validate() calls in try/catch block? Or should we just facilitate their life by doing it already?\r\n\r\n    //TODO Complete the interface with functions having the following signatures :\r\n    //init         : an.init(options, input)\r\n    //get          : an.get(input)\r\n    //set          : an.set(value, input)\r\n    //formString   : an.formString(form)\r\n    //formArray    : an.formArray(form)\r\n    //getFormatted : an.getFormatted(input)\r\n    //unset        : an.unset(input) //to rename to 'unformat'? (and merge with autoUnFormat/unFormat?)\r\n    //reformat     : an.reformat(input) // 'reSet' is very to close to 'reset' and therefore should be renamed. We could still expose 'reSet', but add a @deprecated tag on its declaration.\r\n    //settings     : an.settings(input)\r\n    //update       : an.update(options, input)\r\n    //wipe         : an.wipe(input)\r\n    //destroy      : an.destroy(input)\r\n\r\n    //raw          : an.raw(input) // Return the unformatted value as a string\r\n    //number       : an.number(input) // Return the unformatted value as a number (Warning: This can lead to precision problems with big numbers)\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/autoNumeric.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}